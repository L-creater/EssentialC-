[{"title":"音视频编解码技术基础","url":"/2024/01/18/音视频/基础知识/音视频编解码技术基础/","content":"\n## 编码格式和封装格式\n\n音视频封装格式是属于文件格式的二进制存储的。**可以把多个流数据合并到一个文件里面**，这就是封装格式\n\n因为编码压缩系统输出的是单路流，视频编码系统输出视频流，音频编码系统输出 音频流，**封装格式就是它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起**。\n\n这里将牛奶加工和音频视频的编码格式和封装格式做个对比。\n![Alt text](../../../images/音视频/assets/编码格式_封装格式.png)\n\n**编码(codec)** 是对原材料的加工，生牛乳不容易运输和传送，体积大质量重，所以加工压缩成奶粉或者奶酪。同样道理，原始的图像和声音是需要占用很大的存储空间和带宽的，不适合运输和传送，所以我们需要对原始图像和声音加工，压缩得更小。而 **编码(codec)** 就是图像和声音的压缩方法。对于视频，主要有 H263、H264、H265、MPEG系列等。\n\n编码(codec)对应的概念还有**解码**，其实**codec**是编解码（**Coder**）和解码（**Decoder**）的合称。编码后的东西是不容易消费的，所以需要解码。「解码」就是把编码后的东西还原为原来的状态。对奶粉来说，就是加水冲泡为可以喝的牛奶。对于视频来说，就是把压缩的图像和声音还原为正常可以播放的图像和声音。\n\n而**封装格式(format)**，或者容器(container)，是为了运输和传送的。对奶粉来说，格式就是金属罐、玻璃瓶、塑料袋等不同规格的容器。没有瓶瓶罐罐，奶粉是很难交付给普通消费者的。对视频来说是MP4、AVI、MKV、RMVB等格式。\n\n### 常见的视频封装格式\n\n* AVI (.avi)\n* ASF（.asf）\n* WMV (.wmv)\n* QuickTime ( .mov)\n* MPEG (.mpg / .mpeg)\n* MP4 (.mp4)\n* m2ts （.m2ts / .mts ）\n* Matroska （.mkv / .mks / .mka）\n* RM ( .rm / .rmvb)\n* TS/PS\n* FLV\n\n### 常见的视频编码格式\n\n**视频编码两大标准**\n\n* “国际电联（ITU-T）”，它制定的标准有H.261、H.263、H.263+、H.264等，\n* “国际标准化组织（ISO）”它制定的标准有MPEG-1、MPEG-2、MPEG-4等。\n\n**常见的视频编码格式**\n\n* Xvid(MPEG4)\n* H265(High Efficiency Video Coding,简称 HEVC)\n* H264\n* H263\n* MPEG1，MPEG2\n* AC-1\n* RM，RMVB\n\n目前最常见的视频编码方式的大致性能排序基本是：\n\nMPEG-1/-2 < WMV/7/8 < RM/RMVB < Xvid/Divx < AVC/H.264（由低到高，可能不完全准确）。\n\n### 常见的音频编码格式\n\n* AAC : Advanced Audio Coding\n* AMR\n* PCM\n* ogg(ogg vorbis音频)\n* AC3(DVD 专用音频编码)\n* DTS(DVD 专用音频编码)\n* APE(monkey’s 音频)\n* AU(sun 格式)\n* WMA\n* MP3\n\n封装格式就是把视频数据和音频数据打包成一个文件的规范。仅仅靠看文件的后缀，很难能看出具体使用了什么视音频编码标准\n\n## 硬解码和软解码\n\n* 软解：CPU解码\n* 硬解：GPU解码\n\n## 直播\n\n**时实**\nMP4 格式的box结构要全部视频录完才能生成，而直播是不知道什么时候结束的。而 FLV 是一种渐进式的格式，非常适合用于直播。\n\n所以不同的封装格式，是解决不同场景的问题。不过封装格式还会解决一些共同的问题，就是音视频同步。封装格式会给每个视频帧跟音频帧打上一个时间戳 PTS。\n\n播放器单独播放视频流，或者音频流的时候，是不需要这个 PTS 时间戳的，视频流按帧率播放，音频流按采样率播放即可。这个 PTS 可以帮助音视频同步。\n\n## 点播\n\n什么是点播?\n**提前录制好的，可随时观看。**\n就是视频已经录好了，放在服务器，客户端按需拉取一小端内容播放，不需要下载全部的视频内容。点播场景比较适合用 MP4 格式，因为 MP4 格式定义了 stts 索引表以及一些相关的数据结构，可以很快的跳转，例如 跳转 某个时间点播放，MP4 格式会比 FLV 快很多。（补充：FLV 可以额外添加 keyframeindex 加快跳转速度）\n\n## 视频帧\n\n### I帧:帧内编码帧\n\n尽可能去除图像空间冗余信息来压缩传输数据量的帧内编码图像\n\nI 帧（可参考，关键帧，帧内编码）是一个自足的帧。它不依靠任何东西来渲染，I 帧与静态图片相似。第一帧通常是 I 帧，但我们将看到 I 帧被定期插入其它类型的帧之间。\n**I帧特点:**\n1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;\n2.解码时仅用I帧的数据就可重构完整图像;\n3.I帧描述了图像背景和运动主体的详情;\n4.I帧不需要参考其他画面而生成;\n5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);\n6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;\n7.I帧不需要考虑运动矢量;\n8.I帧所占数据的信息量比较大。\n\n### P帧：前向预测编码帧\n\n通过充分将低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧\n\n**P 帧利用了一个事实：当前的画面几乎总能使用之前的一帧进行渲染。** 例如，在第二帧，唯一的改变是球向前移动了。仅仅使用（第二帧）对前一帧的引用和差值，我们就能重建前一帧。\n![Alt text](../../../images/音视频/assets/p帧.png)\n**P帧的预测与重构**\nP帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。\n\n**P帧特点:**\n\n1. P帧是I帧后面相隔1~2帧的编码帧;\n2. P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);\n3. 解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;\n4. **P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;**\n5. P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;\n6. 由于P帧是参考帧,它可能造成解码错误的扩散;\n7. 由于是差值传送,P帧的压缩比较高。\n\n### B帧：双向预测内插编码帧\n\n既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像，也叫双向预测帧\n![Alt text](../../../images/音视频/assets/B帧.png)\n\n**B帧的预测与重构**\nB帧**以前面的I或P帧和后面的P帧为参考帧**,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。\n\n**B帧特点**\n\n1. **B帧是由前面的I或P帧和后面的P帧来进行预测的;**\n2. B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;\n3. **B帧是双向预测编码帧;**\n4. **B帧压缩比最高**,因为它只反映并参考帧间运动主体的变化情况,预测比较准确;\n5. B帧不是参考帧,不会造成解码错误的扩散。\n\n注:I、B、P各帧是根据压缩算法的需要,是人为定义的,它们都是实实在在的物理帧,至于图像中的哪一帧是I帧,是随机的,一但确定了I帧,以后的各帧就严格按规定顺序排列。\n\n> 一般地，I帧压缩效率最低，P帧较高，B帧最高。对于视频压缩推流过程中，首先考虑将B帧取消，然后是P帧。\n\n**为什么需要B帧？**\n\n 从上面的看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。那么为什么还要引入B帧？\n\n网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。\n\n### 显示和解码顺序示意图\n\n![Alt text](../../../images/音视频/assets/decoding_display.png)\n\n在H264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流。\n\n一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。\n\n一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。\n\n在视频编码序列中，GOP即Group of picture（图像组），指两个I帧之间的距离，Reference（参考周期）指两个P帧之间的距离。两个I帧之间形成一组图片，就是GOP（Group Of Picture）。\n\n### I帧和IDR帧区别\n\n将GOP中首个I帧要和其他I帧区别开，把第一个I帧叫IDR。\n\n**IDR帧的作用是立刻刷新,使错误不致传播,从IDR帧开始算新的序列开始编码。I帧有被跨帧参考的可能,IDR不会。**\n**严谨来说，应该是两个IDR帧之间的图像，称作一组gop，应该有些特殊情况，使一组Gop中存在多个I帧**\n\n如下图所示\n![Alt text](../../../images/音视频/assets/GOP.png)\n\n* GOP一般设置为25，50(一般为帧率的倍数)\n* 如果不是直播流，一般设置2帧连续B帧，以降低码率。\n  \n### PTS和DTS\n\n**为什么会有PTS和DTS的概念？**\n\n通过上面的描述可以看出：P帧需要参考前面的I帧或P帧才可以生成一张完整的图片，而B帧则需要参考前面I帧或P帧及其后面的一个P帧才可以生成一张完整的图片。这样就带来了一个问题：在视频流中，**先到来的 B 帧无法立即解码，需要等待它依赖的后面的 I、P 帧先解码完成，这样一来播放时间与解码时间不一致了，顺序打乱了**，那这些帧该如何播放呢？这时就引入了另外两个概念：**DTS 和 PTS**。\n\n**【PTS和DTS】**\nDTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。\nPTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。\n\n在视频采集的时候是录制一帧就编码一帧发送一帧的，在编码的时候会生成 PTS，**这里需要特别注意的是 frame（帧）的编码方式**。\n在通常的场景中，编解码器编码一个 I 帧，然后向后跳过几个帧，用编码 I 帧作为基准帧对一个未来 P 帧进行编码，然后跳回到 I 帧之后的下一个帧。编码的 I 帧和 P 帧之间的帧被编码为 B 帧。\n\n之后，编码器会再次跳过几个帧，使用第一个 P 帧作为基准帧编码另外一个 P 帧，然后再次跳回，用 B 帧填充显示序列中的空隙。这个过程不断继续，每 12 到 15 个 P 帧和 B 帧内插入一个新的 I 帧。\n\nP 帧由前一个 I 帧或 P 帧图像来预测，而 B 帧由前后的两个 P 帧或一个 I 帧和一个 P 帧来预测，因而编解码和帧的显示顺序有所不同，如下所示：\n\n![Alt text](../../../images/音视频/assets/decoding_display2.png)\n假设编码器采集到的帧是这个样子的：\n\n I B B P B B P\n\n那么它的显示顺序，也就是PTS应该是这样：\n\n 1 2 3 4 5 6 7\n\n推流顺序也是按照编码顺序去推的，即\n\n I P B B P B B\n\n那么接收到的视频流也就是\n\n I P B B P B B\n\n这时候去解码，也是按照收到的视频流一帧一帧去解的了，接收一帧解码一帧，因为在编码的时候已经按照 I、B、P 的依赖关系编好了，接收到数据直接解码就好了。那么解码顺序是：\n\n``` cpp\n     I P B B P B B\nDTS：1 2 3 4 5 6 7\nPTS：1 4 2 3 7 5 6\n```\n\n可以看到解码出来对应的 PTS 不是顺序的，为了正确显示视频流，这时候我们就必须按照 PTS 重新调整解码后的 frame(帧)，即\n\n``` cpp\n     I B B P B B P\nDTS：1 3 4 2 6 7 5\nPTS：1 2 3 4 5 6 7\n```\n\n如下图:\n\n![Alt text](../../../images/音视频/assets/decoding_display3.png)\n\n* I frame 的解码不依赖于任何的其它的帧.\n* p frame 的解码则依赖于其前面的 I frame 或者 P frame.\n* B frame 的解码则依赖于其前的最近的一个 I frame 或者 P frame 及其后的最近的一个 P frame.\n\n另外，并不是一定要使用B帧。在实时互动直播系统中，很少使用B帧。主要的原因是压缩和解码B帧时，由于要双向参考，所以它需要缓冲更多的数据，且使用的CPU也会更高。由于实时性的要求，所以一般不使用它。不过对于播放器来说，遇到带有B帧的H264数据是常有的事儿。**在没有B帧的情况下，存放帧的顺序和显示帧的顺序就是一样的，PTS和DTS的值也是一样的。**\n\n### 音视频同步\n\n上面说了视频帧、DTS、PTS 相关的概念。我们都知道在一个媒体流中，除了视频以外，通常还包括音频。音频的播放，也有 DTS、PTS 的概念，但是音频没有类似视频中 B 帧，不需要双向预测，所以**音频帧的 DTS、PTS 顺序是一致的。**\n\n## 参考\n\n<https://feater.top/ffmpeg/the-introduction-of-ibp-frame>\n<https://zhuanlan.zhihu.com/p/137686779>\n<https://www.cnblogs.com/yongdaimi/p/10676309.html>\n","tags":["音视频基础知识"]},{"title":"ffmepg常用命令","url":"/2024/01/17/FFmpeg/ffmepg常用命令/","content":"\n## 帮助命令的帮助\n\n``` bash\nffmpeg -h\n```\n\n``` cpp\nusage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...\n\n简单来讲就是\n\nffmpeg [一些选项] [[输入文件的选项] -i 输出文件的路径] {[输出文件的选项] 输出文件路径}\n```\n\n### 查看支持的formats/decoders\n\n``` bash\n//支持的封装格式(合并&&分离)\nffmpeg -formats \n//合并\nffmpeg -muxers\n//分离\nffmpeg -demuxers\n\n//支持的过滤器\nffmpeg -filters\n\n//支持的编解码器\nffmepg -codecs\n//支持的解码器\nffmpeg -decoders\n//支持的编码器\nffmpeg -encoders\n\n//支持的硬编解列表\nffmpeg -hwaccels\n\n//位流格式\nffmpeg -bsfs\n\n//像素格式\nffmpeg -pix_fmts\n\n//采样格式\nffmpeg -sample_fmts\n\n```\n\n### 查看具体支持某一种格式，类似这样\n\n``` bash\nffmpeg -h muxer=flv\n```\n\n如果不支持 就是unknown了\n![Alt text](../../images/FFmpeg/ffmpeg_unknown.png)\n\n其他的还有\n\n```bash\nffmpeg -h filter=atempo\n\nffmpeg -h encoder=libx264\n```\n\n## FFPlay\n\n### 命令格式\n\nffplay 是一个播放器 他的命令格式为： `ffplay [options] [input_url]`\n\n### 主要命令\n\n### 主要选项有\n\n``` bash\n选项 说明\n-x width 强制显示宽带。\n-y height 强制显示高度。\n-s size 帧尺寸 设置显示帧存储(WxH格式)，仅适用于类似原始YUV等没有包含帧大小(WxH)的视频。该参数已经被废弃，请尝试用-video_size代替\n-fs 以全屏模式启动。\n-an 禁用音频（不播放声音）\n-vn 禁用视频（不播放视频）\n-sn 禁用字幕（不显示字幕）\n-ss pos 根据设置的秒进行定位拖动，注意时间单位：比如'55' 55 seconds, '12:03:45' ,12 hours, 03 minutes and 45 seconds, '23.189' 23.189 second\n-t duration 设置播放视频/音频长度，时间单位如 -ss选项\n-bytes 按字节进行定位拖动。\n-seek_interval interval 自定义左/右键定位拖动间隔（以秒为单位），默认值为10秒\n-nodisp 关闭图形化显示窗口，视频将不显示\n-noborder 无边框窗口\n-volume vol 设置起始音量。音量范围[0 ~100]\n-f fmt 强制使用设置的格式进行解析。比如-f s16le\n-window_title title 设置窗口标题（默认为输入文件名）\n-loop number 设置播放循环次数\n-showmode mode 设置显示模式，可用的模式值：0 显示视频，1 显示音频波形，2 显示音频频谱。缺省为0，如果视频不存在则自动选择2\n-vf filtergraph 设置视频滤镜\n-af filtergraph 设置音频滤镜\n```\n\n### 高级命令\n\n**高级选项**\n\n``` bash\n-pix_fmt format 格式设置像素格式。此选项已被弃用，有利于私有选项，try -pixel_format\n-stats 打印多个回放统计信息，包括显示流持续时间，编解码器参数，流中的当前位置，以及音频/视频同步差值。默认情况下处于启用状态，要显式禁用它则需要指定-nostats。\n-fast 非标准化规范的多媒体兼容优化\n-genpts 生成pts。\n-sync type 同步类型 将主时钟设置为audio（type=audio），video（type=video）或external（type=ext），默认是音频为主时钟。\n-ast audio_stream_specifier 指定音频流索引，比如-ast 3，播放流索引为3的音频流\n-vst video_stream_specifier 指定视频流索引，比如-vst 4，播放流索引为4的视频流\n-sst subtitle_stream_specifier 指定字幕流索引，比如-sst 5，播放流索引为5的字幕流\n-autoexit 视频播放完毕后退出。\n-exitonkeydown 键盘按下任何键退出播放\n-exitonmousedown 鼠标按下任何键退出播放\n-codec:media_specifier codec_name 强制使用设置的多媒体解码器，media_specifier可用值为a（音频）， v（视频）和s字幕。比如-codec:v h265 强制视频采用h265解码\n-acodec codec_name 强制使用设置的音频解码器进行音频解码\n-vcodec codec_name 强制使用设置的视频解码器进行视频解码\n-scodec codec_name 强制使用设置的字幕解码器进行字幕解码\n-autorotate 根据文件元数据自动旋转视频。默认情况下启用，若需禁用则使用-noautorotate\n-framedrop 如果视频不同步则丢弃视频帧。当主时钟非视频时钟时默认开启。若需禁用则使用 -noframedrop\n-infbuf 不限制输入缓冲区大小。尽可能快地从输入中读取尽可能多的数据。播放实时流时默认启用，如果未及时读取数据，则可能会丢弃数据。此选项将不限制缓冲区的大小。若需禁用则使用-noinfbuf\n```\n\n### 播放控制\n\n``` bash\n选项 说明\nq, ESC 退出播放\nf 全屏切换\np, SPC 暂停\nm 静音切换\n9, 0 9减少音量，0增加音量\n/, * /减少音量，*增加音量\na 循环切换音频流\nv 循环切换视频流\nt 循环切换字幕流\nc 循环切换节目\nw 循环切换过滤器或显示模式\ns 逐帧播放\nleft/right 向后/向前拖动10秒\ndown/up 向后/向前拖动1分钟\npage down/page up 拖动上一个/下一个。或者如果没有章节向后/向前拖动10分钟。\n鼠标右键单击 拖动与显示宽度对应百分比的文件进行播放\n鼠标左键双击 全屏切换\n\n```\n\n### 举个🌰？\n\n#### 播放本地文件\n\n最直接：`ffplay test_video.mp4`\n\n`ffplay -window_title \"mirs ffplay\" -ss 2 -t 10 -autoexit test.mp4`\n\n#### 播放网络流\n\n`ffplay rtmp://live.hkstv.hk.lxdns.com/live/hks1`\n\n#### 视频旋转播放\n\n`ffplay -i test_video.mp4 -vf transpose=1`\n\n#### 视频反转播放\n\n(镜面)`ffplay test_video.mp4 -vf hflip`\n(上下) `ffplay test_video.mp4 -vf vflip`\n\nps：视频旋转和反转可以组合食用 （听说巧克力和牛奶更配哟）\n\n#### 变速播放\n\n* 音频变速视频不变速 （1.5倍食用更佳）\n  * `ffplay -i test_video.mp4 -af atempo=1.5`\n* 视频变速音频不变速\n  * `ffplay -i test_video.mp4 -vf setpts=PTS/1.5`\n* 音视频一起变速(3倍！！！)\n  * `ffplay -i test_video.mp4 -vf setpts=PTS/3 -af atempo=3`\n\n## ffmpeg\n\n终于到ffmepg了，我们首先来吧他常用的参数分个类\n\n### 常用参数\n\n``` bash\n主要参数：\n-i 设定输入流\n-f 设定输出格式\n-ss 开始时间\n-t   时间长度\n\n视频参数：\n-vframes 设置要输出的视频帧数\n-b 设定视频码率，默认为200Kbit/s\n-b:v 视频码率\n-r 设定帧速率，默认为25\n-s 设定画面的宽与高\n-aspect 设定画面的比例\n-vn 不处理视频\n-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器\n-vf 视频滤波器\n\n音频参数：\n-aframes 设置要输出的音频帧数\n-b:a 音频码率\n-ar 设定采样率\n-ac 设定声音的Channel数\n-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器\n-an 不处理音频\n-af 音频滤波器\n\n```\n\n### 举个🌰？\n\n#### 分离视频音频流\n\n* 分离音频\n  * `ffmpeg -i test_video.mp4 -acodec copy -vn audio.aac`\n  * 然后...\n\n* 分离视频\n  * `ffmpeg -i test_video.mp4 -vcodec copy -an video.mp4`\n* 提取H264\n  * `ffmpeg -i test_video.mp4 -vcodec copy -an test_copy.264`\n* 提取AAC\n  * `ffmpeg -i test_video.mp4 -acodec copy -vn test.aac`\n* 改变编码格式\n  * `ffmpeg -i test_video.mp4 -vcodec copy -acodec copy test_copy.ts`\n* 修改帧率\n  * `ffmpeg -i test_video.mp4 -r 15 output.mp4`\n* 修改码率\n  * `ffmpeg -i test_video.mp4 -b:v 1.5M output2.mp4`\n* 修改音频码率\n  * `ffmpeg -i test_video.mp4 -b:a 192k output2.mp4`\n* 修改音视频码率\n  * `ffmpeg -i test_video.mp4 -b:v 1.5M -b:a 192k output2.mp4`\n* 修改分辨率\n  * `ffmpeg -i test_video.mp4 -s 640x480 output.mp4`\n* 提取PCM\n  * `ffmpeg -i test.mp4 -f s16le audio.pcm`\n* 提取YUV\n  * 提取3秒 分辨率和原来的一致\n  * `ffmpeg -i test_video.mp4 -t 3 -pix_fmt yuv420p yuv420p_orig.yuv`\n  * 提取3秒 指定分辨率\n  * `ffmpeg -i test_video.mp4 -t 3 -pix_fmt yuv420p -s 320x240 yuv420p_320x240.yuv`\n* 提取RGB\n  * 提取3秒数据，分辨率转为320x240\n  * `ffmpeg -i test_video.mp4 -t 3 -pix_fmt rgb24 -s 320x240 rgb24_320x240.rgb`\n* RGB和YUV转换\n  * `ffmpeg -s 968x544 -pix_fmt yuv420p -i yuv420p_orig.yuv -pix_fmt rgb24 orig.rgb`\n\n原文链接\n<https://juejin.cn/post/6844903815918026760>\n","tags":["FFmpeg"]},{"title":"YUV格式介绍","url":"/2024/01/05/音视频/基础知识/YUV格式介绍/","content":"<!-- # YUV数据格式 -->\n\nYCbCr颜色空间，又常被称作YUV颜色空间，是用于数字电视的颜色空间，在ITU-R BT.601、BT.709、BT.2020标准中被明确定义，这三种标准分别针对标清、高清、超高清数字电视。Y是亮度，Cb（U）、Cr（V）表示色度，描述颜色的色调与饱和度。其中Cr反映RGB中红色部分与Y亮度值之间的差异；Cb则反映蓝色部分与亮度值之间的差异。在广播电视中，使用YCbCr可解决黑白电视和彩色电视之间的信号兼容问题。\n\nHVS （Human Visual System）人类视觉系统 对 色彩空间的感知能力。\n\n视觉心理学研究表明，人的视觉系统对光的感知程度可以用两个属性来描述：亮度（luminance）跟 色度（chrominance），这里的色度也叫做 饱和度或彩度，总之 色度的叫法有很多，要注意上下文来区分语义。\n\n然后 色度感知 包含两个维度：**色调**（Hue）和 **色饱和度**（saturation）。色调是由光波的峰值定义的，描述的是光的颜色。色饱和度是由光波的谱宽定义的，描述的是光的纯度。\n\n因此 HVS 对色彩的感知主要有 3个属性：**亮度**（luminance），**色调**（Hue）和 **色饱和度**（saturation）。也就是 YUV 色彩空间，Y 代表 亮度，U代表色调，V代表色饱和度。\n\n经过大量研究实验表明，**视觉系统 对 色度 的敏感度 是远小于 亮度的。所以可以对 色度 采用更小的采样率来压缩数据，对亮度采用正常的采样率即可，这样压缩数据不会对视觉体验产生太大的影响。** 简单来说就是用更少的数据/信息来表达 色度（chroma），用更多的数据/信息来表达 亮度（luminance）。\n\n## YUV 格式\n\n1. planner ：平面格式， 先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。\n注意：这里的连续存储，不是一行像素里面连续存储，是整张图片的连续存储，例如一张图片是 6075kb 大小，那第 1~ 2025kb 都是 Y 的数据， 2026 ~ 4050kb 都是 像素点的 U 数据，以此类推。\n\n2. semi-Planar：半平面的YUV格式，Y分量单独存储，但是UV分量交叉存储。\n\n3. packed ：每个像素点的Y,U,V是连续交错存储的。\n\n## YUV 4:4:4 存储格式\n\n基于YUV 4:4:4采样，每一个Y对应一组UV分量,一个YUV占8+8+8 = 24bits 3个字节。\n\nYUV4:4:4在存储格式上和RGB图像的存储方法一致，Y、U、V三个分量连续存放，如下图所示。\n![Alt text](../../../images/音视频/assets/YUV_444.png)\n\n## YUV 4:2:2 存储格式\n\n基于YUV 4:2:2采样，每两个Y共用一组UV分量,一个YUV占8+4+4 = 16bits 2个字节。\n\n### YUYV\n\nYUYV格式为YUV422采样的存储格式中的一种，遵循YUV422存储格式的基本原则，相邻的两个像素点的Y共用其相邻的两个U、V。对于相邻两个像素点的Y00、Y01而言，其U、V的值均为 U00、V00，其他的像素点的YUV取值依此类推。\n![Alt text](../../../images/音视频/assets/YUYV_422.png)\n\n### YVYU\n\nUYVY格式也是YUV422采样的存储格式中的一种，与YUYV不同的是UV排列顺序不一样，UV共用方法与上述一致。\n![Alt text](../../../images/音视频/assets/YVYU_422.png)\n\n### YUV422P\n\nYUV422P格式也属于YUV422采样的存储格式中的一种，它是一种Plane模式，即平面模式。与上述两种存储方式的区别在于并不是将YUV数据交错存储，而是先存放所有的Y分量，然后再存储所有的U分量，最后存储所有的V分量。\n![Alt text](../../../images/音视频/assets/YUV422P.png)\n\n## YUV 4:2:0 存储格式\n\n每四个Y共用一组UV分量,一个YUV占8+2+2 = 12bits 1.5个字节。\n\n### YU12，YV12\n\nYU12格式和YV12格式均属于YUV420格式，也是一种Plane模式，将Y、U、V分开依次存储。其中每一个像素点的YUV数据遵循YUV420存储格式的基本原则，即4个Y分量共用一组UV。如下图所示。\n![Alt text](../../../images/音视频/assets/YU12_YV12.png)\n\n### NV12，NV21\n\nV12格式和NV21格式也属于YUV420格式，是一种two-plane格式，即Y分量和UV分量各自占一部分， UV分量交错存储。\n\n![Alt text](../../../images/音视频/assets/NV12_NV21.png)\n\n**重点：YUV420 比 YUV444 少了一半数据，视觉体验几乎没有变化。**\n\n参考：\n<https://mp.weixin.qq.com/s/gbRKy2b-ujDRLM63L6ReRA>\n<https://feater.top/ffmpeg/the-introduction-of-yuv>\n<https://ffmpeg-vip.xianwaizhiyin.net/base-knowledge/raw-yuv.html>\n<https://github.com/lyt-s/digital_video_introduction/blob/master/README-cn.md>\n","tags":["音视频基础知识"]},{"title":"cmake","url":"/2024/01/04/cmake/cmake/","content":"<!-- # CMakeLists.txt -->\n\n根项目的 CMakeLists.txt 负责处理全局有效的设定。\n\n而子项目的 CMakeLists.txt 则仅考虑该子项目自身的设定，比如他的头文件目录，要链接的库等等。\n\n## 科普：亲 Unix 软件从源码安装的通用套路\n\n```bash\nMakefile 构建系统：\n./configure --prefix=/usr --with-some-options    # 生成 Makefile（这个 configure 脚本由 Autoconf 生成）\nmake -j 8                # 8 核心编译，生成 libtest.so\nsudo make install   # 安装，拷贝到 /usr/lib/libtest.so\n\nCMake 构建系统：\ncmake -B build -DCMAKE_INSTALL_PREFIX=/usr -DWITH_SOME_OPTIONS=ON  # 生成 Makefile\ncmake --build build --parallel 8                  # 8 核心编译，生成 libtest.so\nsudo cmake --build build --target install    # 安装，拷贝到 /usr/lib/libtest.so\n\n注：如果 -DCMAKE_INSTALL_PREFIX=/usr/local 则会拷贝到 /usr/local/lib/libtest.so\n\n```\n\n## 如果第三方库发懒，没有提供 Config 文件怎么办？\n\n但是，也有少数不听话的库，官方不提供 CMake 支持，即安装时不自带 Config 文件。\n恼人的是，这些不听话的库有些竟然是非常热门的库！例如 Python，CUDA，Jemalloc。\n为了不影响 CMake 用户体验，CMake 发明了 Find 文件（FindXXX.cmake），你不支持我是吧？我支持你！Find 文件会在 CMake 安装时负责安装到`/usr/share/cmake/Modules`。\n包搜索文件可以在不知道包具体位置信息的情况下搜索他们（在 `/usr/lib` 等默认路径搜索）。\n这些都是 CMake 自带的包搜索文件：\n`/usr/share/cmake/Modules/FindCUDAToolkit.cmake`\n`/usr/share/cmake/Modules/FindPython.cmake`\n那么如果有个不太热门的第三方库没提供包配置文件，CMake 也没提供包搜索文件，我们该如何找到他？这就需要自己提供包搜索文件了！别担心，你不用自己写，`GitHub` 上有很多志士仁人已经写过了对应的包搜索文件，你搜一下 FindXXX.cmake 就能找到了。\n\n**举例：FindJemalloc.cmake**\n\n**注意不论是项目自己的头文件还是外部的系统的头文件，请全部统一采用 <项目名/模块名.h> 的格式。不要用 “模块名.h” 这种相对路径的格式，避免模块名和系统已有头文件名冲突。**\n\n![image-20230712103514686](../../images/cmake/assets/image-20230712103514686.png)\n\n## 一个标准的 CMakeLists.txt 模板\n\n![image-20230714162906960](../../images/cmake/assets/image-20230714162906960.png)\n\n### 小技巧\n\n1. CMake 的 ${} 表达式可以嵌套\n\n2. 设定一个变量的默认值\n\n```cmake\nif(NOT DEFINED BUILD_SHARED_LIBS)\n SET(BUILD_SHARED_LIBS ON)\nendif()\n```\n\n### 常见坑点\n\n**动态库无法链接静态库**\n\n### 一些参数的含义\n\n1. `CMAKE_CURRENT_SOURCE_DIR` -- 当前CMakeList.txt所在的路径。\n\n2. `CMAKE_CURRENT_BINARY_DIR` --  表示当前输出目录的位置，例如 ~/hellocmake/build。\n\n3. `CMAKE_SOURCE_DIR` -- 表示整个项目最外面的CMakeList.txt\n\n4. `PROJECT_SOURCE_DIR` 表示最近一次调用 project 的 CMakeLists.txt 所在的源码目录。\n\n   1. 利用 `PROJECT_SOURCE_DIR` 可以实现从子模块里直接获得项目最外层目录的路径。\n\n   2. ![image-20230714160654000](../../images/cmake/assets/image-20230714160654000.png)\n\n   3. > **子模块里也可以用 project 命令，将当前目录作为一个独立的子项目**\n      >\n      > --- 这样一来 `PROJECT_SOURCE_DIR` 就会是子模块的源码目录而不是外层了。这时候 `CMake` 会认为这个子模块是个独立的项目，会额外做一些初始化。他的构建目录 `PROJECT_BINARY_DIR` 也会变成 build/<源码相对路径>。这样在 MSVC 上也会看见 `build/mylib/mylib.vcxproj` 的生成。\n      >\n      > ![image-20230714161111648](../../images/cmake/assets/image-20230714161111648.png)\n\n   4. project(项目名 LANGUAGES 使用的语言列表...)  指定了该项目使用了哪些编程语言。--- 如果不指定 LANGUAGES，默认为 C 和 CXX。\n\n   5. `CMAKE_CXX_STANDARD` 是一个整数，表示要用的 C++ 标准。比如需要 C++17 那就设为 17，需要 C++23 就设为 23。\n\n   6. `CMAKE_CXX_STANDARD_REQUIRED` 是 BOOL 类型，可以为 ON 或 OFF，默认 OFF。他表示是否一定要支持你指定的 C++ 标准：如果为 OFF 则 CMake 检测到编译器不支持 C++17 时不报错，而是默默调低到 C++14 给你用；为 ON 则发现不支持报错，更安全。\n\n   7. `CMAKE_CXX_EXTENSIONS` 也是 BOOL 类型，默认为 ON。设为 ON 表示启用 GCC 特有的一些扩展功能；OFF 则关闭 GCC 的扩展功能，只使用标准的 C++。\n\n   8. 要兼容其他编译器（如 MSVC）的项目，都会设为 OFF 防止不小心用了 GCC 才有的特性。此外，**最好是在 project 指令前设置 CMAKE_CXX_STANDARD 这一系列变量，**这样 CMake 可以在 project 函数里对编译器进行一些检测，看看他能不能支持 C++17 的特性。\n\n   9.  \n\n   ```cmake\n        cmake_minimum_required(VERSION 3.15)\n        set(CMAKE_CXX_STANDARD  17)\n        set(CMAKE_CXX_STANDARD_REQUIRED ON)\n        set(CMAKE_CXX_EXTENSIONS ON)\n        project(hellocmake LANUAGES CXX)\n        \n        # 请勿直接修改 CMAKE_CXX_FLAGS 来添加 -std=c++17（你在百度 CSDN 学到的用法）。\n        # 请使用 CMake 帮你封装好的 CMAKE_CXX_STANDARD（从业人员告诉你的正确用法）。\n        # 为什么百度不对：你 GCC 用户手动指定了 -std=c++17，让 MSVC 的用户怎么办？\n        # 此外 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加 -std=c++11 选项了，你再添加个 -std=c++17 选项不就冲突了吗？所以请用 CMAKE_CXX_STANDARD。\n\n      ```\n\n5. project(项目名 VERSION x.y.z) 可以把当前项目的版本号设定为 x.y.z。\n\n      - 之后可以通过 PROJECT_VERSION 来获取当前项目的版本号。\n      - PROJECT_VERSION_MAJOR 获取 x（主版本号）。\n      - PROJECT_VERSION_MINOR 获取 y（次版本号）。\n      - PROJECT_VERSION_PATCH 获取 z（补丁版本号）。\n      - **项目名的另一大作用：会设置另外 <项目名>_SOURCE_DIR 等变量**\n\n6. `PROJECT_IS_TOP_LEVEL` ：BOOL类型，表示当前项目是否是（最顶层的）根项目\n\n7. `PROJECT_NAME` ：当前项目名\n\n8. `CMAKE_PROJECT_NAME` ：根项目的项目名\n\n9. `CMAKE_PREFIX_PATH` -- 指定查找外部软件包或库时的前缀路径。 -- Unix 平台默认为 /usr。\n\n    ```cmake\n    set(CMAKE_PREFIX_PATH \"/path/to/library;/another/path/to/library\")\n    ```\n\n10. 安装库时， --prefix 选项，指定安装的根路径。\n\n11. `CMAKE_BUILD_TYPE`  -- 构建的类型，调试模式还是发布模式\n\n    - CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量，用于控制构建类型，他的值可以是\n\n    - Debug 调试模式，完全不优化，生成调试信息，方便调试程序Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢\n\n    - MinSizeRel 最小体积发布，生成的文件比 Release 更小，不完全优化，减少二进制体积\n\n    - RelWithDebInfo 带调试信息发布，生成的文件比 Release 更大，因为带有调试的符号信息默认情况下 CMAKE_BUILD_TYPE 为空字符串，这时相当于 Debug。\n\n      - **如何让 CMAKE_BUILD_TYPE 在用户没有指定的时候为 Release，指定的时候保持用户指定的值不变呢。** 就是说 CMake 默认情况下 CMAKE_BUILD_TYPE 是一个空字符串。因此这里通过 if (NOT CMAKE_BUILD_TYPE) 判断是否为空，如果空则自动设为 Release 模式。大多数 CMakeLists.txt 的开头都会有这样三行，为的是让默认的构建类型为发布模式（高度优化）而不是默认的调试模式（不会优化）。我们稍后会详细捋一遍类似于 CMAKE_BUILD_TYPE 这样的东西。绝大多数 CMakeLists.txt 开头都会有的部分，可以说是“标准模板”了。\n\n    ```cmake\n    if (NOT CMAKE_BUILD_TYPE)\n    set (CMAKE_BUILD_TYPE Release)\n    endif()\n    ```\n\n## set\n\n- 设置变量\n\n  ```cmake\n  add_executable(main)\n  set(source main.cpp other.cpp other.h)\n  target_sources(main PUBLIC ${sources})\n  ```\n\n## 构建和链接静态库和动态库 --- add_library\n\n```cmake\nadd_library(biology STATIC ${srcs})\n```\n\n- 创建目标——静态库。库的名称和源码文件名相同，具体代码如下：\n\n   ```cmake\n   add_library(message\n     STATIC\n       Message.hpp\n       Message.cpp\n     )\n     #创建hello-world可执行文件的目标部分不需要修改：\n     add_executable(hello-world hello-world.cpp)\n     #最后，将目标库链接到可执行目标：\n     target_link_libraries(hello-world message)\n    \n    #编译成功后，构建目录包含libmessage.a一个静态库(在GNU/Linux上)和hello-world可执行文件。\n   ```\n\n- `add_library(message STATIC Message.hpp Message.cpp)`：生成必要的构建指令，将指定的源码编译到库中。\n\n  - `add_library`的第一个参数是目标名。\n  - 整个`CMakeLists.txt`中，可使用相同的名称来引用库。生成的库的实际名称将由CMake通过在前面添加前缀`lib`和适当的扩展名作为后缀来形成。\n  - 生成库是根据第二个参数(`STATIC`或`SHARED`)和操作系统确定的。\n\n- `target_link_libraries(hello-world message)`: 将库链接到可执行文件。\n\n  - 此命令还确保`hello-world`可执行文件可以正确地依赖于消息库。\n  - 因此，在消息库链接到`hello-world`可执行文件之前，需要完成消息库的构建。\n\n  **CMake接受其他值作为`add_library`的第二个参数的有效值**\n\n  - **STATIC**：用于创建静态库，即编译文件的打包存档，以便在链接其他目标时使用，例如：可执行文件。\n  - **SHARED**：用于创建动态库，即可以动态链接，并在运行时加载的库。可以在`CMakeLists.txt`中使用`add_library(message SHARED Message.hpp Message.cpp)`从静态库切换到动态共享对象(DSO)。\n  - **OBJECT**：可将给定`add_library`的列表中的源码编译到目标文件，不将它们归档到静态库中，也不能将它们链接到共享对象中。如果需要一次性创建静态库和动态库，那么使用对象库尤其有用。我们将在本示例中演示。\n  - **MODULE**：又为DSO组。与`SHARED`库不同，它们不链接到项目中的任何目标，不过可以进行动态加载。该参数可以用于构建运行时插件。\n  \n- **add_library 无参数时，是静态库还是动态库?**\n\n  - 会根据 BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库。ON 则相当于 SHARED，OFF 则相当于 STATIC。\n\n  - 如果未指定 BUILD_SHARED_LIBS 变量，则默认为 STATIC。\n\n  - 因此，如果发现一个项目里的 add_library 都是无参数的，意味着你可以用：cmake -B build -DBUILD_SHARED_LIBS:BOOL=ON来让他全部生成为动态库。稍后会详解命令行传递变量的规则。\n\n``` cmake\n    set(BUILD_SHARED_LIBS ON)\n    add_library(mylib mylic.cpp)\n```\n\n## flie\n\n通过 **GLOB_RECRUSE** 为它批量添加了所有位于 `src` 和 `include` 下源码和头文件。\n\n![image-20230712103409952](../../images/cmake/assets/image-20230712103409952.png)\n\n```cmake\nfile(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp include/*.h)\nadd_library(biology STATIC ${srcs})\ntarget_include_directories(biology PUBLIC include)\n#因为子项目的 CMakeLists.txt 里指定的路径都是相对路径，所以这里指定 src 实际上是：根/biology/src。\n```\n\n这里我们给 biology 批量添加了 src/*.cpp 下的全部源码文件。\n\n**明明只有 *.cpp 需要编译，为什么还添加了 include/*.h?**\n\n为了头文件也能被纳入 VS 的项目资源浏览器，方便编辑。\n\n### GLOB 和 GLOB_RECRUSE 的区别\n\n``` cmake\nfile (GLOB myvar CONFIGURE_DEPENDS src/*.cpp)\nfile (GLOB_RECURSE myvar CONFIGURE_DEPENDS src/*.cpp)\n\n疑问1：都是按照通配符批量匹配文件，有什么区别？\nGLOB：  src/main.cpp（√） src/test/main.cpp（×）\nGLOB_RECURSE： src/main.cpp（√） src/test/main.cpp（√）\n区别在于 GLOB_RECURSE 允许 * 匹配嵌套的目录。\n\n疑问2：加了 CONFIGURE_DEPENDS 这个选项有什么区别？\n如果不加，在你创建新文件时，myvar 不会自动更新，还是旧的那几个文件，可能出现 undefined symbol，需要重新运行 cmake -B build 才能更新。\n加了，则每次 cmake --build 时自动检测目录是否更新，如果目录有新文件了，CMake 会自动帮你重新运行 cmake -B build 更新 myvar 变量。\n\n```\n\n## include\n\n- include 和 add_subdirectory 的区别\n  - include 相当于直接把代码粘贴过去，直接访问调用者的作用域。  -- 比如  include 中含有CMAKE_CURRENT_SOURCE_DIR时，此路径为调用include的文件的路径，而不是include内部的文件路径。\n  - include命令是在当前CMake脚本中执行，直接将指定文件的内容插入到该位置，并继续执行后续命令；而add_subdirectory命令则进入指定目录，并执行该目录下的CMakeLists.txt文件中定义的内容。\n  - include用于导入其他脚本的内容，而add_subdirectory用于处理其他目录中的项目的构建过程。\n\n## list\n\n## add_subdirectory\n\n```cmake\nadd_subdirectory(pybmain)\nadd_subdirectory(biology)\n```\n\n通过 `add_subdirectory` 把两个子项目 `pybmain` 和 `biology` 添加进来（顺序无关紧要），这会调用 `pybmain/CMakeLists.txt` 和 `biology/CMakeLists.txt`。\n\n## add_executable\n\n用于创建一个可执行文件目标。\n\n```cmake\nadd_executable(target_name [WIN32] [MACOSX_BUNDLE]\n    source1 source2 ...\n)\n# target_name是要创建的可执行文件目标的名称，可以根据需要自定义。\n# WIN32和MACOSX_BUNDLE是可选的参数，用于指定目标的属性。\n# source1、source2等是构成可执行文件的源文件（源代码文件）。\n```\n\n例：\n\n```cmake\nadd_executable(my_executable main.cpp helper.cpp)\n# add_executable命令创建了一个名为my_executable的可执行文件目标，\n# 该目标由main.cpp和helper.cpp这两个源文件构成。CMake会自动根据这些源文件生成对应的编译规则，并生成可执行文件。\n```\n\n- 可以根据需要在`add_executable`命令中指定不同的源文件，并可以在同一个CMakeLists.txt文件中多次使用`add_executable`命令创建多个可执行文件目标。\n- 使用`add_executable`命令后，您可以使用其他命令（如`target_link_libraries、target_include_directories`等）为目标添加依赖库、指定包含目录等其他属性和操作。\n\n## add_dependencies\n\n假设我们需要生成一个可执行文件,该文件生成需要链接a.so b.so c.so d.so四个动态库\n正常来讲,我们一把只需要以下两条指令即可:\n\n``` cmake\nadd_executable(main main.cpp)\ntarget_link_libraries(main a.so b.so c.so d.so)\n```\n\n但是编译的时候报错,一些符号的定义找不到,而这些符号恰恰就在这几个库中,假设在`a.so`和`b.so`中,在上述两条指令之间加上一条指令即可编译通过:\n\n``` cmake\nadd_executable(main a.so b.so)\n```\n\n原因比较简单,生成main需要依赖`a.so`和`b.so`中的符号定义,然而`a.so`和`b.so`库的生成是在main编译生产之后的,添加这条语句就是提醒编译器需要先生成main的依赖(a.so,b.so),然后再去生成main.\n\n## find_package\n\n**用于在CMake项目中查找和加载外部软件包或模块。**\n\n```cmake\nfind_package(<PackageName> [version] [EXACT] [QUIET] [CONFIG] [MODULE]\n             [REQUIRED] [[COMPONENTS] [components...]]\n             [OPTIONAL_COMPONENTS components...]\n)\n\n\n\n# package_name是要查找的软件包或模块的名称，如Boost、OpenCV等。\n# version是可选的参数，用于指定软件包的版本号。\n# EXACT关键字可以用于精确匹配指定版本的软件包。\n# QUIET关键字可以用于禁止输出查找过程中的消息。\n# MODULE关键字可以用于查找CMake模块。\n# REQUIRED关键字可以用于指定软件包是必需的，如果找不到，将报错并停止构建。\n```\n\n例:\n\n```cmake\nfind_package(OpenCV)\n# 查找名为 OpenCV 的包，找不到不报错，事后可以通过 ${OpenCV_FOUND} 查询是否找到。\nfind_package(OpenCV QUIET)\n# 查找名为 OpenCV 的包，找不到不报错，也不打印任何信息。\nfind_package(OpenCV REQUIRED)    # 最常见用法\n# 查找名为 OpenCV 的包，找不到就报错（并终止 cmake 进程，不再继续往下执行）。\nfind_package(OpenCV REQUIRED COMPONENTS core videoio)\n# 查找名为 OpenCV 的包，找不到就报错，且必须具有 OpenCV::core 和 OpenCV::videoio 这两个组件，如果没有这两个组件也会报错。\nfind_package(OpenCV REQUIRED OPTIONAL_COMPONENTS core videoio)\n# 查找名为 OpenCV 的包，找不到就报错，可具有 OpenCV::core 和 OpenCV::videoio 这两个组件，没有这两组件不会报错，通过 ${OpenCV_core_FOUND} 查询是否找到 core 组件。\n\n```\n\n### find_package 说是找“包”，到底是在找什么？\n\n`find_package(OpenCV)`实际上是在找一个名为`OpenCVConfig.cmake` 的文件。\n\n注：出于历史兼容性考虑，除了 `OpenCVConfig.cmake` 以外`OpenCV-config.cmake` 这个文件名也会被 CMake 识别到。\n\n同理，`find_package(Qt5)` 则是会去找名为`Qt5Config.cmake` 的文件。\n这些形如 包名 + Config.cmake 的文件，我称之为包配置文件。\n`Qt5Config.cmake`是你安装 `Qt5` 时，随 `libQt5Core.so` 等实际的库文件，一起装到你的系统中去的。以我的 `Arch Linux` 系统为例：\n包配置文件位于 `/usr/lib/cmake/Qt5/Qt5Config.cmake`\n实际的动态库文件位于`/usr/lib/libQt5Core.so`\n\n- 因此 `find_package` 并不是直接去找具体的动态库文件和头文件（例如  `libQt5Core.so`）。\n- 而是去找包配置文件（例如Qt5Config.cmake），这个配置文件里包含了包的具体信息，包括动态库文件的位置，头文件的目录，链接时需要开启的编译选项等等。而且某些库都具有多个子动态库，例如 Qt 就有 `libQt5Core.so`、`libQt5Widgets.so`、`libQt5Network.so`。因此 CMake 要求所有第三方库作者统一包装成一个 `Qt5Config.cmake` 文件包含所有相关信息（类似于 nodejs 的 `package.json`），比你单独的一个个去找动态库文件要灵活的多。\n- 包配置文件由第三方库的作者（Qt的开发团队）提供，在这个库安装时（Qt的安装程序或apt install等）会自动放到 /usr/lib/cmake/XXX/XXXConfig.cmake 这个路径（其中XXX是包名），供 CMake 用户找到并了解该包的具体信息。\n- /usr/lib/cmake 这个位置是 CMake 和第三方库作者约定俗成的，由第三方库的安装程序负责把包配置文件放到这里。如果第三方库的作者比较懒，没提供 CMake 支持（由安装程序提供XXXConfig.cmake），那么得用另外的一套方法（FindXXX.cmake），稍后细谈。\n\n### Windows 系统下的搜索路径\n\n``` cmake\n\n<prefix>/\n<prefix>/cmake/\n<prefix>/<name>*/\n<prefix>/<name>*/cmake/\n<prefix>/<name>*/(lib/<arch>|lib*|share)/cmake/<name>*/\n<prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/\n<prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/cmake/\n\n其中 <prefix> 是变量 ${CMAKE_PREFIX_PATH}，Windows 平台默认为 C:/Program Files。\n<name> 是你在 find_package(<name> REQUIRED) 命令中指定的包名。\n<arch> 是系统的架构名。\n\n```\n\n### Unix 类系统下的搜索路径\n\n```c\n<prefix>/(lib/<arch>|lib*|share)/cmake/<name>*/\n<prefix>/(lib/<arch>|lib*|share)/<name>*/\n<prefix>/(lib/<arch>|lib*|share)/<name>*/cmake/\n<prefix>/<name>*/(lib/<arch>|lib*|share)/cmake/<name>*/\n<prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/\n<prefix>/<name>*/(lib/<arch>|lib*|share)/<name>*/cmake/\n\n其中 <prefix> 是变量 ${CMAKE_PREFIX_PATH}，Unix 平台默认为 /usr。\n<name> 是你在 find_package(<name> REQUIRED) 命令中指定的包名。\n<arch> 是系统的架构，例如 x86_64-linux-gnu 或 i386-linux-gnu。\n（用于伺候 Ubuntu 喜欢把库文件套娃在 /usr/lib/x86_64-linux-gnu 目录下）\n\n```\n\n### 举例说明 find_package 搜索路径\n\n```c\n// 例如你是 64 位的 Linux 系统，find_package(Qt5 REQUIRED) 会依次搜索：\n/usr/lib/cmake/Qt5/Qt5Config.cmake\n/usr/lib/x86_64-linux-gnu/cmake/Qt5/Qt5Config.cmake\n/usr/share/cmake/Qt5/Qt5Config.cmake\n/usr/lib/Qt5/Qt5Config.cmake\n/usr/lib/x86_64-linux-gnu/Qt5/Qt5Config.cmake\n/usr/share/Qt5/Qt5Config.cmake\n/usr/Qt5/lib/cmake/Qt5/Qt5Config.cmake\n/usr/Qt5/lib/x86_64-linux-gnu/cmake/Qt5/Qt5Config.cmake\n/usr/Qt5/share/cmake/Qt5/Qt5Config.cmake\n/usr/Qt5/lib/Qt5/Qt5Config.cmake\n/usr/Qt5/lib/x86_64-linux-gnu/Qt5/Qt5Config.cmake\n/usr/Qt5/share/Qt5/Qt5Config.cmake\n\n\n```\n\n```c\n// 例如你是 64 位的 Windows 系统，find_package(Qt5 REQUIRED) 会依次搜索：\nC:/Program Files/Qt5Config.cmake\nC:/Program Files/cmake/Qt5Config.cmake\nC:/Program Files/Qt5/Qt5Config.cmake\nC:/Program Files/Qt5/cmake/Qt5Config.cmake\nC:/Program Files/Qt5/lib/cmake/Qt5/Qt5Config.cmake\nC:/Program Files/Qt5/lib/x86_64-windows-gnu/cmake/Qt5/Qt5Config.cmake\nC:/Program Files/Qt5/share/cmake/Qt5/Qt5Config.cmake\nC:/Program Files/Qt5/lib/Qt5/Qt5Config.cmake\nC:/Program Files/Qt5/lib/x86_64-windows-gnu/Qt5/Qt5Config.cmake\nC:/Program Files/Qt5/share/Qt5/Qt5Config.cmake\n\n\n```\n\n```c\n//还有一点，<name> 可以有额外后缀，且不分大小写（无论 Linux 还是 Windows），例如：\nC:/Program Files/Qt5/cmake/Qt5Config.cmake\nC:/Program Files/Qt5.12.1/cmake/Qt5Config.cmake\nC:/Program Files/qt5dnmd/cmake/Qt5Config.cmake\n同样都是可以被 find_package(Qt5 REQUIRED) 搜索到的。\n/usr/lib/cmake/OpenCV/OpenCVConfig.cmake\n/usr/lib/cmake/opencv4/OpenCVConfig.cmake\n同样都是可以被 find_package(OpenCV REQUIRED) 搜索到的。\n\n```\n\n### 安装在非标准路径的库\n\n以 Qt5 为例，如果你安装在下列标准路径，`find_package` 能够自动找到\n\nWindows：C:/Program Files/Qt5.12.1/lib/cmake/Qt5/Qt5Config.cmake。\nLinux：/usr/lib/cmake/Qt5/Qt5Config.cmake。\n\n但是假如我的库不是装在这些标准路径，而是我**自定义的路径，怎么办？**\n\n而且即使你不自定义安装路径，Windows 版的 Qt 默认安装就会安装到：\nC:/Qt5.12.1/msvc2017_64/lib/cmake/Qt5/Qt5Config.cmake。\n\n何况我们同学有的还喜欢装到 D 盘去，Windows 是非标准路径的重灾区，他就没有一个统一的 /usr/lib 目录。然而你一旦把库安装到非标准路径，find_package 是找不到的。\n\n这时你需要手动指定一个变量告诉他在哪儿，可以是普通变量 ${Qt5_DIR}，也可以是环境变量 $ENV{Qt5_DIR}，两个中只要设置了任何一个 find_package 都可以识别到。\n\n变量一般通过命令行 -DQt5_DIR=”C:/Program Files/Qt5.12.1/lib/cmake/Qt5” 设置。\n\n### 举例，Windows 系统，Qt5\n\n例如我把 Qt5 安装到了 D:/Qt5.12.1。\n首先找到他里面的 Qt5Config.cmake 文件所在位置（可以用文件管理器的“搜索”功能）。\n假如你找到该文件的位置是 D:/Qt5.12.1/msvc2017/lib/cmake/Qt5/Qt5Config.cmake，那么请你设置变量 Qt5_DIR 为 D:/Qt5.12.1/msvc2017/lib/cmake/Qt5。有三种设置方法：\n\n(1) 单次有效。在 configure 阶段，可以从命令行设置（注意要加引号）：\ncmake -B build -DQt5_DIR=”D:/Qt5.12.1/msvc2017/lib/cmake/Qt5”\n(2) 全局启用。右键“我的电脑”->“管理”->“高级”添加一个环境变量 Qt5_DIR 值为 D:/Qt5.12.1/msvc2017/lib/cmake/Qt5，然后重启 Visual Studio。这样以后你每次构建任何项目，find_package 都能自动找到这个路径的 Qt5 包了。\n(3) 单项目有效。直接在你自己项目的 CMakeLists.txt 最开头写一行（注意要加引号）：\nset(Qt5_DIR ”D:/Qt5.12.1/msvc2017/lib/cmake/Qt5”)    # 一定要加在最前面！\n\n### 举例，Linux 系统，Qt5\n\n```cmake\n例如我把 Qt5 安装到了 /opt/Qt5.12.1。\n首先找到他里面的 Qt5Config.cmake 文件所在位置（可以用文件管理器的“搜索”功能）。\n假如你找到该文件的位置是 /opt/Qt5.12.1/lib/cmake/Qt5/Qt5Config.cmake，那么请你设置变量 Qt5_DIR 为 /opt/Qt5.12.1/lib/cmake/Qt5。有三种设置方法：\n(1) 单次有效。在 configure 阶段，可以从命令行设置：\ncmake -B build -DQt5_DIR=”/opt/Qt5.12.1/lib/cmake/Qt5”\n(2) 全局启用。修改你的 ~/.bashrc 文件添加环境变量：\nexport Qt5_DIR=”/opt/Qt5.12.1/lib/cmake/Qt5”，然后重启终端。这样以后你每次构建任何项目，find_package 都能自动找到这个路径的 Qt5 包了。\n(3) 单项目有效。直接在你自己项目的 CMakeLists.txt 最开头写一行：\nset(Qt5_DIR ”/opt/Qt5.12.1/lib/cmake/Qt5”)    # 一定要加在最前面！\n\n\n```\n\n### 三种方案利弊分析\n\n```cmake\n单次有效（通过命令行）最安全，小彭老师高度推荐。\n\n全局有效（添加环境变量）可能影响以后其他项目。比如你 A 项目依赖 Qt5.12.1，你设置了环境变量 Qt5_DIR=/opt/Qt5.12.1，后来又搞了个 B 项目依赖 Qt5.10.3，但是你忘了你设置过全局的环境变量指向 5.12.1 了，导致版本冲突。\n\n单项目有效（写死在 CMakeLists.txt）虽然方便了你，但是你的 CMakeLists.txt 拿到别人电脑上（例如你通过 GitHub 开源的），可能你 set(Qt5_DIR D:/Qt5)，而人家却需要 set(Qt5_DIR E:/Qt5) 呢？就冲突了。\n\n所以“单次有效”虽然劳驾您的高抬贵手每次命令行打一下 -DQt5_DIR=”D:/Qt5”，但人家也打一下 -DQt5_DIR=”E:/Qt5”，就没有冲突，各美其美，美美与共，赋能多元化社会，下沉团队合作发力面。\n\n实际上只要你不删 build，不需要每次都 -DQt5_DIR 一下，CMake 具有“记忆”功能。\ncmake -B build -DQt5_DIR=D:/Qt5   # 只需要第一次指定好，\ncmake -B build                                  # 以后第二次运行可以省略！\nrm -rf build                                         # 只有清理了 build 以后，\ncmake -B build -DQt5_DIR=D:/Qt5   # 才需要重新指定。\n\n```\n\n### find_package 的两种模式 ---指定使用哪种模式\n\n```cmake\nfind_package(TBB MODULE REQUIRED)\n# 只会寻找 FindTBB.cmake，搜索路径：\n${CMAKE_MODULE_PATH}（默认为 /usr/share/cmake/Modules）\n\nfind_package(TBB CONFIG REQUIRED)\n# 只会寻找 TBBConfig.cmake，搜索路径：\n${CMAKE_PREFIX_PATH}/lib/cmake/TBB（默认为 /usr/lib/cmake/TBB）\n${TBB_DIR} 或 $ENV{TBB_DIR}\n\nfind_package(TBB REQUIRED)\n# 不指定则两者都会尝试，先尝试 FindTBB.cmake，再尝试 TBBConfig.cmake。\n\n```\n\n### find_package 命令指定版本\n\n```cmake\nfind_package(OpenCV REQUIRED)\n# 查找名为 OpenCV 的包，不限版本，事后可以通过 ${OpenCV_VERSION} 查询找到的版本。\nfind_package(OpenCV 2.0.1 REQUIRED)\n# 查找版本在 2.0.1 以上的 OpenCV 包（version >= 2.0.1）。\nfind_package(OpenCV 2.0.1 EXACT REQUIRED)\n# 查找版本刚好为 2.0.1 的 OpenCV 包（version == 2.0.1）。\n\n# 如果没写全，则没写的部分默认为 0。例如下列三者等价：\nfind_package(OpenCV 2 REQUIRED)\nfind_package(OpenCV 2.0 REQUIRED)\nfind_package(OpenCV 2.0.0 REQUIRED)\n```\n\n### 总结\n\n```bash\n# 安装 TBB：\ncd tbb\n./configure --prefix=/opt/tbbinstalldir\nmake -j 8\nsudo make install\n\n# 在你的项目里使用 TBB：\ncd yourapp\ncmake -B build -DTBB_DIR=/opt/tbbinstalldir/lib/cmake/TBB\ncmake --build build --parallel 8\n\n```\n\n```cmake\n# CMakeLists.txt 这样写：\n\nproject(yourapp)\nadd_executable(yourapp yourmain.cpp)\nfind_package(TBB CONFIG REQUIRED COMPONENTS tbb)\ntarget_link_libraries(yourapp PUBLIC TBB::tbb)\n```\n\n## include_directories\n\n- **target_include_directories  和 include_directories 区别**\n- `target_include_directories` 命令：\n  - `target_include_directories` 命令是为指定的目标（target）添加包含目录。\n  - 通过 `target_include_directories` 命令，可以为特定目标（如可执行文件、库或自定义目标）指定包含目录，以便在构建目标时能够找到所需的头文件。\n  - 该命令允许为不同的目标设置不同的包含目录，并且可以针对不同的可见性级别（INTERFACE、PUBLIC、PRIVATE）指定包含目录。\n  - `target_include_directories` 命令通常与target_link_libraries一起使用，以确保链接的库能够找到其所需的头文件。\n- `include_directories`命令：\n  - `include_directories`命令用于向整个CMake项目添加全局的包含目录。\n  - 通过`include_directories`命令，可以为整个项目指定公共的包含目录，以便在构建过程中所有目标都能够找到所需的头文件。\n  - 该命令将包含目录应用于整个项目，对所有目标都具有相同的影响。\n  - `include_directories`命令通常位于CMakeLists.txt文件的顶层，并在添加目标之前调用。\n- 总结\n  - `target_include_directories` 命令用于为特定目标添加包含目录，允许为不同目标设置不同的包含目录，并支持可见性级别。\n  - `include_directories` 命令用于为整个项目添加全局的包含目录，将包含目录应用于整个项目的所有目标。\n\n## target_include_directories\n\n为指定的目标（target）添加包含目录。\n\n```cmake\ntarget_include_directories(target_name [SYSTEM] [BEFORE]\n    <INTERFACE|PUBLIC|PRIVATE> [items1...]\n    [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])\n    \n\nSET (EXEC_PREFIX \"szy.\")\ntarget_include_directories(${EXEC_PREFIX}log_service PRIVATE ${Protobuf_INCLUDE_DIR} ${Qt5Core_INCLUDE_DIRS} ${Qt5Sql_INCLUDE_DIRS})\n\n#${EXEC_PREFIX} -- 作用就是字符拼接\n```\n\n- target_name是目标的名称，可以是可执行文件、库或自定义目标。\n- [SYSTEM]是可选参数，用于指定包含目录是否为系统目录。\n- [BEFORE]也是可选参数，用于指定是否将新的包含目录添加到已有的目录之前。\n\n例：\n\n```cmake\nadd_executable(my_executable main.cpp)\ntarget_include_directories(my_executable\n    PRIVATE include/\n    PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/common/\n    INTERFACE ${Boost_INCLUDE_DIRS})\n# target_include_directories命令将include/目录添加为my_executable目标的私有包含目录，\n# ${CMAKE_CURRENT_SOURCE_DIR}/common/添加为公共包含目录，\n# 以及${Boost_INCLUDE_DIRS}（Boost库的包含目录）添加为接口包含目录。这样，在构建my_executable时，它将能够访问这些包含目录中的头文件。\n```\n\n## link_libraries\n\n用于指定目标（target）链接的库。\n\n```cmake\nlink_libraries(library1 library2 ...)\n# 其中，library1、library2等是要链接的库的名称或路径。\n```\n\n**link_libraries命令会将指定的库链接到所有后续的目标中，包括在该命令之后创建的目标。**\n\n**这意味着，在调用link_libraries命令后，所有接下来的add_executable、add_library或自定义目标命令都会自动链接指定的库。**\n\n例：\n\n```cmake\nlink_libraries(my_library)\nadd_executable(my_executable main.cpp)\n# link_libraries命令将名为my_library的库链接到所有后续的目标中。然后，\n# add_executable命令创建了一个名为my_executable的可执行文件，并自动链接了my_library库。\n```\n\n**请注意，`link_libraries`命令对于多目标项目可能不够灵活，因为它将指定的库链接到所有目标中，而您可能希望只将特定的库链接到特定的目标。**\n\n**在这种情况下，建议使用`target_link_libraries`命令，它允许更精确地指定要链接的库和目标。**\n\n## target_link_libraries\n\n为指定的目标（target）添加链接的库。\n\n```cmake\ntarget_link_libraries(target_name\n    <PRIVATE|PUBLIC|INTERFACE> item1 item2 ...\n)\n# target_name是目标的名称，可以是可执行文件、库或自定义目标。\n# PRIVATE、PUBLIC、INTERFACE关键字用于指定后续要链接的库的可见性和属性。\n\n# PRIVATE：链接的库只对目标本身可见。\n# PUBLIC：链接的库对目标本身和依赖于该目标的其他目标可见。\n# INTERFACE：链接的库不对目标本身可见，但会传递给依赖于该目标的其他目标。\n```\n\n例：\n\n```cmake\nadd_executable(my_executable main.cpp)\ntarget_link_libraries(my_executable\n    PRIVATE library1\n    PUBLIC library2\n    INTERFACE library3\n)\n# target_link_libraries命令将library1库链接为my_executable目标的私有库，\n# 将library2库链接为公共库，\n# 将 library3库链接为接口库。这样，在构建my_executable时，它将链接这些库，并与其他目标共享或传递相应的链接库。\n```\n\n### INTERFACE\n\n假设我们有目标A和目标B。目标A编译成可执行文件，是我们最终要运行的目标。而目标B则编译成目标A的一个依赖，比如说，静态库。\n\nPUBLIC的意思就是 目标B的属性 不仅自己使用，还传递给依赖它的目标A。\n\nPRIVATE的意思就是 目标B的属性 不会传递，只给目标B自己使用。\n\n而INTERFACE则极为特殊：它的属性都 不会自己使用，只传递给目标A。\n\nINTERFACE就是纯粹的利他主义，我自己不用，但我甘于奉献，让别人用。INTERFACE只做个纯粹的“接口”。这类似于电话接线员。接线员不能听到任何信息，他们只是把信息转发给别人。\n\n```cmake\nadd_library(Eigen INTERFACE)\n\ntarget_sources(Eigen INTERFACE\n  FILE_SET HEADERS\n    BASE_DIRS src\n    FILES src/eigen.h src/vector.h src/matrix.h\n)\n\nadd_executable(exe1 exe1.cpp)\ntarget_link_libraries(exe1 Eigen)\n\n```\n\n这里 Eigen库是个header-only的库。\n\n首先我们声明它的可见性为INTERFACE。这表示它自己不会使用自己的任何属性。它只是个接线员。（注意：源文件也可以看做是一种\"属性\"，因此，Eigen这个库的所有源文件和头文件都不会被它自己使用，所以它不会编译出任何东西）\n\n使用target_souces来指定它的源文件。\n\n最后两行，我们编译出exe1这个可执行目标，然后把Eigen链接到exe1上。\n\nexe1由于引用了Eigen，所以Eigen的所有属性都传递到exe1身上。也就是说，Eigen的所有源码都作为了exe1的源码。\n\n## target_sources\n\n将源文件（源代码文件）添加到指定的目标。\n\n```cmake\ntarget_sources(target_name\n    PRIVATE|PUBLIC|INTERFACE\n    [item1 [item2 ...]]\n)\n```\n\n**target_name是目标的名称，可以是可执行文件、库或自定义目标。**PRIVATE、PUBLIC、INTERFACE关键字用于指定后续源文件的可见性和属性。\n\nPRIVATE：源文件只对目标本身可见。\nPUBLIC：源文件对目标本身和依赖于该目标的其他目标可见。\nINTERFACE：源文件不对目标本身可见，但会传递给依赖于该目标的其他目标。\n\n例：\n\n```cmake\nadd_executable(my_executable)\ntarget_sources(my_executable\n    PRIVATE main.cpp\n    PUBLIC utils.cpp\n    INTERFACE common.h\n)\n# target_sources命令将main.cpp源文件添加为my_executable目标的私有源文件，\n# utils.cpp添加为公共源文件，common.h添加为接口源文件。这样，在构建my_executable时，它将包含这些源文件，并与其他目标共享或传递相应的源文件。\n```\n\n## aux_source_directory\n\n**自动搜集需要的文件后缀名**\n\n```cmake\naux_source_directory(./source DIR_SOURCE_ARMA)\n# 表示将./source目录中的所有源文件（.cpp、.c、.cxx等）的列表存储在名为DIR_SOURCE_ARMA的变量中。\n\n```\n\n```cmake\nfile(GLOB_RECURSE sources CONFIGURE_DEPENDS *.cpp *.h)\n# GLOB_RECURSE -- 能自动包含所有子文件夹下的文件\n\n\n# GLOB_RECURSE 的问题：会把 build 目录里生成的临时 .cpp 文件也加进来\n解决方案：要么把源码统一放到 src 目录下，要么要求使用者不要把 build 放到和源码同一个目录里，我个人的建议是把源码放到 src 目录下。\n\n```\n\n## set_target_properties\n\n设置目标属性\n\n该命令的语法是列出想要更改的所有目标，然后提供接下来想要设置的值。您可以使用该命令任何所需的键值对，然后使用`get_property()`或`get_target_property()`命令提取它。\n\n- ```cmake\n  # 生成disproto时，输出到指定路径 --  LIBRARY_OUTPUT_DIRECTORY\n  set_target_properties(disproto PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n  \n  # 希望 \"hello_static\" 在输出时，不是\"hello_static\"，而是以\"hello\"的名字显示，故设置如下：\n  SET_TARGET_PROPERTIES (hello_static PROPERTIES OUTPUT_NAME \"hello\")\n  \n  #动态库是应该包含一个版本号的， VERSION指代动态库版本，SOVERSION指代API版本。\n   \n  SET_TARGET_PROPERTIES (hello PROPERTIES VERSION 1.2 SOVERSION 1)\n  ```\n\n- 同样是指定输出目录，但是不同的动态库文件指定不同的输出目录。（静态库和二进制执行文件也是同理）。目标文件可以大致分为三种类型：二进制执行文件、动态库、静态库。保存不同目标文件所用到的属性不一样。具体分类如下。\n\n  RUNTIME_OUTPUT_DIRECTORY：二进制执行文件\n  LIBRARY_OUTPUT_DIRECTORY：动态库\n  ARCHIVE_OUTPUT_DIRECTORY：静态库\n\n  以保存动态库为例：\n\n  ```cmake\n  # 将动态库 libhello.so 保存到 lib 目录下\n  # set_target_properties(hello PROPERTIES LIBRARY_OUTPUT_DIRECTORY \"lib\")\n   \n  # 将目标文件保存到顶层CMakeLists.txt所处目录下的build/lib \n  set_target_properties(mul \n      PROPERTIES LIBRARY_OUTPUT_DIRECTORY \n      ${PROJECT_SOURCE_DIR}/build/lib\n  )\n  ```\n\n- 指定Debug模式下目标文件名的后缀（DEBUG_POSTFIX）\n\n  为了区别不同模式下的不同文件，我们可以指定Debug模式下的目标文件名后缀为 _d，以用于区分 release 模式下生成的目标文件。\n\n  命令格式：\n\n  ```cmake\n  SET_TARGET_PROPERTIES (<target> PROPERTIES DEBUG_POSTFIX <suffix_name>)\n  \n  # 指定debug模式下的目标文件名后缀为 _d，即如果是动态库文件，那就是 libhello_d.so\n  SET_TARGET_PROPERTIES (hello PROPERTIES DEBUG_POSTFIX _d)\n  ```\n\n- 获取属性\n  `get_target_properties` 可以获取到某个目标已有的属性对应的值，并保存到指定变量中。这个属性可以是内置的，也可以是自己创建的。\n\n  命令格式：\n\n  `get_target_property(<variable> <target> <target_property>)`\n\n## 变量的传播规则：父会传给子\n\n- 父模块里定义的变量，会传递给子模块。\n- 但是子模块里定义的变量，不会传递给父模块。\n- 如果父模块里本来就定义了同名变量，则离开子模块后仍保持父模块原来设置的值。\n- 可以用 set 的 PARENT_SCOPE 选项，把一个变量传递到上一层作用域（也就是父模块）。\n\n## 静态库循环依赖问题\n\n- `\"$<LINK_GROUP:RESCAN,${MODUO_LIBS}>\"`\n\n``` cmake\n  target_link_libraries(\n  dlogdb\n  PRIVATE scdb\n          \"$<LINK_GROUP:RESCAN,${MODUO_LIBS}>\"\n          Boost::system\n          Boost::filesystem\n          glog\n          Qt5Core\n          Qt5Sql\n          pthread\n          proto\n          faiss\n          CUDA::cuda_driver\n          CUDA::cudart\n          ${cityhash_LIRARIES}\n          ${facerec_LIBRARIES}\n          ${Protobuf_LIBRARIES}\n          ${OpenCV_LIBRARIES}\n         )\n```\n\n- 这里muduo_lib有循环依赖的问题[cmake]<https://cmake.org/cmake/help/latest/variable/CMAKE_LINK_GROUP_USING_FEATURE.html>\n\n- `set_property(TARGET ${COMPONENT_LIB} APPEND PROPERTY LINK_INTERFACE_MULTIPLICITY 3)`\n","tags":["cmake"],"categories":["cmake"]},{"title":"对象生命周期","url":"/2024/01/02/cpp/practice/对象生命周期/","content":"\n# 对象生命周期\n\n总结:\n\n1. 函数对象会在其作用域的**右括号**处进行析构。\n2. `func2(Test(\"t\")),puts(\"---\");`函数会在其 **;** 处进行析构，此时Test的作用域已结束。\n\n## 第一种情况\n\n对象会在其作用域 \"}\" 释放\n\n``` cpp\nvoid func() {\n  {\n    puts(\"===\");\n    Test t(\"t\");\n    { Test t2(\"t2\"); }\n    puts(\"===\");\n  }  // t.~Test() 自动调用析构函数 , 加括号后析构提前,作用域\n  puts(\"---\");\n}  // t.~Test() 自动调用析构函数\n```\n\n## 第二种情况\n\n一行语句结束，是以 **\" ; \"** 结尾。\n\n``` cpp\nint main() {\n//   Test t(\"t\");  // 这个传入下面的函数时，才会在main结束后析构。\n\n  func2(Test(\"t\")),\n      puts(\"---\");  \n      // t 在此进行析构\n      // 此语句和下面括号内的内容等价\n  puts(\"{-----------}\");\n  {\n    Test t1(\"t1\");\n    func2(t1); \n    puts(\"---\");\n  }  \n  // 出 } 后，t1 会在此进行析构\n  puts(\"===\");\n  // 当在main 定义  Test t(\"t\");  会在语句结束后，将Test t 析构掉\n}\n```\n\n## 第三种情况\n\n``` cpp\nvoid func3(Test t) {\n  //\n  puts(\"func(Test t)\");\n}\n\nint main() {\n  // 测试 3\n  Test t(\"t\");\n  func3(t), puts(\"===\"); \n  // func(test t) 时，会多一次拷贝和析构,\n  // 上面的和括号中的语句等价， t 会在main 结束 时 析构。\n  {\n    Test t_copy(t);\n    func(t_copy), puts(\"===\");\n  }\n  puts(\"===\");\n  // t_copy 在 } 时， 析构。\n}\n```\n\n结果\n\n``` cpp\nTest() t\nTest(Test const &) t_copy\nfunc(Test t)\n===\n~Test() t_copy\nTest(Test const &) t_copy\nfunc(Test const &t)\n===\n~Test() t_copy\n===\n~Test() t\n```\n\n## 第四种情况 --move\n\n```cpp\n  Test t(\"t\");  // 调用Test的构造函数 ，会在main } 处析构，delete 空指针\n  func(std::move(t)), puts(\"===\");  // 调用 func(Test &&t)\n  {\n    Test t_move(std::move(t));  // 调用Test的移动构造函数\n    // 移动就是创建了一个一模一样的对象，仅此而已，还是会再次析构t\n    //  此时 t 已经没了\n    func(t_move), puts(\"===\");\n  }\n```\n\n测试结果\n\n``` cpp\nTest() t\nfunc(Test &&t)\n===\nTest(Test &&) t_move\nfunc(Test const &t)\n===\n~Test() t_move\n~Test() null\n```\n\n## unique_ptr 和 std::move\n\n``` cpp\n  // 这里移动的是智能指针本身，不是指针指向的内容\n  // 默认unique_ptr不会调用调用test的拷贝和移动构造函数\n  std::unique_ptr<Test> t(new Test(\"t\"));\n  /*所以move 时，不会调用移动构造函数，这里移动的是，指针\n  移动的只是房产证，不是房子\n  不能拷贝\n  */\n  func(std::move(t));\n```\n\n测试结果\n\n``` cpp\nTest() t\nfunc\n~Test() t\n```\n\n## 生命周期分析练习\n\n1.\n\n```cpp\n        std::string const &func_test(std::string s) {\n          // 会将 hello 拷贝一份 --s\n          return s;  // s 出作用域时自动析构,\n        }\n\n        int main() {\n          auto ret = func_test(std::string(\"hello\"));\n          // segmentation fault 这里 std::string(\"hello\"), 出作用域 时， 会自动析构\n          std::cout << ret << std::endl;\n        }\n```\n\n2.\n\n```cpp\n        std::string const &func_test(std::string const &s) {\n          // 会将 hello 拷贝一份 --s\n          return s;  // s 出作用域时自动析构,\n        }\n        int main() {\n          auto ret = func_test(std::string(\"hello\"));\n          // release 和 debug\n          // 模式下都显示正常，但是存在泄露，但是却显示正常\n          // 在返回时，它被以引用的形式返回。这意味着在main函数中，ret变量实际上引用了一个临时std::string对象，该对象是由std::string(\"hello\")复制构造而来。\n          std::cout << ret << std::endl;\n        }\n\n        // 这种情况下Debug显示正常，Release出现问题，和下面的情况类似。\n        auto ret = &func_test(std::string(\"hello\"));\n        std::cout << *ret << std::endl;\n```\n\n3.\n\n``` cpp\n\n    std::string const &func_test(std::string const &s) {\n      // 会将 hello 拷贝一份 --s\n      return s;  // s 出作用域时自动析构,\n    }\n\n    int main() {\n      auto s = std::string(\"test\");\n      auto ret = &func_test(s);  // 正常的 ret 和 s 是同一个对象\n      printf(\"%s\\n\", ret->c_str());\n    }\n\n```\n\n4. 这里 `cout` 时，会出现 `166120 segmentation fault (core dumped)`，\n`printf` 时 会出现乱码 `�3�]�`。并且 **Release 出现异常 Debug模式正常**\n\n ``` cpp\n   std::string const *ret;\n   {\n     auto s = std::string(\"test\");\n     ret = &func_test(s);  // s 出了作用域，析构。但是 ret 持有 s的指针\n     //  未定义行为 内存泄漏\n     // ，变量未初始化，调试模式未初始化变量为0\n     // ，但是发布模式未初始化变量则有可能不是0. msvc\n   }\n   std::cout << *ret << std::endl;\n   printf(\"%s\\n\", ret->c_str());  // Release 出现异常 Debug模式正常\n ```\n\n## lambda 何时使用 & =\n\n``` cpp\nstd::vector<std::function<void()>> g_funcs;\n\nvoid fun(auto f) { g_funcs.emplace_back(std::move(f)); }\n\nvoid bao() {\nfor (auto &f : g_funcs) {\n   f();\n}\n}\n\nvoid foo() {\n// int i = 1;\nstd::shared_ptr<int> i(new int);\n\nfun([i]() { printf(\"1_i = %d\\n\", (*i)++); });\nfun([i]() { printf(\"2_i = %d\\n\", (*i)++); });\n}\n\nint main() {\n// lambda 函数合适传& =\n// 这里会出错， 将 i  推到了全局， 其实已经析构\n// i 来计数，lambda 和shared_ptr 结合使用\nfoo();\n// [&]这里会乱打印i, = 会正常打印,\n// 但是计数时，需要引用--》这里采用 lambda 和shared_ptr 结合使用\nbao();\n}\n\n```\n\n> 代码地址 <https://github.com/lyt-s/my_stl/tree/master/cpplifetimetest>\n","tags":["c++11"],"categories":["c++"]},{"title":"小小的operator=竟有这么多细节","url":"/2023/12/22/cpp/c++11/小小的operator-竟有这么多细节/","content":"\n## operator=\n\n```cpp\nclass MyString{\npublic:\n    MyString(char * pData = nullptr);\n    MyString(const MyString& str);\nprivate:\n        char * m_pData;\n};\n```\n\nTODO:\n**添加赋值运算符**\n\n* 是否把返回值类型声明为该类型的引用，并在函数返回时，返回实例自己的引用(*this)。 **只有返回一个引用，才允许连续赋值。**  否则，如果函数自身返回值是void，则应用该赋值运算符将不能进行连续赋值。假设有3个MyString的对象，`str1`,`str2`,`str3`,在程序中语句`str1 = str2 = str3`将不能通过编译。\n* 是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数，把参数设为引用可以避免无谓的消耗，能提高代码的效率。同时我们在赋值运算符函数内不会改变传入的实例的状态，因此应该为传入的引用参数上加入const关键字。\n* 是否释放自己的内存。如果我们忘记在分配新内存之前释放自身已有的空间，则会造成内存泄漏。\n* 判断传入的参数和当前的实例(*this)是不是指向同一个实例。如果是同一个，则不进行操作，直接返回。如果事先不判断就进行赋值，那么在释放实际内存的时候就会导致严重的问题：当`*this`和传入的参数是同一个实例时，一旦释放了自身的内存，传入的参数的内存同时被释放了，因此就再也找不到需要赋值的内容了。\n\n## 经典做法\n\n``` cpp\nMyString& MyString::operator=(const MyString& other){\n    if(this == &other) return *this;\n\n    delete []m_pData;\n    m_pData = nullptr;\n\n    m_pData = new char[strlen(other.m_pData) + 1];\n    strcpy(m_pData, other.m_pData);\n\n    return *this;\n}\n```\n\n## 考虑异常安全性\n\n``` cpp\nMyString& MyString::operator=(const MyString& other){\n    if(this ！= &other) {\n       MyString strTemp(other);\n\n       char *pTemp = strTemp.m_pData;\n       strTemp.m_pData = m_pData;\n       m_pData = pTemp;\n    }\n    return *this;\n}\n```\n\n在之前的函数，我们再分配之前，先用`delete`释放了实例`m_pData`的内存。如果此时内存不足导致`new char` 抛出异常，则`m_pData`将是一个空指针，这样非常容易导致程序崩溃。违背了异常安全性原则。\n\n这里改进，先创建一个临时实例，在交换临时实例和原来的实例。\n\n在这个函数中，我们先创建，一个临时实例strTemp, 接着把`strTemp.m_pData`和实例自身的`m_pData`进行交换。由于`strTemp`是一个局部变量，但程序运行到if外面时，也就处理该变量的作用域，就会自动调用`strTemp`的析构函数，把`strTemp.m_pData`所指向的内存释放掉。由于`strTemp.m_pData`指向的内存就是实例之前m_pData的内存，这就相当于自动调用析构函数释放实例的内存。\n","tags":["c++11"],"categories":["c++"]},{"title":"自己实现STL之vector","url":"/2023/12/19/my_stl/vector/","content":"\n这里的 `m_size` 是实际数据占用的大小。`m_capacity`是目前所能够容纳数据的大小，`m_size <= m_capacity`。\n\n`clear()` 清空的是 `m_data`和`m_size`,`reverse()`改变的是 `m_capacity`\n\n``` cpp\ntemplate <class T, class Alloc = std::allocator<T>>\nstruct Vector {\n  using value_type = T;\n  using allocator_type = Alloc;\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using pointer = T*;\n  using const_pointer = T const*;\n  using reference = T&;\n  using const_reference = T const&;\n  using iterator = T*;\n  using const_iterator = T const*;\n  using reverse_iterator = std::reverse_iterator<T*>;\n  using const_reverse_iterator = std::reverse_iterator<T const*>;\n\n  int* m_data;\n  size_t m_size; // 实际数据大小\n  size_t m_capacity; // 所能容纳的大小\n  ...\n}\n```\n\n## 重载[]\n\n这里重载[]，是为了实现 `arr[i] = i;`\n\n```cpp\n  //   // 这里返回纯右值\n  //   int operator[](size_t i) const {\n  //     return m_data[i];\n  //   }  // 这里添加const ， 否则 const Vector &v = v; 无法赋值\n\n  // 这里返回纯右值 , 防止多余拷贝 ，和上面功能是一样的\n  int const& operator[](size_t i) const noexcept {\n    return m_data[i];\n  }  // 这里添加const ， 否则  Vector &v = v; 无法赋值\n\n  // 这里返回左值引用\n  int& operator[](size_t i) noexcept {\n    return m_data[i];\n    //\n  }\n\n```\n\n## std::destroy_at()\n\n``` cpp\n定义于头文件 <memory>\ntemplate< class T >\nvoid destroy_at( T* p );(C++17 起) (C++20 前)\ntemplate< class T >\nconstexpr void destroy_at( T* p ); (C++20 起)\n\n参数：\n\np - 指向要被销毁的对象的指针\n```\n\n`destroy_at` 函数模板通过调用对象的析构函数来执行销毁操作。\n\n``` cpp\n#include <memory>\n#include <new>\n#include <iostream>\n \nstruct Tracer {\n    int value;\n    ~Tracer() { std::cout << value << \" destructed\\n\"; }\n};\n \nint main()\n{\n    alignas(Tracer) unsigned char buffer[sizeof(Tracer) * 8];\n \n    for (int i = 0; i < 8; ++i)\n        new(buffer + sizeof(Tracer) * i) Tracer{i}; // 手工构造对象\n \n    auto ptr = std::launder(reinterpret_cast<Tracer*>(buffer));\n \n    for (int i = 0; i < 8; ++i)\n        std::destroy_at(ptr + i);\n}\n```\n\n## std::construct_at()\n\n`std::construct_at` 是 C++ 中的一个函数模板，用于在指定位置构造对象。\n函数模板的声明如下：\n\n``` cpp\n它位于 <memory> 头文件中，并定义在命名空间 std 中。\ntemplate<class T, class... Args>\nT* construct_at(T* location, Args&&... args);\n```\n\n参数 `location` 是指向要构造对象的位置的指针。参数 `args` 是传递给对象构造函数的参数列表。\n\n`construct_at` 函数模板将在指定位置调用对象的构造函数来构造对象。它返回指向构造的对象的指针。\n在给定地址 `p` 创建一个使用参数`args...` 初始化的`T` 对象。\n\n示例:\n\n``` cpp\n#include <iostream>\n#include <memory>\n \nstruct S\n{\n    int x;\n    float y;\n    double z;\n \n    S(int x, float y, double z) : x{x}, y{y}, z{z} { std::cout << \"S::S();\\n\"; }\n \n    ~S() { std::cout << \"S::~S();\\n\"; }\n \n    void print() const\n    {\n        std::cout << \"S { x=\" << x << \"; y=\" << y << \"; z=\" << z << \"; };\\n\";\n    }\n};\n \nint main()\n{\n    alignas(S) unsigned char storage[sizeof(S)];\n \n    S* ptr = std::construct_at(reinterpret_cast<S*>(storage), 42, 2.71828f, 3.1415);\n    ptr->print();\n \n    std::destroy_at(ptr);\n}\n```\n\n## clear()\n\n清空全部内容\n\n```cpp\n  void clear() noexcept {\n    for (size_t i = 0; i != m_size; i++) {\n      std::destroy_at(&m_data[i]);\n    }\n    m_size = 0;\n  }\n```\n\n## resize()\n\n这里`resize()`两种情况。这里改变的只是m_size大小\n\n1. `arr.resize(6)`之后，`arr.resize(3)`。容量比之前小了，这里会销毁掉3后面的数据。\n2. 第二种就是容量比之前变大了，那么我们会对后面增加的容量进行初始化，默认初始化为0。\n3. `resize()`,有两种resize方式，一种是不指定初始化的value，一种是指定初始化的value。\n\n``` cpp\n  void resize(size_t n) {\n    if (n < m_size) {\n      for (size_t i = n; i != m_size; ++i) {\n        std::destroy_at(&m_data[i]);\n      }\n    } else if (n > m_size) {\n      reserve(n);\n      for (size_t i = m_size; i < n; ++i) {\n        std::construct_at(&m_data[i]);  // m_data[i] = 0\n      }\n    }\n    m_size = n;\n  }\n\n  void resize(size_t n, T const& value) {\n    if (n < m_size) {\n      // resize 变小了，需要删除\n      for (size_t i = n; i != m_size; ++i) {\n        std::destroy_at(&m_data[i]);\n      }\n    } else if (n > m_size) {\n      reserve(n);\n      // 扩大部分置为value\n      for (size_t i = m_size; i < n; ++i) {\n        std::construct_at(&m_data[i], value);  // m_data[i] = value;\n      }\n    }\n    m_size = n;\n  }\n```\n\n## std::move_if_noexcept()\n\n**对于移动构造函数来说，抛出异常是很危险的。**\n因为移动语义还没完成，一个异常就抛出来，可能会造成悬挂指针。因此，应尽量通过noexcept声明不抛出异常，而一旦出现异常就可以直接调用std::terminate终止程序。\n\n`std::move_if_noexcept`模板来替代`move`函数。\n该函数在类的**移动构造函数没有声明`noxcept`关键字时返回一个左值引用**从而使变量通过拷贝语义，\n在**移动构造函数有noexcept时返回一个右值引用**，从而使变量可以使用移动语义。移动操作未加noexcept时，编译器仍会强制调用一个复制操作。\n\n``` cpp\nDefined in header <utility>\ntemplate< class T >\nconstexpr typename std::conditional<  \n    !std::is_nothrow_move_constructible<T>::value && std::is_copy_constructible<T>::value,\n    const T&,\n    T&&\n>::type move_if_noexcept( T& x ) noexcept;\n(since C++14)\n```\n\n如果`T` 类型的对象 `x`**满足以下条件**：\n\n* T 类型具有移动构造函数（`is_move_constructible_v<T>` 为 `true`）。\n* T 类型的移动构造函数不会抛出异常（`is_nothrow_move_constructible_v<T>` 为 `true`）。\n\n那么 std::move_if_noexcept(x) 将返回 T&& 类型的右值引用，表示可以安全地执行移动操作。\n\n**不满足上面的条件时,返回 const T &**\n如果`T` 类型的对象`x` 不满足上述条件，但具有拷贝构造函数（`is_copy_constructible_v<T>` 为 `true`）。\n\n那么 `std::move_if_noexcept(x)` 将返回` const T& `类型的左值引用，表示无法安全地执行移动操作，但可以使用拷贝操作。\n\n**这样，`std::move_if_noexcept` 可以根据类型的移动构造函数是否抛出异常来选择性地将对象转移为右值引用，以提高性能。**\n\n示例:\n\n``` cpp\n\n#include <iostream>\n#include <utility>\n \nstruct Bad\n{\n    Bad() {}\n    Bad(Bad&&) // may throw\n    {\n        std::cout << \"Throwing move constructor called\\n\";\n    }\n    Bad(const Bad&) // may throw as well\n    {\n        std::cout << \"Throwing copy constructor called\\n\";\n    }\n};\n \nstruct Good\n{\n    Good() {}\n    Good(Good&&) noexcept // will NOT throw\n    {\n        std::cout << \"Non-throwing move constructor called\\n\";\n    }\n    Good(const Good&) noexcept // will NOT throw\n    {\n        std::cout << \"Non-throwing copy constructor called\\n\";\n    }\n};\n \nint main()\n{\n    Good g;\n    Bad b;\n    [[maybe_unused]] Good g2 = std::move_if_noexcept(g);\n    [[maybe_unused]] Bad b2 = std::move_if_noexcept(b);\n}\n```\n\n结果:\nNon-throwing move constructor called\nThrowing copy constructor called\n\n## reserve()\n\n`reverse`这里实现的方式为，超过原来的`m_capacity`时，进行`m_capacity*2`的扩容，实现push_back的复杂度为O(N)。\n\n**实现**\n\n``` cpp\n  //   // size =0 cap =0\n  //   // size =1 cap =1 *\n  //   // size = 2 cap = 2 *\n  //   // size = 3 cap = 4\n  //   // size = 4 cap = 4\n  //   // size = 5 cap = 8 *\n  //   // ...\n  //   // size =9 cap = 16 *\n  //   // 平均复杂度，o(n);\n```\n\n``` cpp\n\n  void reserve(size_t n) {\n    if (n <= m_capacity) [[likely]] {\n      return;\n    }\n    n = std::max(n, m_capacity * 2);\n    // printf(\"grow from %zd to %zd\\n\", m_capacity, n);\n    auto old_data = m_data;\n    auto old_capacity = m_capacity;\n    // resize(0)\n    if (n == 0) {\n      m_data = nullptr;\n      m_capacity = 0;\n\n    } else {\n      m_data = new int[n];\n      m_capacity = n;\n    }\n    if (old_capacity != 0) {\n      for (size_t i = 0; i < m_size; ++i) {\n        // memcpy(m_data, old_data, std::min(old_size, m_size) * sizeof(int));\n        std::construct_at(&m_data[i], std::move_if_noexcept(old_data[i]));\n      }\n      for (size_t i = 0; i < m_size; ++i) {\n        std::destroy_at(&m_data[i]);\n      }\n      // delete[] old_data;\n      m_alloc.deallocate(old_data, old_capacity);\n    }\n  }\n```\n\n## shrink_to_fit()\n\n请求移除未使用的容量。\n\n它是减少 capacity() 到 size()非强制性请求。请求是否达成依赖于实现。\n\n如果发生重分配，那么所有迭代器（包括 end() 迭代器）和所有到元素的引用都会失效。如果没有发生重分配，那么没有迭代器或引用会失效。\n示例：\n\n``` cpp\n#include <iostream>\n#include <vector>\n \nint main()\n{\n  Vector<int> bar;    \n  bar.resize(100);\n  std::cout << \"Capacity of a 100-element vector is \" << bar.capacity() << '\\n';\n  bar.resize(50);\n  std::cout << \"Capacity after resize(50) is \" << bar.capacity() << '\\n';\n  bar.shrink_to_fit();\n  std::cout << \"Capacity after shrink_to_fit() is \" << bar.capacity() << '\\n';\n  bar.clear();\n  std::cout << \"Capacity after clear() is \" << bar.capacity() << '\\n';\n  bar.shrink_to_fit();\n  std::cout << \"Capacity after shrink_to_fit() is \" << bar.capacity() << '\\n';\n}\n```\n\n**实现**\n\n``` cpp\n  // 请求移除未使用的容量。\n  // 它是减少 capacity() 到 size() 非强制性请求。请求是否达成依赖于实现。\n  void shrink_to_fit() noexcept {\n    auto old_data = m_data;\n    auto old_capacity = m_capacity;\n    m_capacity = m_size;\n    if (m_size == 0) {\n      m_data = nullptr;\n    } else {\n     m_data = m_alloc.allocate(m_size);\n    }\n    if (old_capacity != 0) {\n      for (size_t i = 0; i != m_size; i++) {\n        // memcpy(m_data, old_data, m_size);\n        std::construct_at(\n            &m_data[i], std::move_if_noexcept(\n                         old_data[i]));  // m_data[i] = std::move(old_data[i]);\n        std::destroy_at(&old_data[i]);\n      }\n      // delete old_data;\n      m_alloc.deallocate(old_data, old_capacity);\n    }\n  }\n```\n\n## at()\n\n``` cpp\n  T const& at(size_t i) const {\n    if (i >= m_size) [[unlikely]] {\n      throw std::out_of_range(\"index out of range(vector::at)\");\n    }\n    return m_data[i];\n  }\n\n  T& at(size_t i) {\n    // 小概率事件，编译器优化\n    if (i >= m_size) [[unlikely]] {\n      throw std::out_of_range(\"index out of range(vector::at)\");\n    }\n    return m_data[i];\n  }\n\n```\n\n## std::as_const()\n\nstd::as_const 是 C++ 中的一个函数模板，用于将对象转换为常量引用。\n\n函数模板的声明如下：\n\n```cpp\nDefined in header <utility>\ntemplate< class T >\nconstexpr std::add_const_t<T>& as_const( T& t ) noexcept;\n(1) (since C++17)\ntemplate< class T >\nvoid as_const( const T&& ) = delete;\n(2) (since C++17)\n\n1) Forms lvalue reference to const type of t.\n2) const rvalue reference overload is deleted to disallow rvalue arguments.\n```\n\n示例:\n\n``` cpp\n#include <cassert>\n#include <string>\n#include <type_traits>\n#include <utility>\n \nint main()\n{\n    std::string mutableString = \"Hello World!\";\n    auto&& constRef = std::as_const(mutableString);\n \n    mutableString.clear(); // OK\n    //  constRef.clear(); // Error: 'constRef' is 'const' qualified,\n                          //        but 'clear' is not marked const\n    //  您正在尝试调用一个非常量成员函数\n    //  clear，但是该函数的调用对象是一个常量对象，因此产生了错误。\n    assert(&constRef == &mutableString);\n    assert(&std::as_const(mutableString) == &mutableString);\n \n    using ExprType = std::remove_reference_t<decltype(std::as_const(mutableString))>;\n \n    static_assert(std::is_same_v<std::remove_const_t<ExprType>, std::string>,\n                  \"ExprType should be some kind of string.\");\n    static_assert(!std::is_same_v<ExprType, std::string>,\n                  \"ExprType shouldn't be a mutable string.\");\n}\n```\n\n## date()\n\n``` cpp\n    T *data() noexcept {\n        return m_data;\n    }\n\n    T const *data() const noexcept {\n        return m_data;\n    }\n\n    T const *cdata() const noexcept {\n        return m_data;\n    }\n```\n\n## is_nothrow_move_assignable_v()\n\n`is_nothrow_move_assignable_v` 是一个 C++ 类型特性(trait)，用于检查类型是否具有不抛出异常的移动赋值操作符`（move assignment operator）`。\n\n## noexcept\n\nnoexcept 关键字用于在函数或操作符后面的括号内声明异常规约。它可以接受一个 `bool` 类型的常量表达式作为参数，用于指定函数或操作符是否可能抛出异常。如果参数表达式为`true`，则表示函数或操作符不会抛出异常；如果参数表达式为 `false`，则表示函数或操作符可能抛出异常。\n\n因此，`noexcept(std::is_nothrow_move_assignable_v<T>)`的作用是在函数或操作符上声明其是否具有不抛出异常的移动赋值操作符。如果 `std::is_nothrow_move_assignable_v<T>` 为 `true`，则整个表达式的结果为 `noexcept(true)`，表示函数或操作符不会抛出异常；如果 `std::is_nothrow_move_assignable_v<T>`为`false`，则整个表达式的结果为`noexcept(false)`，表示函数或操作符可能抛出异常。\n\n## erase()\n\nerase实现有两种情况:\n\n1. 删除单个元素，需要输入对应元素的迭代器\n2. 删除区间内的元素，则需要输入删除元素区间的起始迭代器和最后元素的迭代器。`[first, last)`\n\n``` cpp\n  T* erase(T const* it) noexcept(std::is_nothrow_move_assignable_v<T>) {\n    size_t i = it - m_data;\n\n    for (size_t j = i + 1; j != m_size; j++) {\n      m_data[j - 1] = std::move(m_data[j]);\n    }\n    m_size -= 1;\n    std::destroy_at(&m_data[m_size]);\n    return const_cast<T*>(it);\n  }\n\n  T* erase(T const* first,\n           T const* last) noexcept(std::is_nothrow_move_assignable_v<T>) {\n    size_t i = first - m_data;\n    size_t j = last - m_data;\n    size_t diff = j - i;\n    for (; j != m_size; j++) {\n      m_data[j - diff] = std::move(m_data[j]);\n    }\n    m_size -= diff;\n    for (size_t j = m_size; j != m_size + diff; j++) {\n      std::destroy_at(&m_data[j]);\n    }\n    return const_cast<T*>(first);\n  }\n```\n\n## push_back()\n\n``` cpp\n  void push_back(T const& val) {\n    if (m_size + 1 >= m_capacity) [[unlikely]] {\n      reserve(m_size + 1);\n    }\n    std::construct_at(&m_data[m_size], val);\n    m_size = m_size + 1;\n    // back() = val;\n    // m_data[m_size] = val; // todo 有问题\n  }\n```\n\n## pop_back()\n\n``` cpp\n  void pop_back() noexcept {\n    m_size -= 1;\n    std::destroy_at(&m_data[m_size]);\n  }\n```\n\n## emplace_back()\n\n``` cpp\n  template <class... Args>\n  T& emplace_back(Args&&... args) {\n    if (m_size + 1 >= m_capacity) [[unlikely]] {\n      reserve(m_size + 1);\n    }\n    T* p = &m_data[m_size];\n    std::construct_at(p, std::forward<Args>(args)...);\n    m_size = m_size + 1;\n    return *p;\n  }\n```\n\n## emplace_back 和 push_back() 区别\n\n`emplace_back` 和`push_back`的区别在于：\n\n* `push_back()`向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）\n* `emplace_back()`则直接在容器尾部创建这个元素省去了拷贝或移动元素的过程，所以在效率上更优。\n\n## emplace()\n\n```cpp\nstd::vector<T,Allocator>::emplace\n\ntemplate< class... Args >\niterator emplace( const_iterator pos, Args&&... args );\n(since C++11)\n(until C++20)\ntemplate< class... Args >\nconstexpr iterator emplace( const_iterator pos, Args&&... args );\n(since C++20)\n```\n\n实现:\n\n``` cpp\n  template <class... Args>\n  T* emplace(int const* it, Args&&... args) {\n    size_t j = it - m_data;\n    reserve(m_size + 1);\n    if (j >= m_size) [[unlikely]] {\n      throw std::out_of_range(\"out of range\");\n    }\n    // j ~ m_size => j + 1 ~ m_size + 1\n    for (size_t i = m_size; i != j; --i) {\n      std::construct_at(&m_data[i], std::move(m_data[i - 1]));\n      std::destroy_at(&m_data[i - 1]);\n    }\n    std::construct_at(&m_data[j], std::forward<Args>(args)...);\n    ++m_size;\n    return m_data + j;\n  }\n```\n\n## assign()\n\n替换容器的内容。\n\n1) 以 count 份 value 的副本替换内容。\n2) 以范围` [first, last) `中元素的副本替换内容。\n3) 以来自 `initializer_list ilist` 的元素替换内容。\n\n``` cpp\n  void assign(size_t n, T value) {\n    clear();\n    reserve(n);\n    m_size = n;\n    for (size_t i = 0; i < n; ++i) {\n      //   m_data[i] = value;\n      std::construct_at(&m_data[i], value);\n    }\n  }\n\n  template <std::random_access_iterator InputIt>  // todo\n  void assign(InputIt first, InputIt last) {\n    clear();\n    size_t n = last - first;\n    reserve(n);\n    m_size = n;\n    for (size_t i = 0; i < n; ++i) {\n      //   m_data[i] = *first++;\n      std::construct_at(&m_data[i], *first++);\n    }\n  }\n\n  void assign(std::initializer_list<T> ilist) {\n    assign(ilist.begin(), ilist.end());\n  }\n```\n\n## std::random_access_iterator()\n\n## insert()\n\n``` cpp\n(1) iterator insert( const_iterator pos, const T& value );\n(C++20 前)\nconstexpr iterator insert( const_iterator pos, const T& value );\n(C++20 起)\n(2) iterator insert( const_iterator pos, T&& value ); (C++11 起)(C++20 前)\nconstexpr iterator insert( const_iterator pos, T&& value );(C++20 起)\n(3) iterator insert( const_iterator pos, size_type count, const T& value );(C++20 前)\nconstexpr iterator\n    insert( const_iterator pos, size_type count, const T& value );(C++20 起)\n(4) template< class InputIt >\niterator insert( const_iterator pos, InputIt first, InputIt last );(C++20 前)\ntemplate< class InputIt >\nconstexpr iterator insert( const_iterator pos, InputIt first, InputIt last );(C++20 起)\n(5) iterator insert( const_iterator pos, std::initializer_list<T> ilist );(C++11 起)\n(C++20 前)\nconstexpr iterator insert( const_iterator pos,\n                           std::initializer_list<T> ilist );(C++20 起)\n```\n\n插入元素到容器中的指定位置。\n1,2)  在 `pos` 前插入 `value`。\n3)  在 `pos` 前插入 `value` 的 `count` 个副本。\n4) 在 `pos` 前插入来自范围`[first, last)` 的元素。\n如果 `InputIt` 是整数类型，那么此重载与重载 (3) 的效果相同。\n\n(C++11 前)\n此重载只有在`InputIt` 足以为输入迭代器时才会参与重载决议，以避免与重载 (3) 有歧义。\n\n(C++11 起)\n如果 `first` 和 `last` 是指向` *this `中的迭代器，那么行为未定义。\n5) 在 `pos` 前插入来自 `initializer_list ilist` 的元素。\n如果操作后新的 `size()`大于原`capacity()` 则会发生重分配，这种情况下，指代元素的所有迭代器（包括 `end()`迭代器）和所有引用均会失效。否则，仅插入点之前的迭代器和引用保持有效。\n\n```cpp\n参数\npos - 将内容插入到它前面的迭代器。pos 可以是 end() 迭代器\nvalue - 要插入的元素值\ncount - 要插入的元素数量\nfirst, last - 要插入的元素范围，不能是指向调用 insert 所用的容器中的迭代器\nilist - 要插入的值来源的 initializer_list\n\n返回值\n1,2) 指向被插入 value 的迭代器。\n3) 指向首个被插入元素的迭代器，或者在 count == 0 时返回 pos。\n4) 指向首个被插入元素的迭代器，或者在 first == last 时返回 pos。\n5) 指向首个被插入元素的迭代器，或者在 ilist 为空时返回 pos。\n\n复杂度\n1,2) 常数，加上 pos 与容器结尾的距离成线性。\n3) 与 count 成线性，加上 pos 与容器结尾的距离成线性。\n4) 与 std::distance(first, last) 成线性，加上 pos 与容器结尾的距离成线性。\n5) 与 ilist.size() 成线性，加上 pos 与容器结尾的距离成线性。\n```\n\n```cpp\n  // insert 一个\n  T* insert(T const* it, T&& value) {\n    size_t j = it - m_data;\n\n    reserve(m_size + 1);\n    // j ~ m_size => j + 1 ~ m_size + n\n    for (size_t i = m_size; i != j; i--) {\n      std::construct_at(&m_data[i], std::move(m_data[i - 1]));\n      std::destroy_at(&m_data[i - 1]);\n    }\n    m_size += 1;\n\n    std::construct_at(&m_data[j], std::move(value));\n    return m_data + j;\n  }\n\n  T* insert(T const* it, T const& value) {\n    size_t j = it - m_data;\n\n    reserve(m_size + 1);\n    // j ~ m_size => j + 1 ~ m_size + n\n    for (size_t i = m_size; i != j; i--) {\n      std::construct_at(&m_data[i], std::move(m_data[i - 1]));\n      std::destroy_at(&m_data[i - 1]);\n    }\n    m_size += 1;\n\n    std::construct_at(&m_data[j], std::move(value));\n    return m_data + j;\n  }\n\n  T* insert(T const* it, size_t n, T const& val) {\n    size_t j = it - m_data;\n    if (n == 0) [[unlikely]]\n      return const_cast<T*>(it);\n    reserve(m_size + n);\n    // j ~ m_size => j + n ~ m_size + n\n    for (size_t i = m_size; i != j; i--) {\n      std::construct_at(&m_data[i + n - 1], std::move(m_data[i - 1]));\n      std::destroy_at(&m_data[i - 1]);\n    }\n    m_size += n;\n    for (size_t i = j; i != j + n; i++) {\n      std::construct_at(&m_data[i], val);\n    }\n    return m_data + j;\n  }\n\n  template <std::random_access_iterator InputIt>\n  T* insert(T const* it, InputIt first, InputIt last) {\n    size_t j = it - m_data;\n    size_t n = last - first;\n    if (n == 0) [[unlikely]] {\n      return const_cast<T*>(it);\n    }\n    reserve(m_size + n);\n    // j ~ m_size => j + 1 ~ m_size + n\n    for (size_t i = m_size; i != j; i--) {\n      std::construct_at(&m_data[i + n - 1], std::move(m_data[i - 1]));\n      std::destroy_at(&m_data[i - 1]);\n    }\n    m_size += n;\n    for (size_t i = j; i != j + n; i++) {\n      std::construct_at(&m_data[i], *first++);\n    }\n    return m_data + j;\n  }\n\n  T* insert(T const* it, std::initializer_list<T> ilist) {\n    return insert(it, ilist.begin(), ilist.end());\n  }\n```\n\n> arr.capacity arr.size() front back data 见源码\n\n## [[no_unique_address]]\n\n`[[no_unique_address]]`是 C++11 中的一个属性（attribute），用于指示编译器在某些情况下可以对成员进行优化，以减少对象的大小和内存开销。\n\n## std::allocator\n\n首先什么是Allocator？Allocator有什么用？\n\n分配器是负责封装堆内存管理的对象，它们在整个标准库中使用，特别是STL容器使用它们来管理r容器内部的所有内存分配,大部份情况下,程序员不用理会,标准容器使用默认的分配器称为`std :: allocator`,例如当你声明一个简单的`vector`对象时，C++编译器默认已经使用了内置的`std::allocator`,在标准库的`vector`模板当中，第二个模板参数`_Alloc`就是`std::allocator`，实际上，`std::allocator`也是一个类模板\n\n## std::destroy_at\n\n`std::destroy_at` 函数用于销毁（析构）一个对象，但它不会释放先前分配的内存。\n\n[`std::allocator` 、`std::destroy_at`、 `std::construct_at`具体细节见std::allocator](https://lyt-s.github.io/2023/12/18/std-allocator/)\n\n## std::numeric_limits<>\n\n 在C/C++11中，std::numeric_limits为模板类，在库编译平台提供基础算术类型的极值等属性信息，取代传统C语言，所采用的预处理常数。比较常用的使用是对于给定的基础类型用来判断在当前系统上的最大值、最小值。若使用此类，需包含`<limits>`头文件。\n\n``` cpp\n#include <iostream>\n#include <limits>  // std::numeric_limits<T>\n\n//\n/* reference:\n        http://www.cplusplus.com/reference/limits/numeric_limits/\n        https://msdn.microsoft.com/en-us/library/c707ct0t.aspx\n*/\nint main() {\n  std::cout << \"Max value for size_t: \" << std::numeric_limits<size_t>::max()\n            << std::endl;\n  std::cout << \"max number of int : \"\n            << std::numeric_limits<size_t>::max() / sizeof(int) << std::endl;\n  // std::boolalpha 用于将 std::cout 的输出格式设置为以字符串 \"true\" 或 \"false\"\n  // 的形式输出布尔值，而不是默认的 1 或 0。\n  std::cout << std::boolalpha;\n  std::cout << \"Minimum value for int: \" << std::numeric_limits<int>::min()\n            << std::endl;\n  std::cout << \"Maximum value for int: \" << std::numeric_limits<int>::max()\n            << std::endl;\n  std::cout << \"int is signed: \" << std::numeric_limits<int>::is_signed\n            << std::endl;\n  std::cout << \"Non-sign bits in int: \" << std::numeric_limits<int>::digits\n            << std::endl;\n  std::cout << \"int has infinity: \" << std::numeric_limits<int>::has_infinity\n            << std::endl;\n\n  std::cout << \"Minimum value for float: \" << std::numeric_limits<float>::min()\n            << std::endl;  // min returns the smallest positive value the type\n                           // can encode, not the lowest\n  std::cout << \"Lowest value for float: \"\n            << std::numeric_limits<float>::lowest()\n            << std::endl;  // the lowest value\n  std::cout << \"Maximum value for float: \" << std::numeric_limits<float>::max()\n            << std::endl;\n  std::cout << \"float is signed: \" << std::numeric_limits<float>::is_signed\n            << std::endl;\n  std::cout << \"Non-sign bits in float: \" << std::numeric_limits<float>::digits\n            << std::endl;\n  std::cout << \"float has infinity: \"\n            << std::numeric_limits<float>::has_infinity << std::endl;\n\n  std::cout << \"Minimum value for unsigned short: \"\n            << std::numeric_limits<unsigned short>::min() << std::endl;\n  std::cout << \"Maximum value for unsigned short: \"\n            << std::numeric_limits<unsigned short>::max() << std::endl;\n\n  std::cout << \"is_specialized(float): \"\n            << std::numeric_limits<float>::is_specialized << std::endl;\n  std::cout << \"is_integer(float): \" << std::numeric_limits<float>::is_integer\n            << std::endl;\n  std::cout << \"is_exact(float): \" << std::numeric_limits<float>::is_exact\n            << std::endl;\n  std::cout << \"is_bounded(float): \" << std::numeric_limits<float>::is_bounded\n            << std::endl;\n  std::cout << \"is_modulo(float): \" << std::numeric_limits<float>::is_modulo\n            << std::endl;\n  std::cout << \"is_iec559(float): \" << std::numeric_limits<float>::is_iec559\n            << std::endl;\n  std::cout << \"digits10(float): \" << std::numeric_limits<float>::digits10\n            << std::endl;\n  std::cout << \"radix(float): \" << std::numeric_limits<float>::radix\n            << std::endl;\n  std::cout << \"min_exponent(float): \"\n            << std::numeric_limits<float>::min_exponent << std::endl;\n  std::cout << \"max_exponent(float): \"\n            << std::numeric_limits<float>::max_exponent << std::endl;\n  std::cout << \"min_exponent10(float): \"\n            << std::numeric_limits<float>::min_exponent10 << std::endl;\n  std::cout << \"max_exponent10(float): \"\n            << std::numeric_limits<float>::max_exponent10 << std::endl;\n  std::cout << \"epsilon(float): \" << std::numeric_limits<float>::epsilon()\n            << std::endl;\n  std::cout << \"round_style(float): \" << std::numeric_limits<float>::round_style\n            << std::endl;\n\n  std::cout << \"The smallest nonzero denormalized value for float: \"\n            << std::numeric_limits<float>::denorm_min() << std::endl;\n  std::cout << \"The difference between 1 and the smallest value greater than 1 \"\n               \"for float: \"\n            << std::numeric_limits<float>::epsilon() << std::endl;\n  std::cout << \"Whether float objects allow denormalized values: \"\n            << std::numeric_limits<float>::has_denorm << std::endl;\n  std::cout << \"Whether float objects can detect denormalized loss: \"\n            << std::numeric_limits<float>::has_denorm_loss << std::endl;\n  std::cout << \"Whether float objects have quiet_NaN: \"\n            << std::numeric_limits<float>::has_quiet_NaN << std::endl;\n  std::cout << \"Whether float objects have a signaling_NaN: \"\n            << std::numeric_limits<float>::has_signaling_NaN << std::endl;\n  std::cout << \"The base for type float is:  \"\n            << std::numeric_limits<float>::radix << std::endl;\n  std::cout << \"The maximum rounding error for type float is:  \"\n            << std::numeric_limits<float>::round_error() << std::endl;\n  std::cout << \"The rounding style for a double type is: \"\n            << std::numeric_limits<double>::round_style << std::endl;\n  std::cout << \"The signaling NaN for type float is:  \"\n            << std::numeric_limits<float>::signaling_NaN() << std::endl;\n  std::cout << \"Whether float types can detect tinyness before rounding: \"\n            << std::numeric_limits<float>::tinyness_before << std::endl;\n  std::cout << \"Whether float types have implemented trapping: \"\n            << std::numeric_limits<float>::traps << std::endl;\n\n  return 0;\n}\n```\n","tags":["my_stl"],"categories":["c++"]},{"title":"std::allocator堆内存管理器","url":"/2023/12/18/cpp/c++11/std-allocator/","content":"\n\nnew有一些灵活性上的局限，其中一方面表现在它将**内存分配和对象构造组合在了一起**。类似的，**delete将对象析构和内存释放组合在了一起**。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应有什么值。当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象的创建操作(同时付出一定开销)。**一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费。**\n分配器 (allocator) 是C++ STL库的基石之一，它是一种策略模式，允许用户将内存管理从容器中解耦出来，进行更具体化的操作。通过使用 `allocator`，我们可以自定义内存的分配和释放方式，从而可以更好地控制内存的使用。\n\n## 为何使用allocator\n\n在C++中，内存的申请和释放是一个昂贵的操作，频繁的申请和释放可能导致系统的内存碎片，使程序性能下降。通过使用`allocator`，我们可以自定义内存的申请和释放方式，减少系统的内存碎片，提高程序的性能。\n\n此外，`allocator`还有一个重要的作用，那就是将对象的构造和内存的申请分开。在传统的内存申请方式中，我们在申请内存的同时就会调用对象的构造函数，但有时候，我们可能只是想申请内存，而不想立即构造对象，这时候，就可以使用`allocator`。\n\n## allocator的基本使用\n\n在C++ STL中，`allocator`是一个模板类，我们可以通过为它提供一个类型参数来创建一个特定类型的`allocator`。以下是一个基本的例子：\n\n```cpp\n#include <memory>\n\nint main() {\n    std::allocator<int> alloc; // 创建一个分配int的allocator\n    int* p = alloc.allocate(10); // 分配10个int的空间\n\n    // 使用未构造的内存\n    for (int i = 0; i < 10; ++i) {\n        alloc.construct(p + i, i); // 在分配的内存上构造对象\n    }\n\n    // 销毁对象并释放内存\n    for (int i = 0; i < 10; ++i) {\n        alloc.destroy(p + i); // 销毁对象\n    }\n    alloc.deallocate(p, 10); // 释放内存\n    return 0;\n}\n\n```\n\n## 自定义分配器\n\n通过自定义分配器，我们可以更灵活地控制内存的申请和释放。例如，我们可以将`vector`的数据直接存储到数据库、共享内存或者文件中，实现了数据的持久化和共享。\n\n一个自定义分配器需要提供以下几个接口：\n\n* typedefs：为使用的类型定义别名\n* allocate(n)：分配能容纳n个对象的内存\n* deallocate(p, n)：释放前面分配的内存\n* construct(p, val)：在指针p所指向的内存上构造一个对象，其值为val\n* destroy(p)：销毁指针p所指向的对象\n\n以下是一个简单的自定义分配器的例子：\n\n```cpp\ntemplate <class T>\nclass MyAllocator {\npublic:\n    typedef T value_type;\n\n    MyAllocator() = default;\n    template <class U> constexpr MyAllocator(const MyAllocator<U>&) noexcept {}\n\n    T* allocate(std::size_t n) {\n        return static_cast<T*>(::operator new(n*sizeof(T)));\n    }\n\n    void deallocate(T* p, std::size_t) noexcept {\n        ::operator delete(p);\n    }\n};\n\ntemplate <class T, class U>\nbool operator==(const MyAllocator<T>&, const MyAllocator<U>&) { return true; }\n\ntemplate <class T, class U>\nbool operator!=(const MyAllocator<T>&, const MyAllocator<U>&) { return false; }\n\n```\n\n在这个例子中，我们创建了一个自定义的分配器`MyAllocator`，这个分配器使用全局`new`和`delete`操作符来分配和释放内存。\n\n## 自定义分配器的使用\n\n自定义分配器可以用于STL中的任何容器，包括`vector`、`list`等。以下是一个使用自定义分配器的`vector`的例子：\n\n```cpp\n#include <vector>\n#include \"MyAllocator.h\" // 包含你的自定义分配器的头文件\n\nint main() {\n    std::vector<int, MyAllocator<int>> vec; // 使用自定义分配器的vector\n    vec.push_back(1);\n    vec.push_back(2);\n    vec.push_back(3);\n    return 0;\n}\n\n```\n\n在这个例子中，我们创建了一个使用`MyAllocator`的`std::vector`。因此，这个`vector`的内存管理策略将由我们的`MyAllocator`来决定。同样的方法也可以应用于`std::list`或其他`STL`容器。\n\n## 未初始化内存算法\n\n在 C++ STL 中，有一系列的未初始化内存算法，这些算法用于在未初始化的内存上直接构造对象，可以提高程序的效率。这些算法的名称通常以 `uninitialized_`开头，其中 `uninitialized_copy` 是最常用的一种。\n\n### uninitialized_copy 算法\n\n`uninitialized_copy` 是一种用于在未初始化内存上复制序列的算法。它接受两个输入迭代器（定义了要复制的序列）和一个输出迭代器（定义了未初始化内存的起始位置），并尝试在输出范围内构造与输入序列相同的元素。\n\n以下是 `uninitialized_copy` 的基本用法：\n在上述代码中，我们首先创建了一个包含五个整数的 `vector`。然后，我们使用 `allocator` 分配了一块足以存储 `vector` 中所有元素的未初始化内存。接着，我们使用 `uninitialized_copy` 将 `vector` 中的元素复制到这块未初始化的内存中。最后，我们遍历这块内存，对每个元素调用 `destroy`，然后调用 `deallocate` 释放整块内存。\n\n需要注意的是，由于 `uninitialized_copy` 不会自动调用 `destructor` 和 `deallocate`，所以我们需要手动调用它们以防止内存泄露。\n\n``` cpp\n#include <cstddef>\n#include <cstdio>\n#include <iostream>\n#include <memory>\n#include <vector>\n\nint main() {\n  std::vector<int> vec{1, 2, 3, 4, 5};\n  std::allocator<int> alloc;\n  auto print_list = [&](std::vector<int> const& vec) {\n    for (size_t i = 0; i < vec.size(); ++i) {\n      printf(\"vec[%zd] = %d\\n\", i, vec[i]);\n    }\n  };\n\n  // 使用 allocator 分配未初始化内存\n  int* p = alloc.allocate(vec.size());\n\n  // 使用 uninitialized_copy 将 vec 中的元素复制到未初始化的内存中\n  std::uninitialized_copy(vec.begin(), vec.end(), p);\n  for (int i = 0; i < vec.size(); ++i) {\n    std::cout << p[i] << \" \";\n  }\n  std::cout << std::endl;\n\n  // 使用完成后，需要手动调用 destructor 和 deallocate 释放资源\n  for (std::size_t i = 0; i < vec.size(); ++i) {\n    std::destroy_at(p + i);\n  }\n  alloc.deallocate(p, vec.size());\n\n  return 0;\n}\n```\n\n### uninitialized_copy_n 算法\n\n`uninitialized_copy_n` 是 `uninitialized_copy` 的一个变体，它接受一个输入迭代器（定义了要复制的序列的起始位置）、一个大小值n（定义了要复制的元素数量）和一个输出迭代器（定义了未初始化内存的起始位置），并尝试在输出范围内构造与输入序列前n个相同的元素。\n\n以下是 `uninitialized_copy_n` 的基本用法：\n\n``` cpp\n#include <memory>\n#include <vector>\n\nint main() {\n    std::vector<int> vec {1, 2, 3, 4, 5};\n    std::allocator<int> alloc;\n\n\n    // 使用 allocator 分配未初始化内存\n    int* p2 = alloc.allocate(vec.size());\n\n    // 使用 uninitialized_copy_n 将 vec 中的前3个元素复制到未初始化的内存中\n    std::uninitialized_copy_n(vec.begin(), 3, p2);\n    for (int i = 0; i < 3; ++i) {\n        std::cout << p2[i] << \" \";\n    }\n    std::cout << std::endl;\n    // 使用完成后，需要手动调用 destructor 和 deallocate 释放资源\n    for (std::size_t i = 0; i < 3; ++i) {\n        std::destroy_at(p2 + i);\n    }\n  \n    alloc.deallocate(p2, vec.size());\n\n    return 0;\n}\n\n```\n\n在上述代码中，我们首先创建了一个包含五个整数的 `vector`。然后，我们使用 `allocator` 分配了一块足以存储 `vector` 中所有元素的未初始化内存。接着，我们使用 `uninitialized_copy_n` 将 `vector` 中的前3个元素复制到这块未初始化的内存中。最后，我们遍历这块内存，对复制的每个元素调用 `destroy`，然后调用 `deallocate` 释放整块内存。\n\n需要注意的是，由于 `uninitialized_copy_n` 不会自动调用 `destructor` 和`deallocate`，所以我们需要手动调用它们以防止内存泄露。这点与 `uninitialized_copy` 是一样的。\n\n### uninitialized_fill 算法\n\n`uninitialized_fill` 是一种在未初始化内存上填充值的算法。它接受两个迭代器（定义了未初始化内存的范围）和一个值，然后尝试在指定范围内构造这个值。\n\n以下是 `uninitialized_fill` 的基本用法：\n\n```cpp\n#include <memory>\n\nint main() {\n\n    std::allocator<int> alloc;\n\n    // 使用 allocator 分配未初始化内存\n    int* p3 = alloc.allocate(5);\n\n    // 使用 uninitialized_fill 将值42填充到未初始化的内存中\n    std::uninitialized_fill(p3, p3 + 5, 42);\n    for (size_t i = 0; i < 5; ++i) {\n        std::cout << p3[i] << \" \";\n    }\n    // 使用完成后，需要手动调用 destructor 和 deallocate 释放资源\n    for (std::size_t i = 0; i < 5; ++i) {\n        std::destroy_at(p3 + i);\n    }\n    alloc.deallocate(p3, 5);\n\n    return 0;\n}\n\n```\n\n在上述代码中，我们使用 `allocator` 分配了一块可以存储5个整数的未初始化内存。然后，我们使用 `uninitialized_fill` 将值42填充到这块未初始化的内存中。最后，我们遍历这块内存，对每个元素调用 `destroy`，然后调用 `deallocate` 释放整块内存。\n\n需要注意的是，由于 `uninitialized_fill` 不会自动调用 `destructor` 和 `deallocate`，所以我们需要手动调用它们以防止内存泄露。\n\n其他的未初始化内存算法（`uninitialized_fill_n`、`uninitialized_default_construct`、`uninitialized_value_construct`）用法与` uninitialized_copy `类似，也需要注意手动调用 `destructor` 和 `deallocate` 以防止内存泄露。\n\n## construct_at、destroy_at 对象构造和销毁\n\n在` C++17 `和 `C++20` 中，有两个非常重要的函数：`std::construct_at` 和 `std::destroy_at`。这两个函数可以分别在给定的内存位置上构造和销毁对象。\n\n### std::construct_at\n\nstd::construct_at 是一种在指定内存位置上构造对象的方法。它接受一个指针和一系列构造函数参数，然后在指针指向的内存位置上构造一个对象。\n\n### std::destroy_at\n\n`std::destroy_at` 是一种在指定内存位置上销毁对象的方法。它接受一个指针，然后调用该指针指向的对象的析构函数。\n\n`std::construct_at` ， `std::destroy_at` 的基本用法。\n\n``` cpp\n#include <cstddef>\n#include <cstdio>\n#include <iostream>\n#include <memory>\n#include <vector>\n\nstruct MyStruct {\n  int x;\n  float y;\n  MyStruct(int x, float y) : x(x), y(y) {\n    std::cout << \"MyStruct(int x, float y)\" << std::endl;\n  }\n  ~MyStruct() {\n    // 自定义析构函数\n    std::cout << \"MyStruct object is being destroyed.\\n\";\n  }\n};\n\nint main() {\n  std::vector<int> vec{1, 2, 3, 4, 5};\n  std::allocator<int> alloc;\n  auto print_list = [&](std::vector<int> const& vec) {\n    for (size_t i = 0; i < vec.size(); ++i) {\n      printf(\"vec[%zd] = %d\\n\", i, vec[i]);\n    }\n  };\n\n  // 使用 allocator 分配未初始化内存\n  int* p = alloc.allocate(vec.size());\n\n  // 使用 uninitialized_copy 将 vec 中的元素复制到未初始化的内存中\n  std::uninitialized_copy(vec.begin(), vec.end(), p);\n  for (int i = 0; i < vec.size(); ++i) {\n    std::cout << p[i] << \" \";\n  }\n  std::cout << std::endl;\n\n  // 使用完成后，需要手动调用 destructor 和 deallocate 释放资源\n  for (std::size_t i = 0; i < vec.size(); ++i) {\n    std::destroy_at(p + i);\n  }\n  alloc.deallocate(p, vec.size());\n\n  //----uninitialized_copy_n---------------------------------------------------\n  // 使用 allocator 分配未初始化内存\n  int* p2 = alloc.allocate(vec.size());\n\n  // 使用 uninitialized_copy_n 将 vec 中的前3个元素复制到未初始化的内存中\n  std::uninitialized_copy_n(vec.begin(), 3, p2);\n  for (int i = 0; i < 3; ++i) {\n    std::cout << p2[i] << \" \";\n  }\n  std::cout << std::endl;\n  // 使用完成后，需要手动调用 destructor 和 deallocate 释放资源\n  for (std::size_t i = 0; i < 3; ++i) {\n    std::destroy_at(p2 + i);\n  }\n\n  alloc.deallocate(p2, vec.size());\n\n  //----uninitialized_fill-------------------------------------------------\n\n  // 使用 allocator 分配未初始化内存\n  int* p3 = alloc.allocate(5);\n\n  // 使用 uninitialized_fill 将值42填充到未初始化的内存中\n  std::uninitialized_fill(p3, p3 + 5, 42);\n  for (size_t i = 0; i < 5; ++i) {\n    std::cout << p3[i] << \" \";\n  }\n  // 使用完成后，需要手动调用 destructor 和 deallocate 释放资源\n  for (std::size_t i = 0; i < 5; ++i) {\n    std::destroy_at(p3 + i);\n  }\n  alloc.deallocate(p3, 5);\n\n  //------------------------------------------------\n  std::allocator<MyStruct> alloc_my_struct;\n\n  // 使用 allocator 分配未初始化内存\n  MyStruct* p_my_struct = alloc_my_struct.allocate(1);\n\n  // 使用 construct_at 在未初始化的内存中构造一个 MyStruct 对象\n  std::construct_at(p_my_struct, 42, 3.14f);\n\n  // 使用完成后，需要手动调用 destroy_at 和 deallocate 释放资源\n  std::destroy_at(p_my_struct);\n  alloc.deallocate(p, 1);\n\n  return 0;\n}\n```\n\n在上述代码中，我们首先定义了一个名为 `MyStruct` 的结构，它具有一个自定义的析构函数。然后，我们使用 `allocator` 分配了一块足以存储一个 `MyStruct` 对象的未初始化内存。接着，我们使用 `construct_at` 在这块未初始化的内存上构造一个 `MyStruct` 对象。接下来，我们调用 `destroy_at` 销毁这个对象，可以看到自定义析构函数的输出信息。最后，我们调用 `deallocate` 释放整块内存。\n\n总的来说，`std::construct_at` 和 `std::destroy_at`提供了一种方便、安全的方式在指定的内存位置上构造和销毁对象，与直接使用 `new` 和 `delete` 相比，它们提供了更好的控制，尤其是在处理未初始化的内存时。\n","tags":["c++11","c++17","c++20"],"categories":["c++"]},{"title":"FFplay源码分析---decoder_decode_frame()","url":"/2023/12/12/FFmpeg/ffplay源码分析/decoder-decode-frame/","content":"## decoder_decode_frame()\n\n![Alt text](../../../images/FFmpeg/ffplay源码分析/decoder_decode_frame().png)\n`decoder_decode_frame()` 其实是一个通用的解码函数，可以解码 音频，视频，字幕的 AVPacket。不过本文主要侧重于分析音频流的解码，但其他的流也是类似的逻辑。\n\n### 函数参数分析\n\n1. `Decoder *d`，这个 `Decoder` 结构，我把它称为解码管理实例。由于 `Decoder` 结构里面有解码器实例 跟 `PacketQueue` 队列，所以只需要传递 `Decoder` 给`decoder_decode_frame()` 函数就能进行解码了。如下：\n\n    ``` cpp\n    typedef struct Decoder {\n        ...\n        PacketQueue *queue; // AVPacket 队列\n        AVCodecContext *avctx; //解码器实例\n        ...\n    } Decoder\n    ```\n\n2. `AVFrame *frame` ，用来存储解码出来的音频或者视频的 `AVFrame`。\n\n3. `AVSubtitle *sub` ，用来存储解码出来的字幕数据，字幕流的使用的数据结构不是 `AVFrame`，而是 `AVSubtitle` 。\n\n### 流程图\n\n![Alt text](../../../images/FFmpeg/ffplay源码分析/decoder_decode_frame()流程图.png)\n\n### 函数如下\n\n**一个for循环结束**------------------------\n\n两个`do while`\n\n``` cpp\nstatic int decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *sub) {\n    int ret = AVERROR(EAGAIN);\n\n    for (;;) {\n        // if---因为已经跳转到别的时间播放了，解码器的缓存是以前的时间点缓存的。如果还继续取，窗口画面就有短暂的不准确。\n        if (d->queue->serial == d->pkt_serial) {\n            // 第一次，必然会跳出此循环\n            do {\n                if (d->queue->abort_request)\n                    return -1;\n\n                switch (d->avctx->codec_type) {\n                    case AVMEDIA_TYPE_VIDEO:\n                        // 第一次时，必然返回 `EAGAIN` \n                        // 后面调用时,仍然可能还是会返回`EAGAIN`，因为不是往解码器发一个`AVPacket`，就一定有数据可读的。有些是 B 帧，还需要多一个P帧来解码。\n                        ret = avcodec_receive_frame(d->avctx, frame);\n                        if (ret >= 0) {\n                            if (decoder_reorder_pts == -1) {\n                                frame->pts = frame->best_effort_timestamp;\n                            } else if (!decoder_reorder_pts) {\n                                frame->pts = frame->pkt_dts;\n                            }\n                        }\n                        break;\n                    case AVMEDIA_TYPE_AUDIO:\n                        // 第一次时，必然返回 `EAGAIN` \n                        ret = avcodec_receive_frame(d->avctx, frame);\n                        if (ret >= 0) {\n                            AVRational tb = (AVRational){1, frame->sample_rate};\n                            if (frame->pts != AV_NOPTS_VALUE)\n                                frame->pts = av_rescale_q(frame->pts, d->avctx->pkt_timebase, tb);\n                            else if (d->next_pts != AV_NOPTS_VALUE)\n                                frame->pts = av_rescale_q(d->next_pts, d->next_pts_tb, tb);\n                            if (frame->pts != AV_NOPTS_VALUE) {\n                                d->next_pts = frame->pts + frame->nb_samples;\n                                d->next_pts_tb = tb;\n                            }\n                        }\n                        break;\n                }\n                if (ret == AVERROR_EOF) {\n                    d->finished = d->pkt_serial;\n                    avcodec_flush_buffers(d->avctx);\n                    return 0;\n                }\n                if (ret >= 0)\n                    return 1;\n            } while (ret != AVERROR(EAGAIN));\n        }\n\n        do {\n            if (d->queue->nb_packets == 0)\n                // 唤醒read_thread线程\n                SDL_CondSignal(d->empty_queue_cond);\n            if (d->packet_pending) {\n                d->packet_pending = 0;\n            } else {\n                int old_serial = d->pkt_serial;\n                if (packet_queue_get(d->queue, d->pkt, 1, &d->pkt_serial) < 0)\n                    return -1;\n                // 清空解码器缓存,从队列取出来的 AVPacket 跟上一次取的 AVPacket 序列号不一样，就会刷新解码器的缓存。\n                if (old_serial != d->pkt_serial) {\n                    avcodec_flush_buffers(d->avctx);\n                    d->finished = 0;\n                    d->next_pts = d->start_pts;\n                    d->next_pts_tb = d->start_pts_tb;\n                }\n            }\n            // 如果不相等，就会直接 `av_packet_unref()` 释放，然后再进入 `while` 循环再从队列取`AVPacket`,快进时,丢弃数据.\n            if (d->queue->serial == d->pkt_serial)\n                break;\n            av_packet_unref(d->pkt);\n        } while (1);\n\n        if (d->avctx->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            int got_frame = 0;\n            ret = avcodec_decode_subtitle2(d->avctx, sub, &got_frame, d->pkt);\n            if (ret < 0) {\n                ret = AVERROR(EAGAIN);\n            } else {\n                if (got_frame && !d->pkt->data) {\n                    // 发送解码器失败，把AVPacket缓存起来，下次继续发送。\n                    d->packet_pending = 1;\n                }\n                ret = got_frame ? 0 : (d->pkt->data ? AVERROR(EAGAIN) : AVERROR_EOF);\n            }\n            av_packet_unref(d->pkt);\n        } else {\n            if (avcodec_send_packet(d->avctx, d->pkt) == AVERROR(EAGAIN)) {\n                av_log(d->avctx, AV_LOG_ERROR, \"Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\");\n                // 发送解码器失败，把AVPacket缓存起来，下次继续发送。\n                d->packet_pending = 1;\n            } else {\n                av_packet_unref(d->pkt);\n            }\n        }\n    }\n}\n```\n\n### 第一个 `do while`\n\n一开始就会用 `avcodec_receive_frame()`去解码器读数据，这里读者可能会有疑问，明明都还没往解码器发送 `AVPacket`， `avcodec_receive_frame()` 函数怎么可能读取到 `AVFrame` 呢？\n\n答：没错，就是读取不到，因为还没发 `AVPacket` 给解码器解码。所以，首次 `avcodec_receive_frame()`必然返回 `EAGAIN`，所以就会跳出这个`do{}while{}` 循环。\n\n### 第二个 `do while`\n\n1. `SDL_CondSignal(d->empty_queue_cond)`，首先，如果 `PacketQueue` 队列里面如果没有数据可读了，就需要唤醒`read_thread()` 线程来读数据，之前说过， `empty_queue_cond` 实际上就是 `continue_read_thread`，这两个指针都指向同一个条件变量。\n\n2. 判断之前发送 `AVPacket` 给解码器是否失败了？如果失败，`d->packet_peding` 会是 1。如果上次失败了，`d->pkt`本身就是有值的，就不需要重队列里面拿数据，直接把`d->pkt` 发送给解码器即可。\n\n3. 调用 `packet_queue_get()` 从 队列读取 AVPacket。简单讲解一下 `packet_queue_get()` 函数的参数，定义如下：\n\n   * `int block` 是控制 `packet_queue_get()` 函数阻塞读取的，如果 `PacketQueue` 队列里面如果没有数据可读，可以一直阻塞等到 `read_thread()`线程读到数据放进去队列 为止。\n   * `AVPacket *pkt`，用来放从队列读取到的 `AVPacket。`\n   * `int *serial`，读取到的 `AVPacket` 的序列号，这是一个返回值。传的是指针。\n\n```cpp\nstatic int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block, int *serial)\n```\n\n`PacketQueue` 队列是一个 `FIFO` 的内存管理器，存的是 `MyAVPacketList`，如下：\n也就是说，队列里的每一个 `AVPacket` 都有一个序列号的。\n\n```cpp\ntypedef struct MyAVPacketList {\n    AVPacket *pkt;\n    int serial;\n} MyAVPacketList;\n```\n\n再回到` decoder_decode_frame() `调用 `packet_queue_get()` 时的传参，如下：\n\n```cpp\n        int old_serial = d->pkt_serial;\n        if (packet_queue_get(d->queue, d->pkt, 1, &d->pkt_serial) < 0)\n```\n\n可以看到从队列取出来的 `AVPacket` 就放在 `d->pkt`里面，而序列号就放在`d->pkt_serial`。\nFFplay播放器其实有 3 种序列号：\n\n1. `MyAVPacketList` 的 `serial` ，队列里面的 `AVPacket` 的序列号。可以看成是临时值，旧值。\n\n2. `PackeQueue` 的 `serial` ，这是队列本身的序列号。可以看成是最新的序列号的值。\n\n3. `Frame` 的 `serial`，本文不需要关注这个, todo --- 序列号分析\n\n`MyAVPacketList` 的 `serial` 就是用`PackeQueue` 队列的 `serial` 来赋值的 。如下代码：**只要不进行跳转播放，他们的序列号就是一样的。**\n\n当快进快退，或者跳转播放时间点的时候，`PackeQueue`队列的序列号就会 +1，而之前已经放进去队列的 `MyAVPacketList` 的序列号则保持不变。\n\n**举个例子**，当前MP4已经播放到了 第20秒的时刻，此时 `PackeQueue` 队列缓存了 5 帧第 21秒的数据，此时，我快进30秒，跳转到第 50 秒的时刻播放。\n\n由于跳转了，所以队列的序列号会 +1，变成了 2，而之前的 5 帧 `MyAVPacketList` 的序列号还是 1。两者就会不一样。\n\n因为要开始播放第 50 秒的数据，所以 `PackeQueue` 队列之前缓存的 5 帧数据就不可用了。丢弃这 5 帧数据就是由下面的代码实现的。\n\n``` cpp\n      if (d->queue->serial == d->pkt_serial)\n          break;\n      av_packet_unref(d->pkt);\n```\n\n注意看上面圈出来的代码，只有两者相等，才会 `break` 退出，如果不相等，就会直接 `av_packet_unref()` 释放，然后再进入 `while` 循环再从队列取`AVPacket`。\n\n这样，就能把无效的 5 帧数据全部丢弃，直到从队列读取到序列号一致的 `AVPacket` 为止。\n\n### 刷新缓存\n\n``` cpp\n    if (old_serial != d->pkt_serial) {\n        avcodec_flush_buffers(d->avctx);\n        d->finished = 0;\n        d->next_pts = d->start_pts;\n        d->next_pts_tb = d->start_pts_tb;\n    }\n```\n\n就是当从队列取出来的 `AVPacket` 跟上一次取的 `AVPacket` 序列号不一样，就会刷新解码器的缓存。\n\n序列号不一样，肯定是因为跳转了播放时间点，而解码器要按顺序解码的，如果不清空缓存，可能会导致马赛克。\n\n### avcodec_send_packet()\n\n假设现在已经从队列读取到 序列号跟队列一样的`AVPacket`，就会把 `AVPacket` 发送给解码器，如下：\n\n```cpp\n  } else {\n      if (avcodec_send_packet(d->avctx, d->pkt) == AVERROR(EAGAIN)) {\n          av_log(d->avctx, AV_LOG_ERROR, \"Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\");\n          d->packet_pending = 1;\n      } else {\n          av_packet_unref(d->pkt);\n      }\n  }\n```\n\n由于发送解码器可能会失败，所以 `ffplay` 做了一下处理，如果失败，就不`unref`，直接标记一下 `d->packet_pending`，下次再继续发送。\n\n---\n\n此时，已经成功发送 `AVPacket` 给解码器了。这时候，`decoder_decode_frame()` 还没有结束，此时此刻还没跳出 最开始的 `for (;;) {}` 循环。\n\n所以又会重新进入一开始的往解码器读 `AVFrame` 的逻辑，`decoder_decode_frame()`函数的逻辑可以说是反着来的，所以看起来有点奇怪。\n\n现在回到一开始的逻辑，如下：\n\n```cpp\n// if---因为已经跳转到别的时间播放了，解码器的缓存是以前的时间点缓存的。如果还继续取，窗口画面就有短暂的不准确。\n        if (d->queue->serial == d->pkt_serial) {\n            do {\n                if (d->queue->abort_request)\n                    return -1;\n\n                switch (d->avctx->codec_type) {\n                    case AVMEDIA_TYPE_VIDEO:\n                    // 仍然可能还是会返回`EAGAIN`，因为不是往解码器发一个`AVPacket`，就一定有数据可读的。有些是 B 帧，还需要多一个P帧来解码。\n                        ret = avcodec_receive_frame(d->avctx, frame);\n                        if (ret >= 0) {\n                            if (decoder_reorder_pts == -1) {\n                                frame->pts = frame->best_effort_timestamp;\n                            } else if (!decoder_reorder_pts) {\n                                frame->pts = frame->pkt_dts;\n                            }\n                        }\n                        break;\n                    case AVMEDIA_TYPE_AUDIO:\n                        ret = avcodec_receive_frame(d->avctx, frame);\n                        if (ret >= 0) {\n                            AVRational tb = (AVRational){1, frame->sample_rate};\n                            if (frame->pts != AV_NOPTS_VALUE)\n                                frame->pts = av_rescale_q(frame->pts, d->avctx->pkt_timebase, tb);\n                            else if (d->next_pts != AV_NOPTS_VALUE)\n                                frame->pts = av_rescale_q(d->next_pts, d->next_pts_tb, tb);\n                            if (frame->pts != AV_NOPTS_VALUE) {\n                                d->next_pts = frame->pts + frame->nb_samples;\n                                d->next_pts_tb = tb;\n                            }\n                        }\n                        break;\n                }\n                if (ret == AVERROR_EOF) {\n                    d->finished = d->pkt_serial;\n                    avcodec_flush_buffers(d->avctx);\n                    return 0;\n                }\n                if (ret >= 0)\n                    return 1;\n            } while (ret != AVERROR(EAGAIN));\n        }\n```\n\n### avcodec_receive_frame()\n\n`avcodec_receive_frame()` 仍然可能还是会返回`EAGAIN`，因为不是往解码器发一个`AVPacket`，就一定有数据可读的。有些是 B 帧，还需要多一个P帧来解码。所以如果 `avcodec_receive_frame()` 返回 `EAGAIN`，就会从 `PacketQueue` 队列再拿出一个 `AVPacket` 往解码器丢。\n\n现在我们假设`avcodec_receive_frame()` 能读出数据了，可以看到，它赋值给了参数 `frame`，也就是第二个参数。\n\n读到 `AVFrame` 之后，`decoder_decode_frame()`就会直接 `return 1` 退出了。\n\n注意，`decoder_decode_frame()` 只从解码器读取到一个 `AVFrame` 就返回了，如果解码器里面还有缓存的`AVFrame`，下次就可以直接取，而不用再从队列拿 `AVPacket` 再发送给解码器。\n\n**这就是为什么从解码器读 AVFrame 要加上这个 if 判断：**\n\n因为已经跳转到别的时间播放了，解码器的缓存是以前的时间点缓存的。如果还继续取，窗口画面就有短暂的不准确。\n\n``` cpp\n\n\nif (d->queue->serial == d->pkt_serial) {\n    ...\n}\n```\n\n---\n\n总结:\n\n`decoder_decode_frame()` 函数的逻辑就是从解码器读取到 一个`AVFrame`，为了解码出一个`AVFrame`，它会从 `PacketQueue` 队列取 `AVPacekt` 发送给解码器，需要多少个就取多少个 `AVPacekt`，直至到能解码出一个 `AVFrame。`\n\n`decoder_decode_frame()` 函数有 3 个返回值:\n\n* 返回 1，获取到 `AVFrame` 。\n* 返回 0 ，获取不到 `AVFrame` ，0 代表已经解码完`MP4`的所有`AVPacket`。这种情况一般是 `ffplay` 播放完了整个 `MP4` 文件，窗口画面停在最后一帧。但是由于你可以按`C` 键重新循环播放，所以即便返回 0 也不能退出 `audio_thread` 线程。\n* 返回 -1，代表 `PacketQueue` 队列关闭了`(abort_request)`。返回 -1 会导致 `audio_thread()` 函数用 `goto the_end` 跳出 `do{}whlle{}` 循环，跳出循环之后，`audio_thread` 线程就会自己结束了。返回`-1` 通常是因为关闭了 `ffplay` 播放器。\n","tags":["FFplay源码分析"]},{"title":"FFplay源码分析---audio_thread()","url":"/2023/12/12/FFmpeg/ffplay源码分析/audio-thread/","content":"\n\n## audio_thread()\n\n![Alt text](../../../images/FFmpeg/ffplay源码分析/audio_thread().png)\n在 stream_component_open() 里面的 decode_start() 函数开启了 audio_thread 线程，如下：\n\n``` cpp\nif ((ret = decoder_start(&is->auddec, audio_thread, \"audio_decoder\", is)) < 0)\n    goto out;\n```\n\naudio_thread 线程主要是负责 解码 PacketQueue 队列里面的 AVPacket 的，解码出来 AVFrame，然后丢给入口滤镜，再从出口滤镜把 AVFrame 读出来，再插入 FrameQueue 队列。\n\n流程图如下:\n![Alt text](../../../images/FFmpeg/ffplay源码分析/audio_open流程.png)\n\n``` cpp\nstatic int audio_thread(void *arg)\n{\n    VideoState *is = arg;\n    AVFrame *frame = av_frame_alloc();\n    Frame *af;\n#if CONFIG_AVFILTER\n    int last_serial = -1;\n    int64_t dec_channel_layout;\n    int reconfigure;\n#endif\n    int got_frame = 0;\n    AVRational tb;\n    int ret = 0;\n\n    if (!frame)\n        return AVERROR(ENOMEM);\n\n    do {\n        if ((got_frame = decoder_decode_frame(&is->auddec, frame, NULL)) < 0)\n            goto the_end;\n\n        if (got_frame) {\n                tb = (AVRational){1, frame->sample_rate};\n\n#if CONFIG_AVFILTER\n                dec_channel_layout = get_valid_channel_layout(frame->channel_layout, frame->channels);\n\n                reconfigure =\n                    cmp_audio_fmts(is->audio_filter_src.fmt, is->audio_filter_src.channels,\n                                   frame->format, frame->channels)    ||\n                    is->audio_filter_src.channel_layout != dec_channel_layout ||\n                    is->audio_filter_src.freq           != frame->sample_rate ||\n                    is->auddec.pkt_serial               != last_serial;\n\n                if (reconfigure) {\n                    char buf1[1024], buf2[1024];\n                    av_get_channel_layout_string(buf1, sizeof(buf1), -1, is->audio_filter_src.channel_layout);\n                    av_get_channel_layout_string(buf2, sizeof(buf2), -1, dec_channel_layout);\n                    av_log(NULL, AV_LOG_DEBUG,\n                           \"Audio frame changed from rate:%d ch:%d fmt:%s layout:%s serial:%d to rate:%d ch:%d fmt:%s layout:%s serial:%d\\n\",\n                           is->audio_filter_src.freq, is->audio_filter_src.channels, av_get_sample_fmt_name(is->audio_filter_src.fmt), buf1, last_serial,\n                           frame->sample_rate, frame->channels, av_get_sample_fmt_name(frame->format), buf2, is->auddec.pkt_serial);\n\n                    is->audio_filter_src.fmt            = frame->format;\n                    is->audio_filter_src.channels       = frame->channels;\n                    is->audio_filter_src.channel_layout = dec_channel_layout;\n                    is->audio_filter_src.freq           = frame->sample_rate;\n                    last_serial                         = is->auddec.pkt_serial;\n\n                    if ((ret = configure_audio_filters(is, afilters, 1)) < 0)\n                        goto the_end;\n                }\n\n            if ((ret = av_buffersrc_add_frame(is->in_audio_filter, frame)) < 0)\n                goto the_end;\n\n            while ((ret = av_buffersink_get_frame_flags(is->out_audio_filter, frame, 0)) >= 0) {\n                tb = av_buffersink_get_time_base(is->out_audio_filter);\n#endif\n                if (!(af = frame_queue_peek_writable(&is->sampq)))\n                    goto the_end;\n\n                af->pts = (frame->pts == AV_NOPTS_VALUE) ? NAN : frame->pts * av_q2d(tb);\n                af->pos = frame->pkt_pos;\n                af->serial = is->auddec.pkt_serial;\n                af->duration = av_q2d((AVRational){frame->nb_samples, frame->sample_rate});\n\n                av_frame_move_ref(af->frame, frame);\n                frame_queue_push(&is->sampq);\n\n#if CONFIG_AVFILTER\n                if (is->audioq.serial != is->auddec.pkt_serial)\n                    break;\n            }\n            if (ret == AVERROR_EOF)\n                is->auddec.finished = is->auddec.pkt_serial;\n#endif\n        }\n    } while (ret >= 0 || ret == AVERROR(EAGAIN) || ret == AVERROR_EOF);\n the_end:\n#if CONFIG_AVFILTER\n    avfilter_graph_free(&is->agraph);\n#endif\n    av_frame_free(&frame);\n    return ret;\n}\n```\n\n1. `audio_thread` 函数一开始就进入 一个 `do{...}while{...}` ，不断地调` decoder_decode_frame() `函数来解码出 `AVFrame`\n2. 然后把 `AVFrame` 往 入口滤镜(`av_buffersrc_add_frame`) 丢，再循环调`av_buffersink_get_frame_flags()`，不断从出口滤镜收割经过 `Filter` 的`AVFrame`\n3. 最后调` frame_queue_push() `把 `AVFrame` 插入 `FrameQueue` 队列。\n4. 但是如果解码出来的 `AVFrame` 的音频格式与入口滤镜要求的音频格式不一样，会重建滤镜（reconfigure），如下：\n\n```cpp\n    reconfigure =\n        cmp_audio_fmts(is->audio_filter_src.fmt, is->audio_filter_src.channels,\n                        frame->format, frame->channels)    ||\n        is->audio_filter_src.channel_layout != dec_channel_layout ||\n        is->audio_filter_src.freq           != frame->sample_rate ||\n        is->auddec.pkt_serial               != last_serial;\n\n```\n\n开始的入口滤镜 `audio_filter_src`的音频格式 是直接从解码器实例（avctx）里面取的，如下：\n\n``` cpp\n      // 从解码器出来的音频信息,ffplay.c 2648行\n      is->audio_filter_src.freq           = avctx->sample_rate;\n      is->audio_filter_src.channels       = avctx->channels;\n      is->audio_filter_src.channel_layout = get_valid_channel_layout(avctx->channel_layout, avctx->channels);\n      is->audio_filter_src.fmt            = avctx->sample_fmt;\n```\n\n而解码器实例`avctx`的音频信息又是从 容器层的流信息里面取出来的。\n\n```cpp\nffpaly.c 2592 行\nret = avcodec_parameters_to_context(avctx, ic->streams[stream_index]->codecpar);\n```\n\n所以以下 3 种场景会重新创建滤镜：\n\n1. 容器层记录的采样率等信息是错误的，与实际解码出来的不符。\n\n2. 解码过程中，中途解码出来的 `AVFrame` 的采样率，声道数或者采样格式 出现变动，与上一次解码出来的 `AVFrame` 不一样。\n\n3. 进行了快进快退操作，因为快进快退会导致 `is->auddec.pkt_serial` 递增。todo --- FFplay序列号分. 。我也不知道为什么序列号变了要重建滤镜。\n4.\n\n这3种情况，`ffplay`都会处理，只要解码出来的 `AVFrame` 跟入口滤镜的格式不一致，都会重建滤镜，把入口滤镜的格式设置为当前的 `AVFrame`的格式，这样滤镜处理才不会出错。\n\n> 补充：last_serial 变量一开始是 -1，而 is->auddec.pkt_serial 一开始是 0，所以一开始是必然会执行一次 reconfigure 操作。\n\n由于每次读取出口滤镜的数据，都会用 while 循环把缓存刷完，不会留数据在滤镜容器里面，所以重建滤镜不会导致音频数据丢失。我圈一下代码里面的重点，如下：\n\n``` cpp\n      while ((ret = av_buffersink_get_frame_flags(is->out_audio_filter, frame, 0)) >= 0) {\n          tb = av_buffersink_get_time_base(is->out_audio_filter);\n#endif\n          if (!(af = frame_queue_peek_writable(&is->sampq)))\n              goto the_end;\n\n          af->pts = (frame->pts == AV_NOPTS_VALUE) ? NAN : frame->pts * av_q2d(tb);\n          af->pos = frame->pkt_pos;\n          af->serial = is->auddec.pkt_serial;\n          af->duration = av_q2d((AVRational){frame->nb_samples, frame->sample_rate});\n\n          av_frame_move_ref(af->frame, frame);\n          frame_queue_push(&is->sampq);\n\n#if CONFIG_AVFILTER\n          if (is->audioq.serial != is->auddec.pkt_serial)\n              break;\n      }\n```\n\n---\n\naudio_thread 线程的逻辑比较简单，复杂的地方都封装在它调用的子函数里面，所以本文简单讲解一下，audio_thread() 里面调用的各个函数的作用。\n\n1. decoder_decode_frame()，从 PacketQueue 里面解码出来 AVFrame，此函数会阻塞，直到解码出来 AVFrame，或者返回错误。这个函数有 3 个返回值。\n\n   * 返回 1，获取到 AVFrame 。\n   * 返回 0 ，获取不到 AVFrame ，0 代表已经解码完MP4的所有AVPacket。这种情况一般是 ffplay 播放完了整个 MP4 文件，窗口画面停在最后一帧。但是由于你可以按 C 键重新循环播放，所以即便返回 0 也不能退出 audio_thread 线程。\n   * 返回 -1，代表 PacketQueue 队列关闭了（abort_request）。返回 -1 会导致 audio_thread() 函数用 goto the_end 跳出 do{}whlle{} 循环，跳出循环之后，audio_thread 线程就会自己结束了。返回 -1 通常是因为关闭了 ffplay 播放器。\n  \n2. configure_audio_filters()，创建音频滤镜函数，之前已经讲过此函数。\n\n3. av_buffersrc_add_frame()，往入口滤镜发送 AVFrame。\n\n4. av_buffersink_get_frame_flags()，从出口滤镜读取 AVFrame。\n\n5. frame_queue_peek_writable()，从 FrameQueue 里面取一个可以写的 Frame 出来。此函数也可能会阻塞。\n\n6. frame_queue_push()，这个函数有点奇怪，他其实不是把之前的 Frame 塞进去队列，而是把队列的写索引值 +1。\n    todo\n\n---\n\naudio_thread() 函数最后还有一个重点，就是当 出口滤镜 结束的时候，finished 就会设置为 非 0 。\n\n``` cpp\nif (ret == AVERROR_EOF)\n    is->auddec.finished = is->auddec.pkt_serial;\n```\n\n提示：只有往入口滤镜发送了 NULL 的 AVFrame ，出口滤镜才会结束。读完数据 跟 结束是两种状态，读完代表滤镜暂时没有数据可读，但是只要再往入口滤镜 发 AVFrame，出口滤镜就会又有数据可读。\n而结束，代表不会再有 AVFrame 往入口滤镜发。\n","tags":["FFplay源码分析"]},{"title":"FFplay源码分析---audio_open()","url":"/2023/12/11/FFmpeg/ffplay源码分析/audio-open/","content":"\n## audio_open()\n\naudio_open() 的作用，就如同它的名字那样，就是打开音频设备。流程图如下：\n    ![Alt text](../../../images/FFmpeg/ffplay源码分析/audio_open流程.png)\n\nSDL 库播放音频数据有两种方式。\n\n1，调用层定时往 SDL 接口塞数据。\n\n2，设置SDL回调函数，让 SDL 来主动执行回调函数来取数据。\n\n第二种方式的实时性更好，ffplay 也是用的第二种。\n\n``` cpp\nstatic int audio_open(void *opaque, int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate, struct AudioParams *audio_hw_params)\n```\n\n函数参数:\n\n1. void *opaque，传递给 SDL 回调函数的参数。\n\n2. wanted_channel_layout，wanted_nb_channels，wanted_sample_rate，希望用 这样的采样率，声道数，声道布局打开音频硬件设备。\n\n3. struct AudioParams *audio_hw_params，实际打开的音频硬件设备的音频格式信息。这里的 hw 是 Hardware 的意思，也就是硬件，不过不是指硬件编解码加速，而是指打开的硬件设备。\n\n这些参数是这样的，想要的音频格式 跟 实际打开的音频格式 不一定一样，例如，MP4 里面的音频流是 48000 采样的，肯定想要用 48000 的格式打开音响设备，这样才能听到最好的音质。但是难免有些音响设备太差，只支持 44100。\n\n### audio_open()分析\n\n``` cpp\nstatic int audio_open(void *opaque, int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate, struct AudioParams *audio_hw_params)\n{\n    SDL_AudioSpec wanted_spec, spec;\n    const char *env;\n    // 这 其实是一个map表，声道切换映射表。\n    // 如果音响设备不支持 7 声道的数据播放，肯定不能直接报错，还要尝试一下其他声道能不能成功打开设备吧。这个其他声道就是 next_nb_channels[]。\n    // next_nb_channels[7] = 6，从7声道切换到6声道打开音频设备\n    // next_nb_channels[6] = 4，从6声道切换到4声道打开音频设备\n    // next_nb_channels[5] = 6，从5声道切换到6声道打开音频设备\n    // next_nb_channels[4] = 2，从4声道切换到2声道打开音频设备\n    // next_nb_channels[3] = 6，从3声道切换到6声道打开音频设备\n    // next_nb_channels[2] = 1，从双声道切换到单声道打开音频设备\n    // next_nb_channels[1] = 0，单声道都打不开音频设备，无法再切换，需要降低采样率播放。\n    // next_nb_channels[0] = 0，0声道都打不开音频设备，无法再切换，需要降低采样率播放\n    static const int next_nb_channels[] = {0, 0, 1, 6, 2, 6, 4, 6};\n    // next_sample_rates[] 存储的仅仅是采样率，当切换所有声道都无法成功打开音频设备，就需要从 next_sample_rates[] 取一个比当前更小的采样率来尝试。\n    static const int next_sample_rates[] = {0, 44100, 48000, 96000, 192000};\n    int next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - 1;\n\n    env = SDL_getenv(\"SDL_AUDIO_CHANNELS\");\n    if (env) {\n        wanted_nb_channels = atoi(env);\n        wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);\n    }\n    // 声道数，声道布局等参数的校验，ffplay 经常会校验 声道布局 跟 声道数是否一致，可能是担心用户在命令行输入错误的参数。\n    if (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) {\n        wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);\n        wanted_channel_layout &= ~AV_CH_LAYOUT_STEREO_DOWNMIX;\n    }\n    wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);\n\n    wanted_spec.channels = wanted_nb_channels;\n    wanted_spec.freq = wanted_sample_rate;\n    if (wanted_spec.freq <= 0 || wanted_spec.channels <= 0) {\n        av_log(NULL, AV_LOG_ERROR, \"Invalid sample rate or channel count!\\n\");\n        return -1;\n    }\n    // 注意一下 next_sample_rate_idx 变量，这个变量存的是比 想要打开的音频采样率 更小一点的采样率的索引。\n    while (next_sample_rate_idx && next_sample_rates[next_sample_rate_idx] >= wanted_spec.freq)\n        next_sample_rate_idx--;\n    // 设置打开参数，设置回调函数 ，如下：\n    // ffpaly 是写死了采样格式，写死成了 AUDIO_S16SYS 格式。也就是说，无论MP4里面的音频采样格式是 64 还是 32 位，还是其他，统统都会先提前转成 AUDIO_S16SYS，然后再丢给 SDL 播放。\n    wanted_spec.format = AUDIO_S16SYS;\n    wanted_spec.silence = 0;\n    // wanted_spec.samples 的作用是告诉 SDL 每次回调取多少样本数来播放，实际上就是控制 SDL 每秒调用回调函数的次数。\n    // 因为播放采样率是固定的，例如 48000。也就是音频设备每秒要播放 48000 个样本，如果调一次 sdl_audio_callback 只能取4800个样本，那他一秒内就需要调 10 次 sdl_audio_callback。\n    wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, 2 << av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));\n    wanted_spec.callback = sdl_audio_callback;\n    wanted_spec.userdata = opaque;\n    // 用 while 循环不断尝试各种 声道 跟 采样的组合来打开音频硬件设备，如下：\n    // SDL_OpenAudioDevice() 函数打开音频设备之后，回调函数是不会立即执行的，需要调 SDL_PauseAudioDevice() 来启动音频设备，这样回调函数才会执行。\n    while (!(audio_dev = SDL_OpenAudioDevice(NULL, 0, &wanted_spec, &spec, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_CHANNELS_CHANGE))) {\n        av_log(NULL, AV_LOG_WARNING, \"SDL_OpenAudio (%d channels, %d Hz): %s\\n\",\n               wanted_spec.channels, wanted_spec.freq, SDL_GetError());\n        // next_nb_channels[FFMIN(7, 7)] == next_nb_channels[7] = 6\n        // 可以看到，如果 7 声道打开失败，就会切换成 6 声道进行尝试，跟上面说的那个映射是一致的。\n        wanted_spec.channels = next_nb_channels[FFMIN(7, wanted_spec.channels)];\n        if (!wanted_spec.channels) {\n        // 而 next_sample_rates[next_sample_rate_idx--] 就是进行降低采样率，再尝试打开音频设备，之前说过，next_sample_rate_idx 是比 想要的采样率更小一点的值。\n            wanted_spec.freq = next_sample_rates[next_sample_rate_idx--];\n            wanted_spec.channels = wanted_nb_channels;\n            if (!wanted_spec.freq) {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"No more combinations to try, audio open failed\\n\");\n                return -1;\n            }\n        }\n        wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);\n    }\n    if (spec.format != AUDIO_S16SYS) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"SDL advised audio format %d is not supported!\\n\", spec.format);\n        return -1;\n    }\n    if (spec.channels != wanted_spec.channels) {\n        wanted_channel_layout = av_get_default_channel_layout(spec.channels);\n        if (!wanted_channel_layout) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"SDL advised channel count %d is not supported!\\n\", spec.channels);\n            return -1;\n        }\n    }\n    // 打开硬件设备成功之后，要记录一下是以什么样的采样率，声道数等等格式打开硬件设备的。\n    // 当 AVFrame 与 硬件音频格式不一致时候需要进行转换。\n    audio_hw_params->fmt = AV_SAMPLE_FMT_S16;\n    audio_hw_params->freq = spec.freq;\n    audio_hw_params->channel_layout = wanted_channel_layout;\n    audio_hw_params->channels =  spec.channels;\n    // 一个音频样本占多少内存。\n    audio_hw_params->frame_size = av_samples_get_buffer_size(NULL, audio_hw_params->channels, 1, audio_hw_params->fmt, 1);\n    // audio_hw_params->freq 数量的音频样本占多少内存。也就是一秒钟要播放多少内存的音频数据。\n    audio_hw_params->bytes_per_sec = av_samples_get_buffer_size(NULL, audio_hw_params->channels, audio_hw_params->freq, audio_hw_params->fmt, 1);\n    if (audio_hw_params->bytes_per_sec <= 0 || audio_hw_params->frame_size <= 0) {\n        av_log(NULL, AV_LOG_ERROR, \"av_samples_get_buffer_size failed\\n\");\n        return -1;\n    }\n    return spec.size;\n}\n```\n\n`wanted_spec.samples` 的计算方式有点难懂，如下：\n\n```cpp\nwanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, 2 << av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));\n```\n\n首先，SDL_AUDIO_MIN_BUFFER_SIZE 宏是 512，所以最小值是 512。但是 后面的用 av_log2 取指数，又 << 位移，是干什么呢？\n\n答：wanted_spec.freq 是采样率，而 SDL_AUDIO_MAX_CALLBACKS_PER_SEC 代表 SDL 每秒调多少次回调函数。两者相除就能得出每次回调需要读取多少个样本数。这个逻辑非常容易理解。\n\nav_log2() 函数是求对数，也就是 2 乘以 自身多少次等于括号里面的结果，这个多少次会进行取整操作的，av_log2() 不会返回小数。\n\n然后 2 << 位移只是想把 样本数数量 变成 2 的指数。\n\n### spec.size\n\n我们可以看一些，SDL 头文件对这个 spec.size 的定义，如下\n\n``` cpp\n    typedef struct SDL_AudioSpec\n    {\n        int freq;                   /**< DSP frequency -- samples per second */\n        SDL_AudioFormat format;     /**< Audio data format */\n        Uint8 channels;             /**< Number of channels: 1 mono, 2 stereo */\n        Uint8 silence;              /**< Audio buffer silence value (calculated) */\n        Uint16 samples;             /**< Audio buffer size in sample FRAMES (total samples divided by channel count) */\n        Uint16 padding;             /**< Necessary for some compile environments */\n        Uint32 size;                /**< Audio buffer size in bytes (calculated) */\n        SDL_AudioCallback callback; /**< Callback that feeds the audio device (NULL to use SDL_QueueAudio()). */\n        void *userdata;             /**< Userdata passed to callback (ignored for NULL callbacks). */\n    } SDL_AudioSpec;\n```\n\n`Audio buffer size in bytes` 指的是 SDL 内部音频数据缓存的大小，代表 SDL线程执行`sdl_audio_callback()` 的时候，SDL 硬件内部还有多少字节音频的数据没有播放。\n\n没错，SDL线程并不是没有音频数据可以播放了才调` sdl_audio_callback() `来拿数据，而是他内部还剩 `audio_hw_buf_size` 长度的数据就会调`sdl_audio_callback()` 来拿数据，是提前拿数据的。这个 概念 以及 `audio_hw_buf_size` 变量 都特别重要，后面会用到。`Audio buffer size in bytes`指的是 SDL 内部音频数据缓存的大小，代表 SDL线程执行 `sdl_audio_callback()`的时候，SDL 硬件内部还有多少字节音频的数据没有播放。\n\n没错，SDL线程并不是没有音频数据可以播放了才调`sdl_audio_callback()` 来拿数据，而是他内部还剩 `audio_hw_buf_size` 长度的数据就会调`sdl_audio_callback()`来拿数据，是提前拿数据的。这个 概念 以及 `audio_hw_buf_size` 变量 都特别重要，后面会用到。\n","tags":["FFplay源码分析"]},{"title":"FFplay源码分析---configure_audio_filters()","url":"/2023/12/10/FFmpeg/ffplay源码分析/configure-audio-filters/","content":"\n![Alt text](../../../images/FFmpeg/ffplay源码分析/configure_audio_filters.png)\n\n## configure_audio_filters()\n\n音频流的 滤镜是通过 configure_audio_filters() 函数来创建的，因为 ffplay 为了代码的通用性，即便命令行参数不使用滤镜，AVFrame 也会过一遍 空滤镜做下样子。\nconfigure_audio_filters() 函数的流程图如下：\n![Alt text](../../../images/FFmpeg/ffplay源码分析/configure_audio_filters流程图.png)\n\nconfigure_audio_filters() 函数的定义如下：\n\n``` cpp\nstatic int configure_audio_filters(VideoState *is, const char *afilters, int force_output_format){...}\n```\n\n函数的参数:\n\n* VideoState *is ，是 ffplay 播放器的全局管理器。\n\n* char *afilters，是滤镜字符串，例如 下面的命令：\n\n``` bash\nffplay -af \"atempo=2.0\" -i juren-5s.mp4\n```\n\n\"atempo=2.0\" 这个字符串就会赋值给 afilters 。\n\nint force_output_format ，代表是否强制把 buffersink 出口滤镜的音频帧采样等信息 设置为 跟 is->audio_tgt 一样。\n\n之前说过 is->audio_tgt 是音响硬件设备打开的信息。is->audio_tgt 是最终要传递给 SDL 的音频格式。所有的采样率，声道数等等最后都要转成 is->audio_tgt 。\n\n---\n\n这个函数一开始就定义了 一些只有 2 个元素的数组，这其实是 ffmpeg 项目传递参数的方式，传递一个数组进去函数，主要有两种方式。\n\n```cpp\n    int sample_rates[2] = { 0, -1 };\n    int64_t channel_layouts[2] = { 0, -1 };\n```\n\n1. 传递数组的大小。就是有多少个元素。\n2. 传递数组的结尾，只要读到结尾元素 (-1)，就算结束了。\n\nffmpeg 大部分函数采用的是第二种方式。\n\n``` cpp\nstatic int configure_audio_filters(VideoState *is, const char *afilters, int force_output_format)\n{\n    static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE };\n    int sample_rates[2] = { 0, -1 };\n    int64_t channel_layouts[2] = { 0, -1 };\n    int channels[2] = { 0, -1 };\n    AVFilterContext *filt_asrc = NULL, *filt_asink = NULL;\n    char aresample_swr_opts[512] = \"\";\n    AVDictionaryEntry *e = NULL;\n    char asrc_args[256];\n    int ret;\n\n    avfilter_graph_free(&is->agraph);\n    if (!(is->agraph = avfilter_graph_alloc()))\n        return AVERROR(ENOMEM);\n    is->agraph->nb_threads = filter_nbthreads;\n\n    while ((e = av_dict_get(swr_opts, \"\", e, AV_DICT_IGNORE_SUFFIX)))\n        av_strlcatf(aresample_swr_opts, sizeof(aresample_swr_opts), \"%s=%s:\", e->key, e->value);\n    if (strlen(aresample_swr_opts))\n        aresample_swr_opts[strlen(aresample_swr_opts)-1] = '\\0';\n    av_opt_set(is->agraph, \"aresample_swr_opts\", aresample_swr_opts, 0);\n\n    ret = snprintf(asrc_args, sizeof(asrc_args),\n                   \"sample_rate=%d:sample_fmt=%s:channels=%d:time_base=%d/%d\",\n                   is->audio_filter_src.freq, av_get_sample_fmt_name(is->audio_filter_src.fmt),\n                   is->audio_filter_src.channels,\n                   1, is->audio_filter_src.freq);\n    if (is->audio_filter_src.channel_layout)\n        snprintf(asrc_args + ret, sizeof(asrc_args) - ret,\n                 \":channel_layout=0x%\"PRIx64,  is->audio_filter_src.channel_layout);\n\n    ret = avfilter_graph_create_filter(&filt_asrc,\n                                       avfilter_get_by_name(\"abuffer\"), \"ffplay_abuffer\",\n                                       asrc_args, NULL, is->agraph);\n    if (ret < 0)\n        goto end;\n\n\n    ret = avfilter_graph_create_filter(&filt_asink,\n                                       avfilter_get_by_name(\"abuffersink\"), \"ffplay_abuffersink\",\n                                       NULL, NULL, is->agraph);\n    if (ret < 0)\n        goto end;\n\n    if ((ret = av_opt_set_int_list(filt_asink, \"sample_fmts\", sample_fmts,  AV_SAMPLE_FMT_NONE, AV_OPT_SEARCH_CHILDREN)) < 0)\n        goto end;\n    if ((ret = av_opt_set_int(filt_asink, \"all_channel_counts\", 1, AV_OPT_SEARCH_CHILDREN)) < 0)\n        goto end;\n\n    if (force_output_format) {\n        channel_layouts[0] = is->audio_tgt.channel_layout;\n        channels       [0] = is->audio_tgt.channel_layout ? -1 : is->audio_tgt.channels;\n        sample_rates   [0] = is->audio_tgt.freq;\n        if ((ret = av_opt_set_int(filt_asink, \"all_channel_counts\", 0, AV_OPT_SEARCH_CHILDREN)) < 0)\n            goto end;\n        if ((ret = av_opt_set_int_list(filt_asink, \"channel_layouts\", channel_layouts,  -1, AV_OPT_SEARCH_CHILDREN)) < 0)\n            goto end;\n        if ((ret = av_opt_set_int_list(filt_asink, \"channel_counts\" , channels       ,  -1, AV_OPT_SEARCH_CHILDREN)) < 0)\n            goto end;\n        if ((ret = av_opt_set_int_list(filt_asink, \"sample_rates\"   , sample_rates   ,  -1, AV_OPT_SEARCH_CHILDREN)) < 0)\n            goto end;\n    }\n\n\n    if ((ret = configure_filtergraph(is->agraph, afilters, filt_asrc, filt_asink)) < 0)\n        goto end;\n\n    is->in_audio_filter  = filt_asrc;\n    is->out_audio_filter = filt_asink;\n\nend:\n    if (ret < 0)\n        avfilter_graph_free(&is->agraph);\n    return ret;\n}\n\n```\n\n### avfilter_graph_free()\n\n`avfilter_graph_free()` 释放滤镜容器（FilterGraph），有些同学可能会疑惑，is->agraph 一开始不是 NULL 吗？ 为什么需要释放？\n\n`is->agraph` 一开始确实是 `NULL`，但是 `configure_audio_filters()` 这个函数可能会调用第二次，第二次的时候 `is->agraph`就不是 `NULL`了。\n\nconfigure_audio_filters() 第一次调用是在 `stream_component_open()` 里面，如下：\n\n``` cpp\n#if CONFIG_AVFILTER\n        {\n            AVFilterContext *sink;\n            // 从解码器出来的音频信息\n            is->audio_filter_src.freq           = avctx->sample_rate;\n            is->audio_filter_src.channels       = avctx->channels;\n            is->audio_filter_src.channel_layout = get_valid_channel_layout(avctx->channel_layout, avctx->channels);\n            is->audio_filter_src.fmt            = avctx->sample_fmt;\n            // 创建音频流的滤镜。\n            if ((ret = configure_audio_filters(is, afilters, 0)) < 0)\n                goto fail;\n            sink = is->out_audio_filter;\n            sample_rate    = av_buffersink_get_sample_rate(sink);\n            nb_channels    = av_buffersink_get_channels(sink);\n            channel_layout = av_buffersink_get_channel_layout(sink);\n        }\n```\n\n第二次调用是在 `audio_thread()` 里面，如下：\n\n``` cpp\n...\n    if (reconfigure) {\n        char buf1[1024], buf2[1024];\n        av_get_channel_layout_string(buf1, sizeof(buf1), -1, is->audio_filter_src.channel_layout);\n        av_get_channel_layout_string(buf2, sizeof(buf2), -1, dec_channel_layout);\n        av_log(NULL, AV_LOG_DEBUG,\n               \"Audio frame changed from rate:%d ch:%d fmt:%s layout:%s serial:%d to rate:%d ch:%d fmt:%s layout:%s serial:%d\\n\",\n               is->audio_filter_src.freq, is->audio_filter_src.channels, av_get_sample_fmt_name(is->audio_filter_src.fmt), buf1, last_serial,\n               frame->sample_rate, frame->channels, av_get_sample_fmt_name(frame->format), buf2, is->auddec.pkt_serial);\n\n        is->audio_filter_src.fmt            = frame->format;\n        is->audio_filter_src.channels       = frame->channels;\n        is->audio_filter_src.channel_layout = dec_channel_layout;\n        is->audio_filter_src.freq           = frame->sample_rate;\n        last_serial                         = is->auddec.pkt_serial;\n        // 这里 \n        if ((ret = configure_audio_filters(is, afilters, 1)) < 0)\n            goto the_end;\n    }\n...\n```\n\n第二次调用 configure_audio_filters() 是因为实际解码出来的 AVFrame 的采样率，声道等，跟容器里面记录的不一致，之前 is->audio_filter_src 是直接从容器，封装层取的数据。封装层记录的音频采样率等，可能是错的，需要以实际解码出来的 AVFrame 为准。\n\n而且，注意，第二次的时候，force_output_format 参数会置为 1，这样会强制 buffersink 出口滤镜的采样信息等 设置为 is->audio_tgt 一样。\n\n其实configure_audio_filters() 必然会调第二次的，因为 is->auddec.pkt_serial != last_serial 这个条件肯定是真。\n\n### filter_nbthreads\n\n``` cpp\nis->agraph->nb_threads = filter_nbthreads;\n```\n\n接着就是设置 滤镜使用的线程数量，0 为自动选择线程数量，如下：\n\n### aresample_swr_opts\n\n设置重采样选项（aresample_swr_opts），如下：\n\n```cpp\n    av_opt_set(is->agraph, \"aresample_swr_opts\", aresample_swr_opts, 0);\n```\n\n什么样的命令行参数才是重采样选项的，在`libswresample/options.c` 里面可以找到，如下：\n\n举个例子，如下：\n\n```bash\nffpaly -ich 1 -i juren-5s.mp4\n```\n\nich 1 就会被解析拷贝进去 `ffplay.c`里面的 `swr_opts` 变量里面。\n\n这里还用到了一个新的函数`av_opt_set()`，这个函数其实不只可以设置滤镜的属性字段，还可以设置大多数数据结构的属性字段，例如解码器，封装器 等等，只要内部有 AVClass 的数据结构，都能用 `av_opt_set()` 来设置属性，todo   av_opt_set\n\n### avfilter_graph_create_filter()\n\n出口滤镜还设置了 sample_fmts 为 AV_SAMPLE_FMT_S16，这是 ffpaly 播放器自己的特性，就是说无论MP4文件里面的音频格式是怎样的，他都会转成 AV_SAMPLE_FMT_S16 格式丢给 SDL 播放，而且它在用 SDL_OpenAudioDevice 打开音频设备的时候，就是用的 S16 格式，这是写死的。\n\n```cpp\n    // 入口滤镜\n    ret = avfilter_graph_create_filter(&filt_asrc,\n                                       avfilter_get_by_name(\"abuffer\"), \"ffplay_abuffer\",\n                                       asrc_args, NULL, is->agraph);\n    if (ret < 0)\n        goto end;\n\n    // 出口滤镜\n    ret = avfilter_graph_create_filter(&filt_asink,\n                                       avfilter_get_by_name(\"abuffersink\"), \"ffplay_abuffersink\",\n                                       NULL, NULL, is->agraph);\n```\n\n### force_output_format()\n\nforce_output_format 的逻辑主要是 强制 buffersink 出口滤镜的采样信息等 设置为跟 is->audio_tgt 一样。audio_tgt 是 SDL 接受音频帧的最终格式。\n\n第一次调用 configure_audio_filters() 函数，force_output_format 为 0，不会跑进去这块逻辑。\n\n### configure_filtergraph()\n\n调 configure_filtergraph() 函数来链接入口跟出口滤镜，同时创建滤镜容器（FilterGraph），如下：\n\n```cpp\n\n    if ((ret = configure_filtergraph(is->agraph, afilters, filt_asrc, filt_asink)) < 0)\n        goto end;\n    // 入口与出口滤镜，赋值到全局管理器\n    is->in_audio_filter  = filt_asrc;\n    is->out_audio_filter = filt_asink;\n```\n\n重要的是，入口滤镜 跟 出口滤镜 被赋值到全局管理器 is 了。后面只要把解码器输出的 AVFrame 往入口滤镜丢，然后往出口滤镜读就行了。\n\n> todo configure_filtergraph()\n","tags":["FFplay源码分析"]},{"title":"vscode配置","url":"/2023/12/10/vscode配置/vscode配置/","content":"\n# vscode 设置\n\n**Ctrl + , 进入设置**\n\n## 搜索brack\n\n![Alt text](../../images/vscode/assets/brack.png)\n\n1. 第一个使得括号有颜色。\n2. 第二个可以看到括号之间的内容区间。如下图所示\n![Alt text](../../images/vscode/assets/brack_pairs.png)\n\n## 搜索smooth\n\n![Alt text](../../images/vscode/assets/smooth.png)\n\n前面的四个选项，全部打开，或感觉到屏幕滑动,和光标的移动更加的顺滑。\n\n最先下面的选项，选择smooth，则会发现光标的闪烁变了。\n\n## 搜索preview\n\n![Alt text](../../images/vscode/assets/preview.png)\n将图中选中的选项打开，会出现预览的效果，类似zsh-autosuggestions插件\n\n## 搜索code lens\n\n![Alt text](../../images/vscode/assets/code%20lens.png)\n关闭下面的两个选项\n\n## 设置切换终端的快捷键\n\n`ctrl+shift+p` 进入命令面板，搜索keyboard。选择图片中高亮的选项。\n\n![Alt text](../../images/vscode/assets/Shortcuts.png)\n\n打开 `keybindings.json`,进行编辑。\n\n再此文件中添加如下内容.\n\n```json\n// 将键绑定放入此文件中以覆盖默认值\n[\n    {\n        \"key\": \"ctrl+tab\",\n        \"command\": \"workbench.action.terminal.focusNext\", // 切换到下一个终端 \n        \"when\": \"terminalFocus\"\n    },\n    {\n        \"key\": \"ctrl+w\",\n        \"command\": \"workbench.action.terminal.kill\", // 关闭当前终端\n        \"when\": \"terminalFocus\"\n    },\n    {\n        \"key\": \"ctrl+t\",\n        \"command\": \"workbench.action.terminal.new\", // 打开新的终端\n        \"when\": \"terminalFocus\"\n    },\n    {\n        \"key\": \"ctrl+1\",\n        \"command\": \"workbench.action.terminal.focusAtIndex1\", // 打开终端1\n        \"when\": \"terminalFocus\"\n    },\n    {\n        \"key\": \"ctrl+2\",\n        \"command\": \"workbench.action.terminal.focusAtIndex2\",\n        \"when\": \"terminalFocus\"\n    },\n    {\n        \"key\": \"ctrl+3\",\n        \"command\": \"workbench.action.terminal.focusAtIndex3\",\n        \"when\": \"terminalFocus\"\n    },\n    {\n        \"key\": \"ctrl+4\",\n        \"command\": \"workbench.action.terminal.focusAtIndex4\",\n        \"when\": \"terminalFocus\"\n    }\n]\n```\n\n## 设置 Tab 尺寸的默认值\n\nCtrl+ , 进入设置界面，搜索 Tab Size 设置为 2\n","tags":["vscode"]},{"title":"FFplay源码分析---stream_component_open()","url":"/2023/12/10/FFmpeg/ffplay源码分析/stream-component-open/","content":"\n![Alt text](../../../images/FFmpeg/ffplay源码分析/stream_conponent_open结构.png)\n\n## stream_component_open()\n\nstream_component_open() 函数主要作用是打开 音频流或者视频流 对应的解码器，开启解码线程去解码。\n\n流程图如下：\n![Alt text](../../../images/FFmpeg/ffplay源码分析/stream_component_open流程图.png)\nstream_component_open() 的函数定义如下：\n\n可以看到，函数的参数非常简单，第一个参数是 VideoState *is 全局管理器，第二个参数 stream_index 是 数据流 的索引值。\n\n``` cpp\n/* open a given stream. Return 0 if OK */\nstatic int stream_component_open(VideoState *is, int stream_index)\n```\n\n### avcodec_alloc_context3, avcodec_parameters_to_context\n\navcodec_alloc_context3() 跟 avcodec_parameters_to_context() ，这可以说是常规操作了，就是申请一个解码器实例的内存，然后把容器流里面的信息拷贝过去。容器里面通常都是有编码器信息的。\n\n```  cpp\n/* open a given stream. Return 0 if OK */\nstatic int stream_component_open(VideoState *is, int stream_index)\n{\n    AVFormatContext *ic = is->ic;\n    AVCodecContext *avctx;\n    const AVCodec *codec;\n    const char *forced_codec_name = NULL;\n    AVDictionary *opts = NULL;\n    AVDictionaryEntry *t = NULL;\n    int sample_rate, nb_channels;\n    int64_t channel_layout;\n    int ret = 0;\n    int stream_lowres = lowres;\n\n    if (stream_index < 0 || stream_index >= ic->nb_streams)\n        return -1;\n\n    avctx = avcodec_alloc_context3(NULL);\n    if (!avctx)\n        return AVERROR(ENOMEM);\n\n    ret = avcodec_parameters_to_context(avctx, ic->streams[stream_index]->codecpar);\n    if (ret < 0)\n        goto fail;\n    avctx->pkt_timebase = ic->streams[stream_index]->time_base;\n\n    codec = avcodec_find_decoder(avctx->codec_id);\n    ...\n}\n```\n\n### avcodec_find_decoder\n\n用于查找解码器。\n\n在音视频处理中，编码器将原始音视频数据转换为压缩格式，而解码器则将压缩格式的音视频数据解码为原始格式。avcodec_find_decoder函数的作用就是根据输入的音视频编码格式，查找对应的解码器。\n\n``` cpp\nAVCodec* avcodec_find_decoder(enum AVCodecID id);\n```\n\n参数id是一个枚举类型AVCodecID的值，用于指定所需解码器的编码格式。可以通过该枚举类型选择常见的音视频编码格式，如H.264（AV_CODEC_ID_H264）、AAC（AV_CODEC_ID_AAC）等。\n\n函数返回一个指向AVCodec结构体的指针，该结构体描述了找到的解码器的属性和功能。如果找不到对应的解码器，返回值将为NULL。\n\n### 指定的编码器\n\n例如你不用想 libx264 编码器，而是使用 openh264 编码器，就可以用 -c:v openh264 参数指定编码器。如下：\n\n```bash\nffplay -c:v openh264 juren.mp4\n```\n\n也有另一种情况，就是容器里面记录的编码器信息是错误的，而你又知道正确的编码器信息，就可以强制指定。命令行的参数会赋值给 forced_codec_name 变量。\n\n``` cpp\n    codec = avcodec_find_decoder(avctx->codec_id);\n\n    switch(avctx->codec_type){\n        case AVMEDIA_TYPE_AUDIO   : is->last_audio_stream    = stream_index; forced_codec_name =    audio_codec_name; break;\n        case AVMEDIA_TYPE_SUBTITLE: is->last_subtitle_stream = stream_index; forced_codec_name = subtitle_codec_name; break;\n        case AVMEDIA_TYPE_VIDEO   : is->last_video_stream    = stream_index; forced_codec_name =    video_codec_name; break;\n    }\n    if (forced_codec_name)\n        codec = avcodec_find_decoder_by_name(forced_codec_name);\n    if (!codec) {\n        if (forced_codec_name) av_log(NULL, AV_LOG_WARNING,\n                                      \"No codec could be found with name '%s'\\n\", forced_codec_name);\n        else                   av_log(NULL, AV_LOG_WARNING,\n                                      \"No decoder could be found for codec %s\\n\", avcodec_get_name(avctx->codec_id));\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n```\n\n### filter_codec_opts()和avcodec_open2()\n\n``` cpp\n    opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], codec);\n    if (!av_dict_get(opts, \"threads\", NULL, 0))\n        av_dict_set(&opts, \"threads\", \"auto\", 0);\n    if (stream_lowres)\n        av_dict_set_int(&opts, \"lowres\", stream_lowres, 0);\n    if ((ret = avcodec_open2(avctx, codec, &opts)) < 0) {\n        goto fail;\n    }\n    if ((t = av_dict_get(opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n        ret =  AVERROR_OPTION_NOT_FOUND;\n        goto fail;\n    }\n```\n\nfilter_codec_opts() 这个函数实际上就是把命令行参数的相关参数提取出来。举个例子:\n\n``` bash\nffpaly -b:v 2000k -i juren-5s.mp4\n```\n\n上面的命令，指定了解码器的码率，但是他指定的是视频的码率，当 stream_component_open() 打开视频流的时候，这个 码率参数才会被 filter_codec_opts() 提取出来。\n\n而stream_component_open() 打开音频流的时候，b:v 不会被提取出来，因为这个参数是跟 视频流 相关的。\n\n所以你可以把 filter_codec_opts() 看成是一个处理命令行参数的函数，提取相关的参数。至于什么是相关，可以自行看这个函数的内部实现。\n\navcodec_open2() 就会接受 filter_codec_opts() 返回 的 AVDictionary 参数。\n\n> 至此，解码器参数已经设置完毕，解码器也已经打开了了。\n---\n\n### AVDISCARD_DEFAULT\n\n把流属性设置为不丢弃， 就是下面这一句代码。\n\n```cpp\n    ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;\n```\n\n可以看到，stream_component_open() 函数会把打开的流的 discard 设置为 AVDISCARD_DEFAULT，这样这个流的数据就可以从 av_read_frame() 函数里面读出来了。\n\n注意，ffplay.c 之前 在 read_thread() 函数里面，是把所有的流都设置为了 AVDISCARD_ALL，也就是会丢弃所有流的数据包。如下所示:\n\n``` cpp\nfor (i = 0; i < ic->nb_streams; i++) {\n    AVStream *st = ic->streams[i];\n    enum AVMediaType type = st->codecpar->codec_type;\n    st->discard = AVDISCARD_ALL;\n    if (type >= 0 && wanted_stream_spec[type] && st_index[type] == -1)\n        if (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) > 0)\n            st_index[type] = i;\n}\n```\n\n所以，如果 mp4 里面有多个视频流，av_read_frame() 只会读取最好的那个视频流的包，音频流同理。\n\n### switch case\n\n这里分别对 音频，视频，字幕做了区别处理。如下所示:\n\n首先可以看到，他有一个宏判断，大部分情况 AVFILTER 滤镜模块都是启用，所以不用管第二个 else。这里需要注意一下，虽然 ffplay -i juren-5s.mp4 这条命令没有使用滤镜，但是 ffplay 的逻辑还是会创建滤镜实例的，只不过这是一个空的实例。这样做是为了代码逻辑更加通用。\n\n无论命令行参数使不使用滤镜，他都是同样的逻辑。\n\n注意下面代码中的`is->audio_filter_src` 变量，这个变量存储的实际上是从解码器出来的音频信息。然后调 `configure_audio_filters()` 这个函数来创建音频流的滤镜。\n\n``` cpp\n    switch (avctx->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n#if CONFIG_AVFILTER\n        {\n            AVFilterContext *sink;\n            // 从解码器出来的音频信息\n            is->audio_filter_src.freq           = avctx->sample_rate;\n            is->audio_filter_src.channels       = avctx->channels;\n            is->audio_filter_src.channel_layout = get_valid_channel_layout(avctx->channel_layout, avctx->channels);\n            is->audio_filter_src.fmt            = avctx->sample_fmt;\n            if ((ret = configure_audio_filters(is, afilters, 0)) < 0)\n                goto fail;\n            sink = is->out_audio_filter;\n            sample_rate    = av_buffersink_get_sample_rate(sink);\n            nb_channels    = av_buffersink_get_channels(sink);\n            channel_layout = av_buffersink_get_channel_layout(sink);\n        }\n#else\n        sample_rate    = avctx->sample_rate;\n        nb_channels    = avctx->channels;\n        channel_layout = avctx->channel_layout;\n#endif\n\n        /* prepare audio output */\n        if ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &is->audio_tgt)) < 0)\n            goto fail;\n        is->audio_hw_buf_size = ret;\n        is->audio_src = is->audio_tgt;\n        is->audio_buf_size  = 0;\n        is->audio_buf_index = 0;\n\n        /* init averaging filter */\n        is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);\n        is->audio_diff_avg_count = 0;\n        /* since we do not have a precise anough audio FIFO fullness,\n           we correct audio sync only if larger than this threshold */\n        is->audio_diff_threshold = (double)(is->audio_hw_buf_size) / is->audio_tgt.bytes_per_sec;\n\n        is->audio_stream = stream_index;\n        is->audio_st = ic->streams[stream_index];\n\n        if ((ret = decoder_init(&is->auddec, avctx, &is->audioq, is->continue_read_thread)) < 0)\n            goto fail;\n        if ((is->ic->iformat->flags & (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) && !is->ic->iformat->read_seek) {\n            is->auddec.start_pts = is->audio_st->start_time;\n            is->auddec.start_pts_tb = is->audio_st->time_base;\n        }\n        if ((ret = decoder_start(&is->auddec, audio_thread, \"audio_decoder\", is)) < 0)\n            goto out;\n        SDL_PauseAudioDevice(audio_dev, 0);\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        is->video_stream = stream_index;\n        is->video_st = ic->streams[stream_index];\n\n        if ((ret = decoder_init(&is->viddec, avctx, &is->videoq, is->continue_read_thread)) < 0)\n            goto fail;\n        if ((ret = decoder_start(&is->viddec, video_thread, \"video_decoder\", is)) < 0)\n            goto out;\n        is->queue_attachments_req = 1;\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        is->subtitle_stream = stream_index;\n        is->subtitle_st = ic->streams[stream_index];\n\n        if ((ret = decoder_init(&is->subdec, avctx, &is->subtitleq, is->continue_read_thread)) < 0)\n            goto fail;\n        if ((ret = decoder_start(&is->subdec, subtitle_thread, \"subtitle_decoder\", is)) < 0)\n            goto out;\n        break;\n    default:\n        break;\n    }\n```\n\n### configure_audio_filters()\n\nconfigure_audio_filters() 函数最重要的地方就是搞好了 is->in_audio_filter 跟 is->out_audio_filter 两个滤镜。解码器输出 AVFrame 之后需要往 in_audio_filter 里面丢，然后播放的时候，需要从 out_audio_filter 读取 AVFrame。\n\nav_buffersink_get_sample_rate() 等函数的调用实际上就是从 buffsink 出口滤镜里面获取到最后的音频信息。\n\n> todo configure_audio_filters() 函数的分析\n\n### audio_open()\n\naudio_open() 函数的内部逻辑就是调 SDL_OpenAudioDevice() 打开音频设备，不过由于音频设备各种各样，从 buffersink 滤镜出来的音频帧，不一定被硬件设备支持，所以可能需要降低采样率之类。例如：有些比较差的音响不支持太高采样或者太多的声道数。\n\naudio_open() 函数会选出被硬件设备支持的采样率，声道数 去打开。这些最终的声道数，采样率等信息，就放在 is->audio_tgt 变量返回。\n\n所以 audio_open() 函数的重点是，打开音频设备，并且把最终的音频信息放在 is->audio_tgt 变量里面了。\n\n> todo audio_open函数分析\n\n下面代码，其中的变量 是用在音频向视频同步的场景上的，非常难懂，而且应用场景极少。**通常音视频同步都是以音频时钟为准**。所以这段代码可以暂时不管。 todo\n\n``` cpp\n    /* init averaging filter */\n    is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);\n    is->audio_diff_avg_count = 0;\n    /* since we do not have a precise anough audio FIFO fullness,\n        we correct audio sync only if larger than this threshold */\n    is->audio_diff_threshold = (double)(is->audio_hw_buf_size) / is->audio_tgt.bytes_per_sec;\n```\n\n### audio_tgt 和 audio_src\n\n如下:\n\n``` cpp\nis->audio_src = is->audio_tgt;\n```\n\n这句代码看起来会有点莫名其妙，为什么把 audio_tgt 赋值给 audio_src 呢？\n\n首先 is->audio_src 是一个 struct AudioParams ，一个存储音频格式信息的结构体。变量名里有个 src ，代表音频的源头，也就是音频源头的格式是怎样的。但是注意这个源头不是指 MP4 文件里面的音频格式，虽然这个也是源头。\n\n但是它的 src 指的是 is->swr_ctx 重采样实例的源头，也就是当需要进行重采样的时候，要输入给 is->swr_ctx 的原始音频格式就是 is->audio_src。流程图如下：\n\n![Alt text](../../../images/FFmpeg/ffplay源码分析/audio_src.png)\n\n上面的流程图，如果去掉重采样，是不是就直接是 is->audio_src = is->audio_tgt; 了？\n\n因此 is->audio_src 存储的其实是 buffersink 出口滤镜的音频格式，但是因为出口滤镜的音频格式可能跟 is->audio_tgt 本身是一样的，所以它上面那句代码就这样写了。\n\nbuffersink 跟 audio_tgt 音频格式不一样，就需要重采样。从重采样实例 is->swr_ctx 角度来看， is->audio_src 确实是源头。只是他的代码取巧了一下。\n\n> todo audio_decode_frame()函数中的重采样代码\n\n**小总结：ffplay 有两个处理音频的地方，一个是 滤镜（is->agraph），一个是重采样（is->swr_ctx）。**\n\n最后，就是记录播放的音频流信息，其他的视频流，字幕流也有类似的操作，如下：\n\n```cpp\n    is->audio_stream = stream_index;\n    is->audio_st = ic->streams[stream_index];\n```\n\n### decoder_init()\n\n`decoder_init()` 函数是比较简单的，不过它用了一个新的数据结构 `struct Decoder`，所以我们先讲一下这个结构，如下：\n\n```cpp\ntypedef struct Decoder {\n    AVPacket *pkt; //要进行解码的 AVPacket，也是要发送给解码器的 AVPacket\n    PacketQueue *queue; // AVPacket 队列\n    AVCodecContext *avctx; //解码器实例\n    int pkt_serial; //序列号\n    int finished; //已完成的时候，finished 等于上面的 pkt_serial。当 buffersink 输出 EOF 的时候就是已完成。\n    int packet_pending; //代表上一个 AVPacket 已经从队列取出来了，但是未发送成功给解码器。未发生成功的会保留在第一个字段 pkt 里面，下次会直接发送，不从队列取。\n    SDL_cond *empty_queue_cond; //条件变量，AVPacket 队列已经没有数据的时候会激活这个条件变量。\n    int64_t start_pts; //流的第一帧的pts\n    AVRational start_pts_tb; //流的第一帧的pts的时间基\n    int64_t next_pts; //下一帧的pts，只有音频用到这个 next_pts 字段\n    AVRational next_pts_tb; //下一帧的pts的时间基\n    SDL_Thread *decoder_tid; //解码线程 ID。\n} Decoder;\n```\n\n首先是第一个 AVPacket *pkt ，这个实际上就是从 AVPacket 队列拿出来的。然后把这个 pkt 发送给解码器，如果发送成功，那当然是 unref 这个 pkt，但是如果发送给解码器失败，就会把 packet_pending 置为1，pkt 不进行 unref，下次再继续发送。\n\n> pkt_serial 这个序列号， todo FFplay序列号分析。\n\n还有一个需要讲解的是 next_pts 字段，一些读者可能会疑惑，不是每一个 AVFrame 都有 pts 的吗？ 为什么还需要这个 next_pts 这个字段？\n\n这就是因为解码出来的 AVFrame 的 pts 有些是 AV_NOPTS_VALUE，这时候就需要 next_pts 来纠正。\n\nnext_pts 的计算规则就是上一帧的 pts 加上他的样本数（也就是播放多久）。\n\n注意：视频流没有使用 next_pts 来纠正，只有音频流用了 next_pts，如下：\n\n接下来分析decoder_init() 函数，代码如下：\n\n``` cpp\nstatic int decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond) {\n    memset(d, 0, sizeof(Decoder));\n    d->pkt = av_packet_alloc();\n    if (!d->pkt)\n        return AVERROR(ENOMEM);\n    d->avctx = avctx;\n    d->queue = queue;\n    d->empty_queue_cond = empty_queue_cond;\n    d->start_pts = AV_NOPTS_VALUE;\n    d->pkt_serial = -1;\n    return 0;\n}\n```\n\n可以看到，就是做一些赋值，比较简单，但是也有一个重点，就是他的 empty_queue_cond 实际上就是 continue_read_thread，只是换了个名字。 如下所示:\n\n``` cpp\n        if ((ret = decoder_init(&is->auddec, avctx, &is->audioq, is->continue_read_thread)) < 0)\n```\n\n### decoder_start()\n\n比较简单，就是开启 SDL 解码线程。\n代码如下:\n\n```cpp\nstatic int decoder_start(Decoder *d, int (*fn)(void *), const char *thread_name, void* arg)\n{\n    packet_queue_start(d->queue);\n    d->decoder_tid = SDL_CreateThread(fn, thread_name, arg);\n    if (!d->decoder_tid) {\n        av_log(NULL, AV_LOG_ERROR, \"SDL_CreateThread(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    return 0;\n}\n```\n\n---\n\n至此，switch case 里面对于音频的处理就讲解完毕，对于视频的处理更加简单，仅仅调了 decoder_init() 与 decoder_start()，如下：\n\n```cpp\n    case AVMEDIA_TYPE_VIDEO:\n        is->video_stream = stream_index;\n        is->video_st = ic->streams[stream_index];\n\n        if ((ret = decoder_init(&is->viddec, avctx, &is->videoq, is->continue_read_thread)) < 0)\n            goto fail;\n        if ((ret = decoder_start(&is->viddec, video_thread, \"video_decoder\", is)) < 0)\n            goto out;\n        is->queue_attachments_req = 1;\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        is->subtitle_stream = stream_index;\n        is->subtitle_st = ic->streams[stream_index];\n\n        if ((ret = decoder_init(&is->subdec, avctx, &is->subtitleq, is->continue_read_thread)) < 0)\n            goto fail;\n        if ((ret = decoder_start(&is->subdec, subtitle_thread, \"subtitle_decoder\", is)) < 0)\n            goto out;\n        break;\n```\n","tags":["FFplay源码分析"]},{"title":"FFplay源码分析---read_thread()","url":"/2023/12/09/FFmpeg/ffplay源码分析/read_thread()/","content":"## read_thread()\n\n![Alt text](../../../images/FFmpeg/ffplay源码分析/read_thread.png)\nread_thread() 线程的主要作用从 MP4 里面读取 AVPacket，然后丢进去 PacketQueue 队列。所以需要先学习一下 strcut PacketQueue 跟 struct MyAVPacketList 数据结构。\n\n```cpp\ntypedef struct MyAVPacketList {\n    AVPacket *pkt;\n    int serial;\n} MyAVPacketList;\n```\n\n``` cpp\ntypedef struct PacketQueue {\n    AVFifoBuffer *pkt_list; //存储的是 MyAVPacketList\n    int nb_packets;\n    int size;\n    int64_t duration;\n    int abort_request;\n    int serial;\n    SDL_mutex *mutex;\n    SDL_cond *cond;\n} PacketQueue;\n```\n\n1. AVFifoBuffer *pkt_list ，AVFifoBuffer 是一个 circular buffer FIFO，一个环形的先进先出的缓存实现。里面存储的是 struct MyAVPacketList 结构的数据。.\n2. int nb_packets;，代表队列里面有多少个 AVPacket。.\n3. int size; ，队列缓存的数据大小 ，算法是所有的 AVPacket 本身的大小加上 AVPacket->size 。.\n4. int64_t duration，队列的时长，通过累加 队列里所有的 AVPacket->duration 得到。.\n5. abort_request，代表队列终止请求，变成 1 会导致 audio_thread 跟 video_thread 退出。.\n6. int serial，队列的序号，每次跳转播放时间点 ，serial 就会 +1。另一个数据结构 MyAVPacketList 里面也有一个 serial 字段。\n    两个 serial 通过比较匹配来丢弃无效的缓存帧，什么情况会导致队列的缓存帧无效？跳转播放时间点的时候。\n\n    例如此时此刻，PacketQueue 队列里面缓存了 8 个帧，但是这 8 个帧都 第30分钟 才开始播放的，如果你通过 ➔ 按键前进到 第35分钟 的位置播放，那队列的 8 个缓存帧就无效了，需要丢弃。\n\n    由于每次跳转播放时间点， PacketQueue::serial 都会 +1 ，而 MyAVPacketList::serial 的值还是原来的，两个 serial 不一样，就会丢弃帧。\n7. SDL_mutex *mutex ，SDL 互斥锁，主要用于修改队列的时候加锁。.\n8. SDL_cond *cond，SDL 条件变量，用于 read_thread() 线程 跟 audio_thread() ，video_thread() 线程 进行通信的。\n\n---\n\n在 ffplay -i juren-5s.mp4 的场景下，read_thread 线程的流程图如下：\n![Alt text](../../../images/FFmpeg/ffplay源码分析/read_thread流程.png)\n\n### st_index[]\n\n首先讲解一下 st_index[] 这个数组变量的含义，如下：\n\n``` cpp\n/* this thread gets the stream from the disk or the network */\nstatic int read_thread(void *arg)\n{\n    VideoState *is = arg;\n    AVFormatContext *ic = NULL;\n    int err, i, ret;\n    int st_index[AVMEDIA_TYPE_NB];\n    AVPacket *pkt = NULL;\n    int64_t stream_start_time;\n    int pkt_in_play_range = 0;\n    AVDictionaryEntry *t;\n    SDL_mutex *wait_mutex = SDL_CreateMutex();\n    int scan_all_pmts_set = 0;\n    int64_t pkt_ts;\n    ...\n}\n```\n\n`st_index[]` 这个数组用的宏是 `AVMEDIA_TYPE_NB`，也就是这个数组涵盖了各种数据流，音频，视频，字幕，附件流等等。因为一个MP4里面可能会有多个视频流。\n\n例如 第 5，第 6 个流都是视频流。这时候 st_index[AVMEDIA_TYPE_VIDEO] 保存的可能就是 5 或者 6 ，代表要播放哪个视频流，其他数据流类推。\n\n默认 st_index[] 数组的值是通过 av_find_best_stream() 确定的，是通过 bit_rate 最大比特率，codec_info_nb_frames 等参数找出 最好的那个音频流 或者 视频流。\n\n### interrupt_callback\n\n指定了中断回调函数。\n\n``` cpp\n...\n  if (!wait_mutex) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError());\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    memset(st_index, -1, sizeof(st_index));\n    is->eof = 0;\n\n    pkt = av_packet_alloc();\n    if (!pkt) {\n        av_log(NULL, AV_LOG_FATAL, \"Could not allocate packet.\\n\");\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    ic = avformat_alloc_context();\n    if (!ic) {\n        av_log(NULL, AV_LOG_FATAL, \"Could not allocate context.\\n\");\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    ic->interrupt_callback.callback = decode_interrupt_cb;\n    ic->interrupt_callback.opaque = is;\n    if (!av_dict_get(format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE)) {\n        av_dict_set(&format_opts, \"scan_all_pmts\", \"1\", AV_DICT_DONT_OVERWRITE);\n        scan_all_pmts_set = 1;\n    }\n    err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n    if (err < 0) {\n        print_error(is->filename, err);\n        ret = -1;\n        goto fail;\n    }\n...\n```\n\n### decode_interrupt_cb()\n\n函数实现如下:\n\n``` cpp\nstatic int decode_interrupt_cb(void *ctx)\n{\n    VideoState *is = ctx;\n    return is->abort_request;\n}\n```\n\n首先，is->abort_request 这个变量控制着整个播放器要不要停止播放，然后退出。\n\n在播放本地文件的时候，interrupt_callback 回调函数的作用不是特别明显，因为本地读取MP4， av_read_frame() 会非常快返回。\n\n但是如果在播放网络流的时候，网络卡顿，av_read_frame() 可能要 8 秒才能返回，这时候如果想关闭播放器，就需要 av_read_frame() 尽快地返回，不要再阻塞了。这时候，就需要 interrupt_callback 了，因为在 8 秒 内，av_read_frame() 内部也会定时执行 interrupt_callback()，只要 interrupt_callback() 返回 1，av_read_frame() 就会不再阻塞，立即返回。\n\n提醒：播放网络流的时候，avformat_find_stream_info() 可能会跟 av_read_frame() 一样阻塞很久。\n\n### avformat_open_input()\n\n之前已经讲过这个函数了，[FFmpegAPI学习---avformat_open_input](<https://lyt-s.github.io/2023/11/20/FFmpeg/FFmpegAPI/FFmpegAPI%E5%AD%A6%E4%B9%A0-avformat-open-input/>)\n\n最后的参数 format_opts 是一个 AVDictionary （字典）。注意，如果 avformat_open_input 函数内部使用了字典的某个选项，就会把这个选项从字典剔除。\n\n所以可以看到，后面判断了还有哪些 option 没使用，这些无法使用的 option （选项），通常是因为命令行参数写错了。\n\nMP4，FLV，TS，等等容器格式，都有一些相同的 option，也有一些不同的 options。具体可以通过以下命令查看容器支持哪些 option ？\n\n``` bash\nffmpeg -h demuxer=mp4\n```\n\n提示：各种流媒体格式 也可以看成是 容器。\n\n### seek 操作\n\n但是本文是讲解 ffplay -i juren-5s.mp4 简单场景下的逻辑的。\n\n简单场景下，不会跑进去 seek 条件。**seek 操作以后再看 todo**\n\n``` cpp\n    is->ic = ic;\n\n    if (genpts)\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n    av_format_inject_global_side_data(ic);\n\n    if (find_stream_info) {\n        AVDictionary **opts = setup_find_stream_info_opts(ic, codec_opts);\n        int orig_nb_streams = ic->nb_streams;\n\n        err = avformat_find_stream_info(ic, opts);\n\n        for (i = 0; i < orig_nb_streams; i++)\n            av_dict_free(&opts[i]);\n        av_freep(&opts);\n\n        if (err < 0) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"%s: could not find codec parameters\\n\", is->filename);\n            ret = -1;\n            goto fail;\n        }\n    }\n\n    if (ic->pb)\n        ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use avio_feof() to test for the end\n\n    if (seek_by_bytes < 0)\n        seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT) && strcmp(\"ogg\", ic->iformat->name);\n\n    is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;\n\n    if (!window_title && (t = av_dict_get(ic->metadata, \"title\", NULL, 0)))\n        window_title = av_asprintf(\"%s - %s\", t->value, input_filename);\n\n    /* if seeking requested, we execute it */\n    if (start_time != AV_NOPTS_VALUE) {\n        int64_t timestamp;\n\n        timestamp = start_time;\n        /* add the stream start time */\n        if (ic->start_time != AV_NOPTS_VALUE)\n            timestamp += ic->start_time;\n        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n        }\n    }\n\n    is->realtime = is_realtime(ic);\n\n    if (show_status)\n        av_dump_format(ic, 0, is->filename, 0);\n\n    for (i = 0; i < ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        enum AVMediaType type = st->codecpar->codec_type;\n        st->discard = AVDISCARD_ALL;\n        if (type >= 0 && wanted_stream_spec[type] && st_index[type] == -1)\n            if (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) > 0)\n                st_index[type] = i;\n    }\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++) {\n        if (wanted_stream_spec[i] && st_index[i] == -1) {\n            av_log(NULL, AV_LOG_ERROR, \"Stream specifier %s does not match any %s stream\\n\", wanted_stream_spec[i], av_get_media_type_string(i));\n            st_index[i] = INT_MAX;\n        }\n    }\n\n    if (!video_disable)\n        st_index[AVMEDIA_TYPE_VIDEO] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,\n                                st_index[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);\n    if (!audio_disable)\n        st_index[AVMEDIA_TYPE_AUDIO] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,\n                                st_index[AVMEDIA_TYPE_AUDIO],\n                                st_index[AVMEDIA_TYPE_VIDEO],\n                                NULL, 0);\n    if (!video_disable && !subtitle_disable)\n        st_index[AVMEDIA_TYPE_SUBTITLE] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,\n                                st_index[AVMEDIA_TYPE_SUBTITLE],\n                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n                                 st_index[AVMEDIA_TYPE_AUDIO] :\n                                 st_index[AVMEDIA_TYPE_VIDEO]),\n                                NULL, 0);\n```\n\n### AVRational sar\n\nsar 这个值是不太容易理解的，我刚开始也被这个 sar 搞懵。我之前以为 sar 等于 width/height （宽高比） ，后来发现不是宽高比。\n\n其实 sar 是以前的显示设备设计的历史遗留问题，不用过多关注，只需要知道，显示的时候用 sar 这个比例拉伸 width 跟 height 作为显示窗口，图像播放就不会扭曲了。sar 在大部分情况都是 1:1。\n\n``` cpp\n    is->show_mode = show_mode;\n    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n        AVStream *st = ic->streams[st_index[AVMEDIA_TYPE_VIDEO]];\n        AVCodecParameters *codecpar = st->codecpar;\n        AVRational sar = av_guess_sample_aspect_ratio(ic, st, NULL);\n        if (codecpar->width)\n            set_default_window_size(codecpar->width, codecpar->height, sar);\n    }\n\n```\n\n### stream_component_open()\n\n接下来来到 `read_thread()` 线程里**最重要的重点**，`stream_component_open()` 函数的调用，`audio_thread()`，`video_thread()` 等解码线程就是从 `stream_component_open()` 里 创建出来的。\n**todo  新一篇文章来进行学习**\n\n``` cpp\n    /* open the streams */\n    if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n        stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n    }\n    \n    if (is->video_stream < 0 && is->audio_stream < 0) {\n        av_log(NULL, AV_LOG_FATAL, \"Failed to open file '%s' or configure filtergraph\\n\",\n               is->filename);\n        ret = -1;\n        goto fail;\n    }\n\n    if (infinite_buffer < 0 && is->realtime)\n        infinite_buffer = 1;\n\n```\n\n> 至此: 上面所有代码干的活，主要是找出最好的音视频流，设置回调，各种初始化，打开容器实例\n\n---\n`read_thread()` 线程的**主要任务**，那就是进入`for (;;) {...}` 死循环不断 **从容器实例读取AVPacket ，然后丢进去对应的 PacketQueue 队列。**\n\n下面分析for循环\n\n``` cpp\n    for (;;) {\n        if (is->abort_request)\n            break;\n        if (is->paused != is->last_paused) {\n            is->last_paused = is->paused;\n            if (is->paused)\n                is->read_pause_return = av_read_pause(ic);\n            else\n                av_read_play(ic);\n        }\n#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL\n        if (is->paused &&\n                (!strcmp(ic->iformat->name, \"rtsp\") ||\n                 (ic->pb && !strncmp(input_filename, \"mmsh:\", 5)))) {\n            /* wait 10 ms to avoid trying to get another packet */\n            /* XXX: horrible */\n            SDL_Delay(10);\n            continue;\n        }\n#endif\n        if (is->seek_req) {\n            int64_t seek_target = is->seek_pos;\n            int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;\n            int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;\n    // FIXME the +-2 is due to rounding being not done in the correct direction in generation\n    //      of the seek_pos/seek_rel variables\n\n            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n            if (ret < 0) {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"%s: error while seeking\\n\", is->ic->url);\n            } else {\n                if (is->audio_stream >= 0)\n                    packet_queue_flush(&is->audioq);\n                if (is->subtitle_stream >= 0)\n                    packet_queue_flush(&is->subtitleq);\n                if (is->video_stream >= 0)\n                    packet_queue_flush(&is->videoq);\n                if (is->seek_flags & AVSEEK_FLAG_BYTE) {\n                   set_clock(&is->extclk, NAN, 0);\n                } else {\n                   set_clock(&is->extclk, seek_target / (double)AV_TIME_BASE, 0);\n                }\n            }\n            is->seek_req = 0;\n            is->queue_attachments_req = 1;\n            is->eof = 0;\n            if (is->paused)\n                step_to_next_frame(is);\n        }\n        if (is->queue_attachments_req) {\n            if (is->video_st && is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC) {\n                if ((ret = av_packet_ref(pkt, &is->video_st->attached_pic)) < 0)\n                    goto fail;\n                packet_queue_put(&is->videoq, pkt);\n                packet_queue_put_nullpacket(&is->videoq, pkt, is->video_stream);\n            }\n            is->queue_attachments_req = 0;\n        }\n\n        /* if the queue are full, no need to read more */\n        if (infinite_buffer<1 &&\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n            || (stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) &&\n                stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq) &&\n                stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)))) {\n            /* wait 10 ms */\n            SDL_LockMutex(wait_mutex);\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n            SDL_UnlockMutex(wait_mutex);\n            continue;\n        }\n        if (!is->paused &&\n            (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) &&\n            (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) {\n            if (loop != 1 && (!loop || --loop)) {\n                stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n            } else if (autoexit) {\n                ret = AVERROR_EOF;\n                goto fail;\n            }\n        }\n        ret = av_read_frame(ic, pkt);\n        if (ret < 0) {\n            if ((ret == AVERROR_EOF || avio_feof(ic->pb)) && !is->eof) {\n                if (is->video_stream >= 0)\n                    packet_queue_put_nullpacket(&is->videoq, pkt, is->video_stream);\n                if (is->audio_stream >= 0)\n                    packet_queue_put_nullpacket(&is->audioq, pkt, is->audio_stream);\n                if (is->subtitle_stream >= 0)\n                    packet_queue_put_nullpacket(&is->subtitleq, pkt, is->subtitle_stream);\n                is->eof = 1;\n            }\n            if (ic->pb && ic->pb->error) {\n                if (autoexit)\n                    goto fail;\n                else\n                    break;\n            }\n            SDL_LockMutex(wait_mutex);\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n            SDL_UnlockMutex(wait_mutex);\n            continue;\n        } else {\n            is->eof = 0;\n        }\n        /* check if packet is in play range specified by user, then queue, otherwise discard */\n        stream_start_time = ic->streams[pkt->stream_index]->start_time;\n        pkt_ts = pkt->pts == AV_NOPTS_VALUE ? pkt->dts : pkt->pts;\n        pkt_in_play_range = duration == AV_NOPTS_VALUE ||\n                (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) *\n                av_q2d(ic->streams[pkt->stream_index]->time_base) -\n                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n                <= ((double)duration / 1000000);\n        if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n            packet_queue_put(&is->audioq, pkt);\n        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range\n                   && !(is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC)) {\n            packet_queue_put(&is->videoq, pkt);\n        } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n            packet_queue_put(&is->subtitleq, pkt);\n        } else {\n            av_packet_unref(pkt);\n        }\n    }\n```\n\n### av_read_pause()\n\n对于播放本地文件，av_read_pause() 函数其实是没有作用的。av_read_pause() 只对网络流播放有效，有些流媒体协议支持暂停操作，暂停了，服务器就不会再往 ffplay 推送数据，如果想重新推数据，需要调用 av_read_play()\n\n``` cpp\n    for (;;) {\n        if (is->abort_request)\n            break;\n        if (is->paused != is->last_paused) {\n            is->last_paused = is->paused;\n            if (is->paused)\n                is->read_pause_return = av_read_pause(ic);\n            else\n                av_read_play(ic);\n        }\n    ...\n    }\n```\n\n### SDL_CondWaitTimeout()\n\nfor 循环里面的第二个重点是 判断 队列缓存中的 AVPacket 是否够用，够用就会休眠 10ms。如下：\n\n``` cpp\n\n        /* if the queue are full, no need to read more */\n        if (infinite_buffer<1 &&\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n            || (stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) &&\n                stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq) &&\n                stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)))) {\n            /* wait 10 ms */\n            SDL_LockMutex(wait_mutex);\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n            SDL_UnlockMutex(wait_mutex);\n            continue;\n        }\n```\n\n在播放本地文件的时候，`infinite_buffer` 总是 0，所以不用管它。\n\n可以看到，判断 `AVPacket` 是否够用，就是根据 `size` 来判断，还有` stream_has_enough_packets() `函数，实现如下：\n\n```cpp\nstatic int stream_has_enough_packets(AVStream *st, int stream_id, PacketQueue *queue) {\n    return stream_id < 0 ||\n           queue->abort_request ||\n           (st->disposition & AV_DISPOSITION_ATTACHED_PIC) ||\n           queue->nb_packets > MIN_FRAMES && (!queue->duration || av_q2d(st->time_base) * queue->duration > 1.0);\n}\n```\n\nstream_has_enough_packets() 主要就是确认 队列至少有 MIN_FRAMES 个帧，而且所有帧的播放时长加起来大于 1 秒钟。\n\n### av_read_frame()\n\n``` cpp\nint av_read_frame(AVFormatContext *s, AVPacket *pkt);\n```\n\n参数解释：\n\n* s：指向AVFormatContext结构体的指针，表示输入文件的上下文信息。AVFormatContext结构体包含了媒体文件的封装格式相关信息，如文件名、流信息等。\n* pkt：指向AVPacket结构体的指针，用于存储读取到的数据包。\n\n返回值：\n\n* 返回值为0表示成功读取了一帧数据包。\n* 返回值为负数表示出现了错误或读取结束，具体的错误码可以参考FFmpeg库的错误码定义。\n\n函数功能：\n\n* av_read_frame函数用于从输入文件中读取音频或视频数据包。\n* 函数会根据当前的读取位置，从输入文件中读取下一个有效的数据包，并将其存储在pkt指向的数据包结构体中。\n* 数据包结构体AVPacket包含了数据包的相关信息，如数据指针、数据大小、时间戳等。\n* 读取的数据包可以是音频帧、视频帧或其他媒体数据。\n* 函数会自动处理媒体文件的封装格式，解析出各个流的数据，并按照时间顺序提供给调用者。\n\n### pkt_in_play_range\n\n当 队列缓存中的 AVPacket 未满的时候，就会直接去读磁盘数据，把 AVPacket 读出来，但是也不是读出来就会立即丢进去 PacketQueue 队列，而是会判断一下AVPacket 是否在期待的播放时间范围内。下面代码可以看到。\n\n``` cpp\n      /* check if packet is in play range specified by user, then queue, otherwise discard */\n      stream_start_time = ic->streams[pkt->stream_index]->start_time;\n      pkt_ts = pkt->pts == AV_NOPTS_VALUE ? pkt->dts : pkt->pts;\n      // 来确定是否在播放时间范围内。\n      pkt_in_play_range = duration == AV_NOPTS_VALUE ||\n              (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) *\n              av_q2d(ic->streams[pkt->stream_index]->time_base) -\n              (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n              <= ((double)duration / 1000000);\n      if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n          packet_queue_put(&is->audioq, pkt);\n```\n\n变量 pkt_in_play_range 来确定是否在播放时间范围内。播放时间范围这个概念是这样的。如果下面这样播放一个视频：\n\n```bash\nffplay -i juren-5s.mp4\n```\n\n因为 juren-5s.mp4 是一个 5 秒的视频，而且命令行没有指定 -t，所以这时候 播放时间范围 就是 0 ~ 5 秒。只要读出来的 AVPacket 的 pts 在 0 ~ 5秒范围内，pkt_in_play_range 变量就为真。因此所有读出来的 AVPacket 都是符合播放时间范围的。\n\n但是如果加了 -t 参数，如下：\n\n``` bash\nffplay -t 2 -i juren-5s.mp4\n```\n\n上面的的命令是 只播放 2秒视频，也就是 播放时间范围 变成了 0 ~ 2 秒，如果读出来的 AVPacket 的 pts 大于 2 秒，就会被丢弃。\n\n这里就有一个有趣的事情，当视频播放到 第二秒的时候，虽然画面停止了，但是 read_thread() **还是会一直读数据**，但由于不符合播放时间范围，**会一直丢弃**。直到读到文件结尾，返回 AVERROR_EOF 才会停下来休眠一小段时间。\n\n### packet_queue_put()\n\n读出来的 AVPacket 符合播放时间之后，就会 用 packet_queue_put() 丢进去 PacketQueue 队列。\n\n可以看到，音频，视频流，是有各自的 PacketQueue 队列的，is->audioq 跟 is->videoq。\n\n```cpp\n     ret = av_read_frame(ic, pkt);\n     if (ret < 0) {\n         if ((ret == AVERROR_EOF || avio_feof(ic->pb)) && !is->eof) {\n             if (is->video_stream >= 0)\n                 packet_queue_put_nullpacket(&is->videoq, pkt, is->video_stream);\n             if (is->audio_stream >= 0)\n                 packet_queue_put_nullpacket(&is->audioq, pkt, is->audio_stream);\n             if (is->subtitle_stream >= 0)\n                 packet_queue_put_nullpacket(&is->subtitleq, pkt, is->subtitle_stream);\n             is->eof = 1;\n         }\n         if (ic->pb && ic->pb->error) {\n             if (autoexit)\n                 goto fail;\n             else\n                 break;\n         }\n         SDL_LockMutex(wait_mutex);\n         SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n         SDL_UnlockMutex(wait_mutex);\n         continue;\n     } else {\n         is->eof = 0;\n     }\n...\n     if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n         // 将读到的符合，丢进队列\n         packet_queue_put(&is->audioq, pkt);\n     } else if (pkt->stream_index == is->video_stream && pkt_in_play_range\n                && !(is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC)) {\n         packet_queue_put(&is->videoq, pkt);\n     } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n         packet_queue_put(&is->subtitleq, pkt);\n     } else {\n         av_packet_unref(pkt);\n     }\n...\n```\n\n---\n\nFFplay 播放器的逻辑流转，`目前就转到 for (;;) {...}` 循环里面不断读取 `AVPacket` 数据。\n\n`read_thread()` 线程函数最后的 fail: 标签代码，是播放器退出之后的清理逻辑，---todo。\n\n### 遗留的问题 todo\n\n1. wanted_stream_spec[] 数组的作用，本文中，这个数组全是 -1，所以忽略了。\n2. av_format_inject_global_side_data() 函数详解。\n3. seek 操作。\n4. av_find_best_stream()\n5. stream_component_open\n6. avformat_find_stream_info\n","tags":["FFplay源码分析"]},{"title":"FFplay源码分析---stream_open()","url":"/2023/12/09/FFmpeg/ffplay源码分析/stream_open()/","content":"## stream_open()\n\n![Alt text](../../../images/FFmpeg/ffplay源码分析/stream_open.png)\n\n### struct VideoState\n\nVideoState 可以说是播放器的全局管理器。字段非常多，时钟，队列，解码器，各种状态 都放在 VideoState 里面。\n\n但是本文不会把 VideoState 的所有字段都讲一遍，只会讲 stream_open() 函数用到的字段，如下是精简过的字段，顺序也经过调整，方便阅读。\n\n``` cpp\ntypedef struct VideoState {\n    int last_video_stream, last_audio_stream, last_subtitle_stream;\n    char* filename;\n    AVInputFormat* iformat;\n    int width, height, xleft, ytop;\n    FrameQueue pictq;\n    FrameQueue sampq;\n    PacketQueue videoq;\n    PacketQueue audioq;\n    SDL_cond *continue_read_thread;\n    SDL_Thread *read_tid;\n    Clock audclk;\n    Clock vidclk;\n    Clock extclk;    \n    int audio_clock_serial;\n    int audio_volume;\n    int muted;\n    int av_sync_type;\n} VideoState;\n```\n\n1. int last_video_stream 代表最后一个视频流，如果你的音视频文件 里面有多个视频流，last_video_stream 就代表最后一个视频流。另外两个 last_audio_stream, last_subtitle_stream 一样代表最后一个。\n\n2. char* filename 存储的是打开的 音视频文件名，或者是网络地址url。\n\n3. AVInputFormat* iformat，容器格式，ffplay 默认是根据 filename 的后缀来确定容器格式，但是你也可以指定按某种容器格式来解析文件。命令如下：\n\n    ```cpp\n    ffplay -i juren-5s.mp4 -f flv\n    ```\n\n    通过命令行参数指定的 -f flv 就会被存储到 AVInputFormat* iformat，当然不是存的字符，有一个根据字符串找到 AVInputFormat 的过程。\n4. int width, height, xleft, ytop;，分别代表播放器窗口的 宽高 跟 位置。位置通过 xleft 跟 ytop 来定位的。\n\n5. FrameQueue pictq， FrameQueue sampq，视频跟音频的 AVFrame 队列。\n\n6. PacketQueue videoq，PacketQueue audioq，视频跟音频的 AVPacket 队列。\n\n7. SDL_cond *continue_read_thread，这是一个 SDL 的条件变量，用于线程间通信的。read_thread() 线程在以下两种情况会进入休眠 10ms.\n   1. 第一种情况：PacketQueue 队列满了，无法再塞数据进去。\n   2. 第二种情况：超过最小缓存size。如果在 10ms 内，PacketQueue 队列全部被消耗完毕，audio_thread() 或者 video_thread() 线程 没有 AVPakcet 能读了，就需要尽快唤醒 read_thread() 线程。\n   3. 如果进行了 seek 操作，也需要快速把 read_thread() 线程 从休眠中唤醒。\n    所以 SDL_cond *continue_read_thread 条件变量，主要用于 read_thread 跟 audio_thread ，video_thread 线程进行通信的。\n8. SDL_Thread *read_tid;，read_thread 的线程ID。\n\n    C++14 标准库有跨平台的线程库，但是 C语言 是没有跨平台的线程库，所以 ffplay 取巧了，使用了 SDL 库的线程跟条件变量，SDL 是跨平台的。\n\n9. Clock audclk;，音频时钟，记录音频流的目前的播放时刻 。\n\n10. Clock vidclk;，视频时钟，记录视频流的目前的播放时刻 。\n\n11. Clock extclk;，外部时钟，取第一帧 音频 或 视频的 pts 作为 起始时间，然后随着物理时间的消逝增长，所以是物理时间的当前时刻。到底是以音频的第一帧，还是视频的第一帧？取决于 av_read_frame() 函数第一次读到的是音频还是视频。\n12. int audio_clock_serial;，这个字段比较独特，只有音频有，视频没有，没有一个 video_clock_serial 字段。\n\n    audio_clock_serial 只是一个用做临时用途的变量，实际上存储的就是 AVFrame 的 serial 字段。不用特别关注。而视频直接用的 AVFrame 的 serial。\n\n13. int audio_volume，播放器的声音大小。\n\n14. int muted，是否静音，C语言C99标准是没有 bool 类型的，都用 int 代替。\n\n15. int av_sync_type，音视频同步方式，有 3 种同步方式，以音频时钟为准，以视频时钟为准，以外部时钟为准。默认方式是以音频时钟为准。\n\n---\n\n由于 FrameQueue 跟 PacketQueue 这两个数据结构非常重要，所以放一整图片方便理解。\n![Alt text](../../../images/FFmpeg/ffplay源码分析/FrameQueue_PacketQueue.png)\n\nFrameQueue 里面的 queue 是一个数组，16 在代码里是一个宏，那个宏通常等于 16。PacketQueue 里面的 pkt_list 是一个 AVFifoBuffer。\n\nFrameQueue 跟 PakcetQueue 是通过一个 pktq 指针来关联的。这两个队列都有自己的 锁 mutex 跟 条件变量 cond。操作这两个队列都需要加锁操作的。\n\n---\n\n下面开始分析 stream_open() 函数，流程图，代码如下\n![Alt text](../../../images/FFmpeg/ffplay源码分析/stream_open流程.png)\n\n``` cpp\nstatic VideoState *stream_open(const char *filename, AVInputFormat *iformat)\n{\n    VideoState *is;\n\n    is = av_mallocz(sizeof(VideoState));\n    if (!is)\n        return NULL;\n    is->last_video_stream = is->video_stream = -1;\n    is->last_audio_stream = is->audio_stream = -1;\n    is->last_subtitle_stream = is->subtitle_stream = -1;\n    is->filename = av_strdup(filename);\n    if (!is->filename)\n        goto fail;\n    is->iformat = iformat;\n    is->ytop    = 0;\n    is->xleft   = 0;\n\n    /* start video display */\n    // 初始化 video 队列\n    if (frame_queue_init(&is->pictq, &is->videoq, VIDEO_PICTURE_QUEUE_SIZE, 1) < 0)\n        goto fail;\n    // 初始化 subtitles 队列\n    if (frame_queue_init(&is->subpq, &is->subtitleq, SUBPICTURE_QUEUE_SIZE, 0) < 0)\n        goto fail;\n    // 初始化 audio 队列\n    if (frame_queue_init(&is->sampq, &is->audioq, SAMPLE_QUEUE_SIZE, 1) < 0)\n        goto fail;\n\n    if (packet_queue_init(&is->videoq) < 0 ||\n        packet_queue_init(&is->audioq) < 0 ||\n        packet_queue_init(&is->subtitleq) < 0)\n        goto fail;\n\n    if (!(is->continue_read_thread = SDL_CreateCond())) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError());\n        goto fail;\n    }\n    // 初始化clock\n    init_clock(&is->vidclk, &is->videoq.serial);\n    init_clock(&is->audclk, &is->audioq.serial);\n    init_clock(&is->extclk, &is->extclk.serial);\n    is->audio_clock_serial = -1;\n    if (startup_volume < 0)\n        av_log(NULL, AV_LOG_WARNING, \"-volume=%d < 0, setting to 0\\n\", startup_volume);\n    if (startup_volume > 100)\n        av_log(NULL, AV_LOG_WARNING, \"-volume=%d > 100, setting to 100\\n\", startup_volume);\n    startup_volume = av_clip(startup_volume, 0, 100);\n    startup_volume = av_clip(SDL_MIX_MAXVOLUME * startup_volume / 100, 0, SDL_MIX_MAXVOLUME);\n    is->audio_volume = startup_volume;\n    is->muted = 0;\n    is->av_sync_type = av_sync_type;\n    // 新的线程 read_thread()\n    is->read_tid     = SDL_CreateThread(read_thread, \"read_thread\", is);\n    if (!is->read_tid) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateThread(): %s\\n\", SDL_GetError());\nfail:\n        stream_close(is);\n        return NULL;\n    }\n    return is;\n}\n```\n\nstream_open() 函数的内部实现非常的简单。无非就是 初始化 队列，初始化时钟，然后创建一个 read_thread() 线程去跑。\n\n### frame_queue_init\n\n``` cpp\nstatic int frame_queue_init(FrameQueue *f, PacketQueue *pktq, int max_size, int keep_last)\n{\n    int i;\n    // memset函数将f指向的帧队列结构体的内存空间清零。\n    memset(f, 0, sizeof(FrameQueue));\n    // 创建一个互斥锁\n    if (!(f->mutex = SDL_CreateMutex())) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    // 创建一个条件变量，并将其赋值给帧队列结构体中的cond成员\n    if (!(f->cond = SDL_CreateCond())) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    // 参数pktq赋值给帧队列结构体中的pktq成员。\n    f->pktq = pktq;\n    f->max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);\n    // 这个 !! 操作没有什么特别，实际上就是把大于 1 的数字转成 1。如果 keep_last 等于 5，取反两次之后，就会变成 1 了。\n    f->keep_last = !!keep_last;\n    // 为帧队列中的每个元素分配一个AVFrame结构体，并将其赋值给帧队列结构体中的queue[i].frame成员。\n    for (i = 0; i < f->max_size; i++)\n        if (!(f->queue[i].frame = av_frame_alloc()))\n            return AVERROR(ENOMEM);\n    // 返回0表示初始化成功。\n    return 0;\n}\n```\n\n### packet_queue_init\n\n``` cpp\n/* packet queue handling */\nstatic int packet_queue_init(PacketQueue *q)\n{\n    memset(q, 0, sizeof(PacketQueue));\n    // av_fifo_alloc函数为数据包队列结构体的pkt_list成员分配一个AVFifoBuffer类型的FIFO队列。\n    q->pkt_list = av_fifo_alloc(sizeof(MyAVPacketList));\n    if (!q->pkt_list)\n        return AVERROR(ENOMEM);\n    q->mutex = SDL_CreateMutex();\n    if (!q->mutex) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    q->cond = SDL_CreateCond();\n    if (!q->cond) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    //abort_request 字段如果置为 1， audio_thread() 跟 video_thread() 解码线程就会退出。所以在创建解码线程 之前，ffplay 会把 abort_request 置为 0 ，\n    q->abort_request = 1;\n    return 0;\n}\n```\n\n### init_clock\n\n``` cpp\nstatic void init_clock(Clock *c, int *queue_serial)\n{   // 将时钟结构体的speed成员设置为1.0，表示时钟的播放速度为正常速度。\n    c->speed = 1.0;\n    // 将时钟结构体的paused成员设置为0，表示时钟处于非暂停状态。\n    c->paused = 0;\n    // 将时钟结构体的queue_serial成员指向传入的队列序列号指针，用于与其他组件共享队列序列号信息。\n    c->queue_serial = queue_serial;\n    // 将时钟结构体的其他成员进行初始化。其中，第一个参数是时钟结构体的指针，第二个参数是NAN（Not a Number），表示初始时钟值未知，第三个参数是-1，表示初始时钟序列号未知。\n    set_clock(c, NAN, -1);\n}\n```\n\n> stream_open() 函数已经讲解完毕，现在逻辑流程已经流转到新的线程 read_thread() 函数里面了，下面文章继续分析 **read_thread()** 函数的内部原理。\n","tags":["FFplay源码分析"]},{"title":"FFplay源码分析---main()","url":"/2023/12/09/FFmpeg/ffplay源码分析/main/","content":"\n![Alt text](../../../images/FFmpeg/ffplay源码分析/ffplay_main.png)\n\n## 非重点函数如下\n\n1，init_dynload()，设置动态库加载规则，这是一个安全函数，在 Windows 系统，默认会从当前目录加载 DLL，这容易被攻击。这个函数就是把当前目录的路径从加载规则里面去掉，里面调的是 SetDllDirectory(\"\")。\n\n2，show_banner()，打印 ffplay 这个软件的 版权，版本之类的信息。可以删掉他，让控制台更简洁。\n\n## 重点函数如下\n\n1. parse_options()，解析命令行参数，虽然这是一个重点函数，但是为了力求简单，我会一笔带过。本文只用到 一个 -i 参数，所以这个函数在这里的作用就是设置 input_filename 全局变量。在 《parse_options函数分析》会详细讲解 命令行解析。\n\n2. SDL_CreateWindow()，创建 SDL 窗口，具体请看 SDL官方文档。\n\n3. stream_open()，这个函数是重中之重，上图中可以看到，可能会有 4 个线程从 stream_open() 里面诞生。先来讲一下这 4 个线程的作用。\n   1. read_thread() ：从 网络或者硬盘里面读取 AVPacket，读取到之后放进去 PacketQueue 队列。\n   2. audio_thread() ：从 PacketQueue audioq 队列拿 AVPacket，然后丢给解码器解码，解码出来 AVFrame 之后，再把 AVFrame 丢到 FrameQueue 队列。\n   3. video_thread() ：从 PacketQueue videoq 队列拿 AVPacket，然后丢给解码器解码，解码出来 AVFrame 之后，再把 AVFrame 丢到 FrameQueue 队列。\n   4. subtitle_thread() ：字幕线程，由于 ffplay 的字幕播放有点不完善，不必关注。\n\n    上面的 4 个线程 不一定会创建，如果 mp4 文件里面没有音频流，就不会创建 audio_thread() 线程，其他的线程 类推。\n\n    这 4 个线程之间的关系如下：**read_thread 是生产者，而 audio_thread 跟 video_thread 是消费者。**\n    ![Alt text](../../../images/FFmpeg/ffplay源码分析/stread_open_thread.png)\n\n4. event_loop()，这个函数是一个死循环，主要的任务就是不断 **处理键盘按键事件** 跟 **播放视频帧。**\n","tags":["FFplay源码分析"]},{"title":"491.递增子序列","url":"/2023/11/30/leetcode/回溯算法/491-递增子序列/","content":"## 题目描述\n\n给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 任意顺序 返回答案。\n\n数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n\n``` cpp\n示例 1：\n\n输入：nums = [4,6,7,7]\n输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n示例 2：\n\n输入：nums = [4,4,3,2,1]\n输出：[[4,4]]\n \n\n提示：\n\n1 <= nums.length <= 15\n-100 <= nums[i] <= 100\n```\n\n## 三部曲\n\n* 递归函数参数\n\n递增子序列。\n\n``` cpp\n    vector<vector<int>> result;\n    vector<int> path;\n\n    void backtracking(vector<int>& nums, int startIndex)\n```\n\n* 递归终止条件\n\n这里要注意，递增序列至少两个元素，所以要判断，何时将path加入到result中。\n当`startIndex` 大于 `nums.size()` 时，返回。\n\n``` cpp\n  if(path.size() > 1){\n      result.push_back(path);\n  }\n  if(startIndex > nums.size()){\n      return;\n  }\n```\n\n* 单层搜索逻辑\n  \n这里的递增为>= 所以，要判断`used`中是否包含当前的数字。\n\n  1. 当 `path` 不为空， 并且当前的数字，比path序列中最后一数字小时，跳过此次循环。\n  2. 当前数字，在`used`中找到时，我们也跳出循环，这里用 `unordered_set` 来进行去重。\n  3. 前面两种情况出现任意一种，就跳过此次循环。\n\n``` cpp\n  unordered_set<int> uset;\n  for(int i = startIndex; i <nums.size();++i){\n     if(!path.empty()&& nums[i] < path.back() || uset.find(nums[i]) != uset.end()){\n         continue;\n     }\n     uset.insert(nums[i]);\n     path.push_back(nums[i]);\n     backtracking(nums,i+1);\n     path.pop_back();\n  }\n```\n\n## 代码\n\n``` cpp\nclass Solution {\n    vector<vector<int>> result;\n    vector<int> path;\n\n    void backtracking(vector<int> nums, int startIndex){\n        if(path.size() > 1){\n            result.push_back(path);\n        }\n        if(startIndex > nums.size()){\n            return;\n        }\n\n        unordered_set<int> uset;\n        for(int i = startIndex; i <nums.size();++i){\n            if(!path.empty()&& nums[i] < path.back() || uset.find(nums[i]) != uset.end()){\n                continue;\n            }\n            uset.insert(nums[i]);\n            path.push_back(nums[i]);\n            backtracking(nums,i+1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        backtracking(nums,0);\n        return result;\n    }\n};\n```\n","tags":["leetcode"]},{"title":"c++局部变量初始化，推荐用哪种写法？最不容易错？","url":"/2023/11/28/cpp/practice/c-局部变量初始化，推荐用哪种写法？最不容易错/","content":"\n\n## c++ 局部变量初始化，推荐用哪种写法？最不容易错？\n\n> auto 防止不初始化\n\n``` cpp\n#include<iostream>\n#include <cstring>\n#include <memory>\n#include <vector>\n\nusing namespace std::literals;\nstruct C{\n    int sex = 0;\n    int age =18;\n    std::string name = \"hello\"s;\n};\n\nstruct lerp{\n    float from =0;\n    float to = 1;\n    float fac = 0.5f;\n\n    struct result{\n        float value;\n        float second_value;\n    };\n\nresult  operator()()const{\n    return{\n    .value =  fac * (to - from) + from,\n    .second_value = fac * (from - to) + to};\n}\n};\n\n\nint main(int argc,char**argv){\n    \n    auto i = [&]{\n        for(int i = 0;i < argc;++i){\n            if(!strcmp(argv[i],\"-h\")){\n                return i;\n            }\n        }\n        return -1;\n    }();\n\n    int i1;  // 错误\n    auto i2 = size_t(i1) ; //正确\n\n    C c1; // 错误\n    auto c2 = C{}; //正确\n    auto p1 = new C;\n    auto p2 = std::make_shared<C>(1,2); // 等价于 C(1,2); // 正确\n\n    auto c3 = char(0); //解决方案\n    auto s1 = std::string(\"hello\"); // 解决方案\n    auto s = \"hello\"s; // 更好的解决方案\n    s= s + \"world\"s;\n    std::cerr << s<<\"\\n\";\n\n    auto c = C{.age = 2};\n    std::cerr << c.age<<\"\\n\";\n    std::cerr << c.name<<\"\\n\"; \n\n    // 死循环\n    // std::vector<int> a(0xffffff);\n    // for(auto i =0; i <a.size();++i){\n    //     std::cerr <<a[i];\n    // }\n\n    // todo static_cast \n    std::vector<int> a1(0xffffff);\n    int *p; \n    // static_cast<size_t>(p)  // 会出错\n    for(auto i = static_cast<size_t>(0); i <a1.size();++i){\n        std::cerr <<a1[i];\n    }\n   \n\n   //\n    // 参数顺序问题解决方案，函数解决方法，\n   auto x1 = lerp{.from = 0, .to =1, .fac = 0.25}();\n\n    // 花里胡哨\n\n    auto [x, y] = lerp{.from = 0, .to =1, .fac = 0.25}();\n    std::cerr << x << \"\\n\";\n    std::cerr << y << \"\\n\";\n    return 0;\n}\n\n\n// auto 防止不初始化\n\n```\n\n原文链接:\n<https://www.bilibili.com/video/BV1xh4y1d7uh/?spm_id_from=333.788&vd_source=733250e8f66c27df3972c026bae5b31b>\n","tags":["c++11"],"categories":["c++"]},{"title":"47.全排列II","url":"/2023/11/27/leetcode/回溯算法/47-全排列II/","content":"## 题目描述\n\n给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n\n``` cpp\n示例 1：\n\n输入：nums = [1,1,2]\n输出：\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n示例 2：\n\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n \n\n提示：\n\n1 <= nums.length <= 8\n-10 <= nums[i] <= 10\n```\n\n## 三部曲\n\n* 递归参数\n\n``` cpp\n  vector<vector<int>> result;\n  vector<int> path;\n\n  void backtracking(vector<int>& nums,vector<bool> used)\n```\n\n* 递归终止条件\n\n排列问题， 终止就要遍历全部元素。\n\n``` cpp\n// 此时说明找到了一组\nif (path.size() == nums.size()) {\n    result.push_back(path);\n    return;\n}\n```\n\n* 单层搜索的逻辑\n  \n在40.组合总和II (opens new window)、90.子集II (opens new window)中详细讲解了去重的写法.\n\n代码如下:\n\n``` cpp\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking (vector<int>& nums, vector<bool>& used) {\n        // 此时说明找到了一组\n        if (path.size() == nums.size()) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过\n            // used[i - 1] == false，说明同一树层nums[i - 1]使用过\n            // 如果同一树层nums[i - 1]使用过则直接跳过\n            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {\n                continue;\n            }\n            if (used[i] == false) {\n                used[i] = true;\n                path.push_back(nums[i]);\n                backtracking(nums, used);\n                path.pop_back();\n                used[i] = false;\n            }\n        }\n    }\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 排序\n        vector<bool> used(nums.size(), false);\n        backtracking(nums, used);\n        return result;\n    }\n};\n\n// 时间复杂度: 最差情况所有元素都是唯一的。复杂度和全排列1都是 O(n! * n) 对于 n 个元素一共有 n! 中排列方案。而对于每一个答案，我们需要 O(n) 去复制最终放到 result 数组\n// 空间复杂度: O(n) 回溯树的深度取决于我们有多少个元素\n```\n\n> **这里建议 78.子集、90.子集II、39.组合总和、40.组合总和II、46全排列、47全排列II一块看，并进行总结**\n","tags":["leetcode"]},{"title":"46.全排列","url":"/2023/11/27/leetcode/回溯算法/46-全排列/","content":"## 题目描述\n\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n\n```cpp\n示例 1：\n\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n示例 2：\n\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n示例 3：\n\n输入：nums = [1]\n输出：[[1]]\n \n\n提示：\n\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nnums 中的所有整数 互不相同\n```\n\n## 三部曲\n\n**注意这次是排列问题，而不是组合问题**\n\n![as](https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png)\n\n* 递归参数\n首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。\n排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示\n\n代码如下:\n\n``` cpp\nvector<vector<int>> result;\nvector<int> path;\nvoid backtracking (vector<int>& nums, vector<bool>& used)\n```\n\n* 递归终止条件\n\n排列问题， 终止就要遍历全部元素。\n\n``` cpp\n// 此时说明找到了一组\nif (path.size() == nums.size()) {\n    result.push_back(path);\n    return;\n}\n```\n\n* 单层搜索的逻辑\n\n因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。\n\n而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。\n\n``` cpp\nfor (int i = 0; i < nums.size(); i++) {\n    if (used[i] == true) continue; // path里已经收录的元素，直接跳过\n    used[i] = true;\n    path.push_back(nums[i]);\n    backtracking(nums, used);\n    path.pop_back();\n    used[i] = false;\n}\n```\n\n整体C++代码如下：\n\n``` cpp\nclass Solution {\npublic:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking (vector<int>& nums, vector<bool>& used) {\n        // 此时说明找到了一组\n        if (path.size() == nums.size()) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            if (used[i] == true) continue; // path里已经收录的元素，直接跳过\n            used[i] = true;\n            path.push_back(nums[i]);\n            backtracking(nums, used);\n            path.pop_back();\n            used[i] = false;\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        vector<bool> used(nums.size(), false);\n        backtracking(nums, used);\n        return result;\n    }\n};\n\n```\n\n* 时间复杂度: O(n!)\n* 空间复杂度: O(n)\n\n## 总结\n\n**大家此时可以感受出排列问题的不同：**\n\n* 每层都是从0开始搜索而不是startIndex\n* 需要used数组记录path里都放了哪些元素了\n\n> **这里建议 78.子集、90.子集II、39.组合总和、40.组合总和II、46全排列、47全排列II一块看，并进行总结**\n","tags":["leetcode"]},{"title":"90.子集II","url":"/2023/11/27/leetcode/回溯算法/90-子集II/","content":"# 题目描述\n\n给你一个整数数组 nums ，**其中可能包含重复元素**，请你返回该数组所有可能的子集（幂集）。\n\n**解集 不能 包含重复的子集**。返回的解集中，子集可以按 任意顺序 排列。\n\n``` cpp\n示例 1：\n\n输入：nums = [1,2,2]\n输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n示例 2：\n\n输入：nums = [0]\n输出：[[],[0]]\n \n\n提示：\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\n```\n\n## 三部曲\n\n* 递归参数\n\n因为数组中包含重复元素，并且要求解集不能包含重复的子集，所以要用used来进行去重。如下图所示:\n\n![s](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124195411977.png)\n\n``` cpp\n    vector<int> path;\n    vector<vector<int>> result;\n    void backtracking(vector<int>& nums, int startIndex,vector<bool> used)\n```\n\n* 递归终止条件\n\n``` cpp\nif (startIndex >= nums.size()) {\n    return;\n}\n```\n\n* 单层搜索逻辑\n\n``` cpp\n        for(int i = startIndex; i < nums.size();++i){\n            if(i>0&& nums[i-1] == nums[i] && used[i-1] == false){\n                continue;\n            }\n            if(used[i] == false){\n                path.push_back(nums[i]);\n                used[i] = true;\n                backtracking(nums,i+1,used);\n                used[i] = false;\n                path.pop_back();\n            }\n        }\n```\n\n代码如下:\n\n```cpp\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {\n        result.push_back(path);\n        for (int i = startIndex; i < nums.size(); i++) {\n            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过\n            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过\n            // 而我们要对同一树层使用过的元素进行跳过\n            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {\n                continue;\n            }\n            path.push_back(nums[i]);\n            used[i] = true;\n            backtracking(nums, i + 1, used);\n            used[i] = false;\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        vector<bool> used(nums.size(), false);\n        sort(nums.begin(), nums.end()); // 去重需要排序\n        backtracking(nums, 0, used);\n        return result;\n    }\n};\n```\n\n## set去重\n\n``` cpp\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path);\n        unordered_set<int> uset;\n        for (int i = startIndex; i < nums.size(); i++) {\n            if (uset.find(nums[i]) != uset.end()) {\n                continue;\n            }\n            uset.insert(nums[i]);\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 去重需要排序\n        backtracking(nums, 0);\n        return result;\n    }\n};\n```\n\n* 时间复杂度: O(n * 2^n)\n* 空间复杂度: O(n)\n\n> **这里建议 78.子集、90.子集II、39.组合总和、40.组合总和II、46全排列、47全排列II一块看，并进行总结**\n","tags":["leetcode"]},{"title":"78.子集","url":"/2023/11/27/leetcode/回溯算法/78-子集/","content":"\n## 题目描述\n\n给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\n```cpp\n示例 1：\n\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n示例 2：\n\n输入：nums = [0]\n输出：[[],[0]]\n \n\n提示：\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\nnums 中的所有元素 互不相同\n```\n\n## 三部曲\n\n* 递归参数\n\n```cpp\nvector<vector<int>> result;\nvector<int> path;\nvoid backtracking(vector<int>& nums,int startIndex)\n```\n\n* 递归终止条件\n\n![s](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)\n\n剩余集合为空的时候，从上图中就可以看出\n\n那么什么时候剩余集合为空呢？\n\n就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了，代码如下:\n\n``` cpp\nif (startIndex >= nums.size()) {\n    return;\n}\n```\n\n**其实可以不需要加终止条件，因为startIndex >= nums.size()，本层for循环本来也结束了。**\n\n* 单层搜索逻辑\n\n**求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。**\n\n``` cpp\nfor (int i = startIndex; i < nums.size(); i++) {\n    path.push_back(nums[i]);    // 子集收集元素\n    backtracking(nums, i + 1);  // 注意从i+1开始，元素不重复取\n    path.pop_back();            // 回溯\n}\n```\n\n**这里要注意result存放时的位置，因为求的是子集，所以要放在if之前**\n\n``` cpp\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己\n        if (startIndex >= nums.size()) { // 终止条件可以不加\n            return;\n        }\n        for (int i = startIndex; i < nums.size(); i++) {\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        backtracking(nums, 0);\n        return result;\n    }\n};\n```\n\n* 时间复杂度: O(n * 2^n)\n* 空间复杂度: O(n)\n\n> **这里建议 78.子集、90.子集II、39.组合总和、40.组合总和II、46全排列、47全排列II一块看，并进行总结**\n","tags":["leetcode"]},{"title":"131.分割回文串","url":"/2023/11/25/leetcode/回溯算法/131-分割回文串/","content":"## 题目描述\n\n给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n\n回文串 是正着读和反着读都一样的字符串。\n\n``` cpp\n示例 1：\n\n输入：s = \"aab\"\n输出：[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n示例 2：\n\n输入：s = \"a\"\n输出：[[\"a\"]]\n \n\n提示：\n\n1 <= s.length <= 16\ns 仅由小写英文字母组成\n\n```\n\n* 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个.....。\n* 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段.....。\n\n所以切割问题，也可以抽象为一棵树形结构，如图：\n![s](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)\n递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。\n\n## 三部曲\n\n* 递归函数参数\n\n全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里）\n\n本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。\n\n**什么时候需要startIndex，什么时候不需要startIndex？**\n如果是一个集合来求组合的话，就需要startIndex，例如：77.组合 (opens new window)，216.组合总和III (opens new window)。\n\n如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：17.电话号码的字母组合\n\n```cpp\nvector<vector<string>> result;\nvector<string> path; // 放已经回文的子串\nvoid backtracking (const string& s, int startIndex);\n```\n\n* 递归函数终止条件\n\n![s](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)\n从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止条件。\n\n**那么在代码里什么是切割线呢？**\n\n在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。\n\n``` cpp\nvoid backtracking (const string& s, int startIndex) {\n    // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了\n    if (startIndex >= s.size()) {\n        result.push_back(path);\n        return;\n    }\n}\n```\n\n* 单层搜索的逻辑\n  \n**来看看在递归循环中如何截取子串呢？**\n\n在for (int i = startIndex; i < s.size(); i++)循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。\n\n首先判断这个子串是不是回文，如果是回文，就加入在`vector<string> path`中，path用来记录切割过的回文子串。\n\n**这里要注意: 切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1。**\n\n``` cpp\nfor (int i = startIndex; i < s.size(); i++) {\n    if (isPalindrome(s, startIndex, i)) { // 是回文子串\n        // 获取[startIndex,i]在s中的子串\n        string str = s.substr(startIndex, i - startIndex + 1);\n        path.push_back(str);\n    } else {                // 如果不是则直接跳过\n        continue;\n    }\n    backtracking(s, i + 1); // 寻找i+1为起始位置的子串\n    path.pop_back();        // 回溯过程，弹出本次已经添加的子串\n}\n```\n\n* 判断回文子串\n可以使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。\n\n``` cpp\nbool isPalindrome(const string& s, int start, int end) {\n     for (int i = start, j = end; i < j; i++, j--) {\n         if (s[i] != s[j]) {\n             return false;\n         }\n     }\n     return true;\n }\n```\n\n## substr\n\n**参数**\n\n* pos - 要包含的首个字符的位置\n* count - 子串的长度\n\n**返回值**\n含子串` [pos, pos + count) `或`[pos, size())` 的字符串。\n\n``` cpp\n#include <iostream>\n#include <string>\n \nint main()\n{\n    std::string a = \"0123456789abcdefghij\";\n \n    // count 是 npos，返回 [pos, size())\n    std::string sub1 = a.substr(10);\n    std::cout << sub1 << '\\n';\n \n    // pos 和 pos + count 都在边界内，返回 [pos, pos + count)\n    std::string sub2 = a.substr(5, 3);\n    std::cout << sub2 << '\\n';\n \n    // pos 在边界内，pos+count 不在，返回 [pos, size()) \n    std::string sub4 = a.substr(a.size() - 3, 50);\n    // 这等效于\n    // std::string sub4 = a.substr(17, 3);\n    // 因为 a.size() == 20，pos == a.size() - 3 == 17 而 a.size() - pos == 3\n \n    std::cout << sub4 << '\\n';\n \n    try\n    {\n        // pos 在边界外，抛出\n        std::string sub5 = a.substr(a.size()+3, 50);\n        std::cout << sub5 << '\\n';\n    }\n    catch(const std::out_of_range& e)\n    {\n        std::cout << \"pos 超出了字符串的大小\\n\";\n    }\n}\n```\n\n代码:\n\n``` cpp\nclass Solution {\n    vector<vector<string>> result;\n    vector<string> path;\n\n    void backtracking(const string& s,int startIndex){\n        if(startIndex >= s.size()){\n            result.push_back(path);\n            return;\n        }\n\n        for(int i = startIndex ; i< s.size();++i){\n            if(isPalindrome(s,startIndex,i)){\n                // 返回 substr 含子串 [pos, pos + count) 或 [pos, size()) 的字符串。 \n                string str = s.substr(startIndex,i - startIndex + 1); \n                path.push_back(str);\n            } else{\n                continue;\n            }\n            backtracking(s,i+1);\n            path.pop_back();\n        }\n    }\n\n    bool isPalindrome(const string &s,int start, int end){\n        for(int i =start,j = end;i<j;i++,j--){\n            if(s[i] != s[j]){\n                return false;\n            }\n        }\n        return true;\n    }\npublic:\n    vector<vector<string>> partition(string s) {\n        result.clear();\n        path.clear();\n        backtracking(s, 0);\n        return result;\n    }\n};\n```\n","tags":["leetcode"]},{"title":"40.组合总和II","url":"/2023/11/25/leetcode/回溯算法/40-组合总和II/","content":"## 题目描述\n\n给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用 一次 。\n\n注意：解集不能包含重复的组合。\n\n``` cpp\n示例 1:\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n输出:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n示例 2:\n\n输入: candidates = [2,5,2,1,2], target = 5,\n输出:\n[\n[1,2,2],\n[5]\n]\n \n\n提示:\n\n1 <= candidates.length <= 100\n1 <= candidates[i] <= 50\n1 <= target <= 30\n```\n\n## 三部曲\n\n* 递归函数参数\n\n  这个集合去重的重任就是used来完成的。\n  bool型数组used，用来记录同一树枝上的元素是否使用过。\n\n  ``` cpp\n  vector<vector<int>> result; // 存放组合集合\n  vector<int> path;           // 符合条件的组合\n  void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used);\n  ```\n\n* 递归终止条件\n\n  终止条件为` sum > target `和`sum == target。`\n\n  ``` cpp\n  if (sum > target) { // 这个条件其实可以省略\n      return;\n  }\n  if (sum == target) {\n      result.push_back(path);\n      return;\n  }\n  ```\n\n  `sum > target` 这个条件其实可以省略，因为在递归单层遍历的时候，会有剪枝的操作，下面会介绍到。\n\n* 单层搜索的逻辑\n  **如果candidates[i] == candidates[i - 1] 并且 used[i - 1] == false，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]。**\n  此时for循环里就应该做continue的操作。\n  ![s](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png)\n\n  可以看出candidates[i] == candidates[i - 1]相同的情况下：\n\n  * used[i - 1] == true，说明同一树枝candidates[i - 1]使用过\n  * used[i - 1] == false，说明同一树层candidates[i - 1]使用过\n\n单层搜索的逻辑代码如下：\n\n``` cpp\n    for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n    // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过\n    // used[i - 1] == false，说明同一树层candidates[i - 1]使用过\n    // 要对同一树层使用过的元素进行跳过\n    if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {\n        continue;\n    }\n    sum += candidates[i];\n    path.push_back(candidates[i]);\n    used[i] = true;\n    backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次\n    used[i] = false;\n    sum -= candidates[i];\n    path.pop_back();\n    }\n```\n\n  **注意sum + candidates[i] <= target为剪枝操作，在39.组合总和 (opens new window)有讲解过！**\n\n整体代码如下:\n\n``` cpp\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {\n        if (sum == target) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过\n            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过\n            // 要对同一树层使用过的元素进行跳过\n            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {\n                continue;\n            }\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            used[i] = true;\n            backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次\n            used[i] = false;\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<bool> used(candidates.size(), false);\n        path.clear();\n        result.clear();\n        // 首先把给candidates排序，让其相同的元素都挨在一起。\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0, 0, used);\n        return result;\n    }\n};\n\n```\n\n* 时间复杂度: O(n * 2^n)\n* 空间复杂度: O(n)\n\n> **这里建议 78.子集、90.子集II、39.组合总和、40.组合总和II、46全排列、47全排列II一块看，并进行总结**\n","tags":["leetcode"]},{"title":"17.电话号码组合","url":"/2023/11/25/leetcode/回溯算法/17-电话号码组合/","content":"## 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n``` cpp\n示例 1：\n\n输入：digits = \"23\"\n输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n示例 2：\n\n输入：digits = \"\"\n输出：[]\n示例 3：\n\n输入：digits = \"2\"\n输出：[\"a\",\"b\",\"c\"]\n \n\n提示：\n\n0 <= digits.length <= 4\ndigits[i] 是范围 ['2', '9'] 的一个数字。\n```\n\n## 三部曲\n\n* 递归函数的返回值以及参数\n\n  ``` cpp\n  void backtracking(const string& digits, int index);\n  ```\n\n  index 表示到那个数字了。\n\n* 回溯函数终止条件\n\n    字母的长度达到数字的长度，就返回。\n\n    ``` cpp\n    if(index == digits.size()){\n        result.push_back(s);\n        return;\n    }\n    ```\n\n* 单层搜索过程\n\n遍历当前数字所代表的所有的字母，\n\n``` cpp\n  int digit = digits[index] - '0';\n  string letters = letterMap[digit];\n  for(int i =0;i<letters.size();++i){\n      s.push_back(letters[i]);\n      backtracking(digits,index+1);\n      s.pop_back();\n  }\n```\n\n``` cpp\nclass Solution {\npublic:\n        const string letterMap[10] = {\n            \"\",\n            \"\",\n            \"abc\",\n            \"def\",\n            \"ghi\",\n            \"jkl\",\n            \"mno\",\n            \"pqrs\",\n            \"tuv\",\n            \"wxyz\",\n        };\n        vector<string> result;\n        string s;\n        void backtracking(const string& digits,int index){\n            if(index == digits.size()){\n                result.push_back(s);\n                return;\n            }\n            int digit = digits[index] - '0';\n            string letters = letterMap[digit];\n            for(int i =0;i<letters.size();++i){\n                s.push_back(letters[i]);\n                backtracking(digits,index+1);\n                s.pop_back();\n            }\n\n        }\n\n        vector<string> letterCombinations(string digits){\n            s.clear();\n            result.clear();\n            if(digits.size() == 0){\n                return result;\n            }\n            backtracking(digits,0);\n            return result;\n        }\n};\n```\n","tags":["leetcode"]},{"title":"39.组合总和","url":"/2023/11/25/leetcode/回溯算法/39-组合总和/","content":"## 题目描述\n\n给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n\n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n\n``` cpp\n示例 1：\n\n输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。\n示例 2：\n\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n示例 3：\n\n输入: candidates = [2], target = 1\n输出: []\n \n\n提示：\n\n1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\ncandidates 的所有元素 互不相同\n1 <= target <= 40\n```\n\n## 三部曲\n\n* 递归函数的返回值以及参数\n\n  * target（int）目标和。\n  * sum（int）为已经收集的元素的总和，也就是path里元素的总和。\n  * startIndex（int）为下一层for循环搜索的起始位置。，**startIndex 就是防止出现重复的组合。**\n\n  ``` cpp\n  vector<vector<int>> result; // 存放符合条件结果的集合\n  vector<int> path; // 用来存放符合条件结果\n  void backtracking(vector<int>& candidates,int target,int sum, int startIndex);\n  ```\n\n* 回溯函数终止条件\n  \n  `sum == target`   `sum > target`\n\n  ``` cpp\n    if (sum > target) {\n    return;\n    }\n    if(sum == target){\n        result.push_back(path);\n        return;\n    }\n  ```\n\n* 单层搜索过程\n\n  由于**同一个**数字可以**无限制重复选择**,这里递归时，为 i，而不是i+1。\n\n  ``` cpp\n    for(int i = startIndex;i < candidates.size();++i){\n      path.push_back(candidates[i]);\n      sum+=candidates[i];\n      backtracking(candidates,target,sum,i); // 可以重复读取相同的值\n      sum -= candidates[i];\n      path.pop_back();\n  }\n  ```\n\n## 实现\n\n  ``` cpp\n  class Solution {\n  public:\n  vector<vector<int>> result;\n          vector<int> path;\n          void backtracking(vector<int>& candidates,int target,int sum, int startIndex){\n              if(sum > target){\n                  return;\n              }\n              if(sum == target){\n                  result.push_back(path);\n                  return;\n              }\n              for(int i = startIndex;i < candidates.size();++i){\n                  path.push_back(candidates[i]);\n                  sum+=candidates[i];\n                  backtracking(candidates,target,sum,i); // 可以重复读取相同的值\n                  sum -= candidates[i];\n                  path.pop_back();\n              }\n          }\n      vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        result.clear();\n        path.clear();\n        sort(candidates.begin(),candidates.end());\n        backtracking(candidates,  target,0,0);\n        return result;\n      }\n  };\n  ```\n\n## 剪枝优化\n\n其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。\n\n**对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。**\n\nfor循环剪枝代码如下：\n\n``` cpp\nfor (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)\n```\n\n> **这里建议 78.子集、90.子集II、39.组合总和、40.组合总和II、46全排列、47全排列II一块看，并进行总结**","tags":["leetcode"]},{"title":"FFmpeg解码","url":"/2023/11/25/FFmpeg/FFmpegAPI/FFmpeg解码/","content":"\n## 解码流程\n\n## 解码的数据结构\n\n1. AVCodecContext，这个结构体可以是 编码器 的上下文，也可以是 解码器 的上下文，两者使用的是同一种数据结构。\n\n2. AVCodec，编解码信息。\n\n3. AVCodecParameters，编解码参数。\n\n4. AVPacket ，数据包（已编码压缩），这里面的数据通常是一帧视频的数据，或者一帧音频的数据。AVPacket 他本身是没有编码数据的，他只是管理编码数据。\n\n5. AVFrame ，解码之后的 YUV 数据。AVFrame 跟 AVPacket 类似，都是一个管理数据的结构体，他们本身是没有数据的，只是引用了数据。\n\n![Alt text](../../../images/FFmpeg/FFmpeg解码的数据结构.png)\n\n## 和解码相关的API函数\n\n1. avcodec_alloc_context3\n   * 通过传递 AVCodec 编解码信息来初始化上下文。\n\n2. avcodec_parameters_to_context\n   * 把流的 AVCodecParameters 里面的 编解码参数 复制到 AVCodecContext。\n\n3. avcodec_open2\n   * 打开一个编码器 或者 解码器。\n\n4. avcodec_is_open\n   * 判断 一个编码器 或者 解码器 是否打开\n\n5. avcodec_send_packet\n   * 往 AVCodecContext 解码器 发送一个 AVPacket 。\n\n6. avcodec_receive_frame\n   * 从 AVCodecContext 解码器 读取一个 AVFrame。\n\n---\n\n1. AVCodec 里面放的是 编解码信息 。\n\n2. AVCodecParameters 里面放的是 编解码参数。\n\n怎么理解 编解码信息 跟 编解码参数？\n\n通常 AVCodec 是使用 avcodec_find_decoder 函数找出来的，你给这个函数一个 AVCodecID，他就能返回一个解码器指针给你。这是 引入 FFmpeg 库的时候，他初始化了一堆静态的编解码变量给你。\n\n例如 AVCodecID 是 AV_CODEC_ID_H263 ，就会返回 263 相关的 AVCodec 指针， AVCodecID 是 AV_CODEC_ID_H264 ，就会返回 264 相关的 AVCodec 指针。\n\n只要是用 H264 编码 的视频，使用的**解码器信息**都是一样的，用的是同一个 AVCodec，但是不同的视频文件，宽高，采样这些信息，肯定会有点不一样。\n\n**这些不一样的东西放在哪里呢？** 就是 AVCodecParameters。\n\n当 avformat_open_input 函数打开一个 MP4 的时候，编码器参数就会放在 codecpar 字段里，如下：\n\n```cpp\nfmt_ctx->streams[0]->codecpar\n// 上面的 codecpar 就是一个 AVCodecParameters，只需要用 avcodec_parameters_to_context 函数把 codecpar 的参数复制给 AVCodecContext 即可，很方便。\n```\n\n带着问题读下面代码：\n\n1. 如何初始化 AVCodecContext ？\n2. 如何打开解码器 ？\n3. 如何往解码器发数据 ？\n4. 如何从解码器读取数据 ？\n\n## 示例代码\n\n``` cpp\n#include <stdio.h>\n#include \"libavformat/avformat.h\"\nint main()\n{\n    AVFormatContext *fmt_ctx = NULL;\n    int type = 1;\n    int ret = 0;\n\n    int err;\n    //提示，要把 juren-30s.mp4 文件放到 Debug 目录下才能找到。\n    char filename[] = \"juren-30s.mp4\";\n\n    fmt_ctx = avformat_alloc_context();\n    if (!fmt_ctx) {\n      printf(\"error code %d \\n\",AVERROR(ENOMEM));\n      return ENOMEM;\n    }\n\n    if((err = avformat_open_input(&fmt_ctx, filename,NULL,NULL)) < 0){\n        printf(\"can not open file %d \\n\",err);\n        return err;\n    }\n\n    if( 1 == type ){\n\n        //本文只初始化 视频解码器。音频解码器不管\n        AVCodecContext *avctx = avcodec_alloc_context3(NULL);\n        ret = avcodec_parameters_to_context(avctx, fmt_ctx->streams[0]->codecpar);\n        if (ret < 0){\n            printf(\"error code %d \\n\",ret);\n            return ret;\n        }\n\n        AVCodec *codec = avcodec_find_decoder(avctx->codec_id);\n        if ((ret = avcodec_open2(avctx, codec, NULL)) < 0) {\n            printf(\"open codec faile %d \\n\",ret);\n            return ret;\n        }\n\n        AVPacket *pkt = av_packet_alloc();\n        AVFrame *frame = av_frame_alloc();\n        int frame_num = 0;\n        int read_end = 0;\n        for(;;){\n            if( 1 == read_end ){\n                break;\n            }\n\n            ret = av_read_frame(fmt_ctx, pkt);\n            //跳过不处理音频包\n            if( 1 == pkt->stream_index ){\n                av_packet_unref(pkt);\n                continue;\n            }\n            if ( AVERROR_EOF == ret) {\n                //已经读完文件\n                //读取完文件，这时候 pkt 的 data 跟 size 应该是 null\n                //冲刷解码器\n                avcodec_send_packet(avctx, pkt);\n                //释放 pkt 里面的编码数据\n                av_packet_unref(pkt);\n\n                //循环不断从解码器读数据，直到没有数据可读。\n                for(;;){\n                    //读取 AVFrame\n                    ret = avcodec_receive_frame(avctx, frame);\n                    /* 释放 frame 里面的YUV数据，\n                     * 由于 avcodec_receive_frame 函数里面会调用 av_frame_unref，所以下面的代码可以注释。\n                     * 所以我们不需要 手动 unref 这个 AVFrame\n                     * */\n                    //av_frame_unref(frame);\n\n                    if( AVERROR(EAGAIN) == ret ){\n                        //提示 EAGAIN 代表 解码器 需要 更多的 AVPacket\n                        //跳出 第一层 for，让 解码器拿到更多的 AVPacket\n                        break;\n                    }else if( AVERROR_EOF == ret ){\n                        /* 提示 AVERROR_EOF 代表之前已经往 解码器发送了一个 data 跟 size 都是 NULL 的 AVPacket\n                         * 发送 NULL 的 AVPacket 是提示解码器把所有的缓存帧全都刷出来。\n                         * 通常只有在 读完输入文件才会发送 NULL 的 AVPacket，或者需要用现有的解码器解码另一个的视频流才会这么干。\n                         *\n                         * */\n\n                        //跳出 第二层 for，文件已经解码完毕。\n                        read_end = 1;\n                        break;\n                    }else if( ret >= 0 ){\n\n                        //解码出一帧 YUV 数据，打印一些信息。\n                        printf(\"decode success ----\\n\");\n                        printf(\"width : %d , height : %d \\n\",frame->width,frame->height);\n                        printf(\"pts : %I64d , duration : %I64d \\n\",frame->pts,frame->pkt_duration);\n                        printf(\"format : %d \\n\",frame->format);\n                        printf(\"key_frame : %d \\n\",frame->key_frame);\n                        printf(\"AVPictureType : %d \\n\",frame->pict_type);\n                        int num = av_image_get_buffer_size(AV_PIX_FMT_YUV420P, 1920, 1080, 1);\n                        printf(\"num : %d , \\n\",num);\n\n\n                    }else{\n                        printf(\"other fail \\n\");\n                        return ret;\n                    }\n                }\n\n            }else if( 0 == ret){\n                retry:\n                if (avcodec_send_packet(avctx, pkt) == AVERROR(EAGAIN)) {\n                    printf(\"Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\");\n                    //这里可以考虑休眠 0.1 秒，返回 EAGAIN 通常是 ffmpeg 的内部 api 有bug\n                    goto retry;\n                } else {\n                    //释放 pkt 里面的编码数据\n                    av_packet_unref(pkt);\n\n                    //循环不断从解码器读数据，直到没有数据可读。\n                    for(;;){\n                        //读取 AVFrame\n                        ret = avcodec_receive_frame(avctx, frame);\n                        /* 释放 frame 里面的YUV数据，\n                         * 由于 avcodec_receive_frame 函数里面会调用 av_frame_unref，所以下面的代码可以注释。\n                         * 所以我们不需要 手动 unref 这个 AVFrame\n                         * */\n                        //av_frame_unref(frame);\n\n                        if( AVERROR(EAGAIN) == ret ){\n                            //提示 EAGAIN 代表 解码器 需要 更多的 AVPacket\n                            //跳出 第一层 for，让 解码器拿到更多的 AVPacket\n                            break;\n                        }else if( AVERROR_EOF == ret ){\n                            /* 提示 AVERROR_EOF 代表之前已经往 解码器发送了一个 data 跟 size 都是 NULL 的 AVPacket\n                             * 发送 NULL 的 AVPacket 是提示解码器把所有的缓存帧全都刷出来。\n                             * 通常只有在 读完输入文件才会发送 NULL 的 AVPacket，或者需要用现有的解码器解码另一个的视频流才会这么干。\n                             *\n                             * */\n\n                            //跳出 第二层 for，文件已经解码完毕。\n                            read_end = 1;\n                            break;\n                        }else if( ret >= 0 ){\n\n                            //解码出一帧 YUV 数据，打印一些信息。\n                            printf(\"decode success ----\\n\");\n                            printf(\"width : %d , height : %d \\n\",frame->width,frame->height);\n                            printf(\"pts : %I64d , duration : %I64d \\n\",frame->pts,frame->pkt_duration);\n                            printf(\"format : %d \\n\",frame->format);\n                            printf(\"key_frame : %d \\n\",frame->key_frame);\n                            printf(\"AVPictureType : %d \\n\",frame->pict_type);\n                            int num = av_image_get_buffer_size(AV_PIX_FMT_YUV420P, 1920, 1080, 1);\n                            printf(\"num : %d , \\n\",num);\n\n                            //打印 yuv\n                            //printf(\" Y size : %d \\n\",frame->linesize[0]);\n                            //printf(\" U size : %d \\n\",frame->linesize[1]);\n                            //printf(\" V size : %d \\n\",frame->linesize[2]);\n\n\n                            /*\n                            //修改 yuv\n                            for(int tt=0; tt < 5 ;tt++){\n                                frame->data[0][tt] = 0xFF;\n                            }\n                            //拼接文件名\n                            char yuv_pic_name[200] = \"./yuv420p_\";\n                            char frame_num_str[10];\n                            itoa(frame_num, frame_num_str, 10);\n                            strcat(yuv_pic_name,frame_num_str);\n                            //写入文件\n                            FILE *fp = NULL;\n                            fp = fopen(yuv_pic_name, \"w+\");\n                            fwrite(frame->data[0] , 1, frame->width * frame->height, fp);\n                            fwrite(frame->data[1] , 1, frame->width/2 * frame->height/2, fp);\n                            fwrite(frame->data[2] , 1, frame->width/2 * frame->height/2, fp);\n                            fclose(fp);\n\n                            frame_num++;\n                            if( frame_num > 10 ){\n                                return 99;\n                            }\n                            */\n\n\n                        }else{\n                            printf(\"other fail \\n\");\n                            return ret;\n                        }\n                    }\n                }\n\n            }\n        }\n\n        av_frame_free(&frame);\n        av_packet_free(&pkt);\n\n        //释放解码器上下文。\n        avcodec_free_context(&avctx);\n\n        avformat_close_input(&fmt_ctx);\n\n    }\n\n\n    return 0;\n}\n```\n\n## avformat_alloc_context\n\n函数原型如下:\n\n用于分配并初始化一个AVFormatContext结构体，该结构体用于音视频格式的输入和输出。\n\n``` cpp\nAVFormatContext *avformat_alloc_context(void);\n```\n\n在音视频处理中，不同的音视频文件或流可能采用不同的格式，如MP4、AVI、FLV等。AVFormatContext结构体用于管理和表示这些不同格式的音视频数据。\n调用avformat_alloc_context函数将会返回一个指向AVFormatContext结构体的指针，该结构体已经被分配和初始化。\n\nAVFormatContext结构体包含了音视频格式相关的信息，包括输入输出的文件名、音视频流的信息、封装格式的参数等。通过操作AVFormatContext结构体，可以进行音视频的读取、写入和处理操作。\n\n需要注意的是，使用完AVFormatContext结构体后，需要调用avformat_free_context函数来释放相关的资源。\n\n## avformat_open_input\n\n用于打开音视频文件或流，并将其与一个AVFormatContext结构体关联起来，以便后续的音视频处理操作。\n集体细节见--->FFmpegAPI学习---avformat_open_input\n\n## avcodec_alloc_context3\n\n用于分配并初始化一个`AVCodecContext`结构体，该结构体用于音视频编解码的参数设置和状态管理。\n\n在音视频编解码过程中，`AVCodecContext`结构体用于保存编解码器的相关参数，如编码器类型、音视频流的格式、编码参数、解码参数等。通过对`AVCodecContext`结构体的设置，可以进行编解码的配置和控制。\n\n``` cpp\nAVCodecContext *avcodec_alloc_context3(const AVCodec *codec);\n```\n\n参数解释：\n`codec`：要使用的编解码器。可以通过调用`avcodec_find_decoder`或`avcodec_find_encoder`等函数来获取。\n\n**如果将avcodec_alloc_context3函数的参数codec设置为NULL**，则函数将只分配一个空的`AVCodecContext`结构体，而不会将其与特定的编解码器相关联。\n在这种情况下，你需要手动设置`AVCodecContext`结构体的参数和配置，包括编码器类型、音视频流的格式、编码参数、解码参数等。通常情况下，你可以通过其他方式获取编解码器的信息，并通过`avcodec_parameters_to_context`函数将相关参数填充到`AVCodecContext`结构体中。\n\n调用`avcodec_alloc_context3`函数将会返回一个指向`AVCodecContext`结构体的指针，该结构体已经被分配和初始化。\n\n## avcodec_parameters_to_context\n\n用于将AVCodecParameters结构体中的参数值复制到AVCodecContext结构体中，以便进行音视频编解码的配置。\n\n在音视频处理中，AVCodecParameters结构体用于保存音视频流的参数信息，如编解码器类型、音视频流的格式、编码参数、解码参数等。而AVCodecContext结构体用于实际的编解码操作。\n\n函数原型如下:\n\n```cpp\nint avcodec_parameters_to_context(AVCodecContext *codec, const AVCodecParameters *par);\n```\n\n参数解释：\n\n* codec：要配置的AVCodecContext结构体指针。\n* par：包含参数信息的AVCodecParameters结构体指针。\n\n调用avcodec_parameters_to_context函数会将AVCodecParameters结构体中的参数值复制到AVCodecContext结构体中，从而实现参数的配置。\n\n## av_packet_alloc\n\n用于分配并初始化一个AVPacket结构体，该结构体用于存储音视频数据包。这里面的数据通常是一帧视频的数据\n\n音视频数据在处理过程中通常以数据包的形式进行传输和处理，AVPacket结构体用于表示和管理这些数据包。\n\n函数原型如下:\n\n``` cpp\nAVPacket *av_packet_alloc(void);\n```\n\n调用av_packet_alloc函数将会返回一个指向AVPacket结构体的指针，该结构体已经被分配和初始化。\n\n通过调用av_packet_alloc函数，可以方便地创建一个用于存储音视频数据包的AVPacket结构体。在使用完AVPacket结构体后，应该调用av_packet_free函数来释放相关的资源。\n\n需要注意的是，AVPacket结构体并不负责音视频数据的内存管理，它只是用于存储数据包的相关信息（如数据指针、大小、时间戳等）。**实际的音视频数据存储在AVPacket结构体的data成员中**，你可能需要额外的内存管理操作来分配和释放音视频数据的存储空间。\n\n## av_frame_alloc\n\n用于分配并初始化一个AVFrame结构体，该结构体用于存储音视频帧数据。\n\n音视频数据在处理过程中通常以帧的形式进行传输和处理，AVFrame结构体用于表示和管理这些帧数据。\n\n函数原型如下:\n\n``` cpp\nAVFrame *av_frame_alloc(void);\n```\n\n调用av_frame_alloc函数将会返回一个指向AVFrame结构体的指针，该结构体已经被分配和初始化。\n\n通过调用av_frame_alloc函数，可以方便地创建一个用于存储音视频帧数据的AVFrame结构体。在使用完AVFrame结构体后，**应该调用av_frame_free函数来释放相关的资源。**\n\n需要注意的是，AVFrame结构体并不负责音视频帧数据的内存管理，它只是用于存储帧数据的相关信息（如数据指针、宽度、高度、格式等）。**实际的音视频帧数据存储在AVFrame结构体的各个平面（planes）中**，你可能需要额外的内存管理操作来分配和释放音视频帧数据的存储空间。\n\n## av_read_frame\n\n用于从输入媒体文件中读取音视频数据帧。\n\n函数原型如下:\n\n``` cpp\nint av_read_frame(AVFormatContext *formatContext, AVPacket *packet);\n```\n\n参数解释:\n\n* formatContext：指向AVFormatContext结构体的指针，表示输入媒体文件的上下文。\n* packet：指向AVPacket结构体的指针，用于存储读取到的音视频数据帧。\n\n返回值:\n\n* 如果返回值为0，表示成功读取了一帧音视频数据。\n* AVERROR_EOF (-542398533)：表示已达到输入媒体文件的结束，没有更多的音视频数据可供读取。\n* AVERROR(EAGAIN) (-11)：表示当前没有音视频数据可用，可以稍后再尝试读取。\n* 其他负数值：表示发生了其他类型的错误，可以使用av_strerror函数将其转换为对应的错误信息。\n\n调用av_read_frame函数可以从输入媒体文件中读取下一个音视频数据帧，并将其存储在AVPacket结构体中。\n\n在使用av_read_frame函数之前，需要确保已经打开输入媒体文件并获取了流信息。然后，在循环中调用av_read_frame函数可以连续读取音视频数据帧，直到读取完毕或发生错误。每次读取后，可以对读取到的音视频数据帧进行进一步的处理。最后，需要释放音视频数据包的资源，包括调用av_packet_unref函数释放AVPacket结构体中的资源，并在完成后释放AVPacket结构体本身的内存。\n\n## avcodec_send_packet\n\n用于向解码器发送音视频数据包进行解码。\n函数原型如下:\n\n``` cpp\nint avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt);\n```\n\n参数解释：\n\n* avctx：指向AVCodecContext结构体的指针，表示解码器的上下文。\n* avpkt：指向AVPacket结构体的指针，表示待解码的音视频数据包。\n\n调用avcodec_send_packet函数将待解码的音视频数据包发送给解码器进行解码操作。\n\n## 解码的数据存放在哪里了?\n\n**解码后的数据存放在解码器的输出缓冲区中，通常是AVFrame结构体中的成员变量。**\n\n**在解码中，AVFrame 是解码器的输出；在编码中，AVFrame 是编码器的输入。**\nAVFrame结构体定义了存储解码后音视频帧数据的格式和信息，包括音频样本、视频像素数据等。具体的成员变量取决于解码后的数据类型，例如：\n\n* 对于音频解码，解码后的音频样本数据存储在AVFrame的data数组中，可以通过AVFrame.data[0]获取音频样本数据的指针。\n* 对于视频解码，解码后的视频像素数据存储在AVFrame的data数组中，可以通过AVFrame.data[0]、AVFrame.data[1]、AVFrame.data[2]等获取不同颜色通道的像素数据指针。\n此外，AVFrame结构体还包含了音频采样率、声道数、视频宽度、高度、像素格式等信息，可以通过相应的成员变量获取。\n\n> todo AVFrame\n\n## avcodec_receive_frame\n\n用于从解码器接收解码后的音视频帧数据。\n\n函数的原型如下：\n\n``` cpp\nint avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame);\n```\n\n参数解释：\n\n* avctx：指向AVCodecContext结构体的指针，表示解码器的上下文。\n* frame：指向AVFrame结构体的指针，用于接收解码后的音视频帧数据。\n\n调用avcodec_receive_frame函数可以从解码器中获取解码后的音视频帧数据。\n\n## av_image_get_buffer_size\n\n用于计算给定图像参数的图像数据缓冲区大小。\n\n函数的原型如下：\n\n``` cpp\nint av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align);\n```\n\n参数解释：\n\n* pix_fmt：表示图像的像素格式，使用enum AVPixelFormat类型。\n* width：图像的宽度。\n* height：图像的高度。\n* align：指定图像数据的对齐方式（以字节为单位），通常为1。\n\n调用av_image_get_buffer_size函数可以根据图像的像素格式、宽度、高度和对齐方式，计算出所需的图像数据缓冲区大小。\n\n`int num = av_image_get_buffer_size(AV_PIX_FMT_YUV420P, 1920, 1080, 1);`\n在示例代码中，我们指定了图像的像素格式（YUV420P），宽度（1920）和高度（1080），并将对齐方式设置为1。然后调用av_image_get_buffer_size函数计算出所需的图像数据缓冲区大小，并打印结果。\n\n需要注意的是，av_image_get_buffer_size函数只计算图像数据缓冲区的大小，不会分配实际的内存。你可以使用计算出的缓冲区大小来分配足够大小的内存，用于存储图像数据。\n\n此外，图像的像素格式和对齐方式对图像数据缓冲区大小的计算影响很大。不同的像素格式和对齐方式可能导致不同的缓冲区大小，因此确保提供正确的参数以获得准确的缓冲区大小。\n","tags":["FFmpeg"],"categories":["FFmpeg"]},{"title":"FFmpeg编码","url":"/2023/11/25/FFmpeg/FFmpegAPI/FFmpeg编码/","content":"## 编码\n\n用于打开音视频编解码器并初始化相关的数据结构。它的功能是根据指定的编解码器参数，打开对应的音视频编解码器，并为后续的音视频解码或编码操作做准备。\n\n具体而言，avcodec_open2 函数会根据传入的AVCodecContext 结构体中的参数，选择并打开对应的音视频编解码器。这些参数包括编解码器的ID、解码器选项、输入/输出格式等。函数会检查是否成功打开编解码器，并将编解码器的上下文信息填充到AVCodecContext 结构体中，以供后续的音视频处理使用。\n\n通过调用avcodec_open2 函数，你可以初始化音视频编解码器并准备进行音视频解码或编码操作。在成功打开编解码器后，你可以使用相应的函数来解码媒体文件中的音视频数据或对音视频数据进行编码。\n\n需要注意的是，avcodec_open2 函数需要在调用avformat_find_stream_info 函数之后进行，以确保在打开编解码器之前已经获取了音视频流的相关参数。\n\n## 和编码相关的数据结构\n\n1. AVCodecContext，这个结构体可以是 编码器 的上下文，也可以是 解码器 的上下文，两者使用的是同一种数据结构。\n\n2. AVCodec，编解码信息。\n\n3. AVCodecParameters，编解码参数。\n\n4. AVPacket ， YUV经过编码压缩之后的数据，在 《AVPacket结构体使用介绍》有介绍。\n\n5. AVFrame ，解码之后的 YUV 数据。AVFrame 跟 AVPacket 类似，都是一个管理数据的结构体，他们本身是没有数据的，只是引用了数据\n\n## 编码相关的API函数如下\n\n1. avcodec_alloc_context3，通过传递 AVCodec 编解码信息来初始化上下文。\n\n2. avcodec_open2，打开一个编码器 或者 解码器。\n\n3. avcodec_is_open，判断 一个编码器 或者 解码器 是否打开\n\n4. avcodec_send_frame，往 AVCodecContext 编码器 发送一个 AVFrame。\n\n5. avcodec_receive_packet，从 AVCodecContext 编码器 读取一个 AVPacket。\n\n## avcodec_find_decoder\n\n用于根据编解码器ID或名称查找对应的解码器\n函数原型如下：\n\n``` cpp\nAVCodec *avcodec_find_decoder(enum AVCodecID id);\n```\n\n参数 id 是要查找的解码器的ID，它是一个枚举类型 enum AVCodecID。你可以根据需要提供不同的解码器ID来查找对应的解码器。\n以下是一些常见的解码器ID的示例：\n\n``` cpp\nAV_CODEC_ID_H264  // H.264解码器\nAV_CODEC_ID_HEVC  // H.265/HEVC解码器\nAV_CODEC_ID_MP3   // MP3解码器\nAV_CODEC_ID_AAC   // AAC解码器\n// 其他解码器ID...\n```\n\n## avcodec_send_frame\n\n用于将待解码的音视频帧发送给解码器进行解码。\n函数原型如下：\n\n``` cpp\nint avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame);\n```\n\n参数 avctx 是已打开的解码器上下文（AVCodecContext）的指针，它包含了解码器的相关配置和状态信息。\n\n参数 frame 是待解码的音视频帧的指针，它是一个 AVFrame 结构体。AVFrame 结构体中包含了音视频帧的数据、格式和其他属性。\n\n函数返回一个整数值，表示操作的结果。返回值大于等于0表示成功，返回值小于0表示出现错误或结束。\n\n## avcodec_receive_packet\n\n用于从解码器中接收解码后的音视频数据包（packet）。\n函数原型如下：\n\n``` cpp\nint avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt);\n```\n\n参数 avctx 是已打开的解码器上下文（AVCodecContext）的指针，它包含了解码器的相关配置和状态信息。\n\n参数 avpkt 是用于接收解码后数据包的 AVPacket 结构体指针。AVPacket 结构体中包含了解码后的音视频数据。\n\n函数返回一个整数值，表示操作的结果。返回值大于等于0表示成功，返回值小于0表示出现错误或结束。当返回值为负数时，可能是由于解码器已经输出了所有可用的数据包或者出现了解码错误\n\n## avcodec_find_encoder\n\n用于根据编码器ID或名称查找对应的编码器。\n\n函数原型如下:\n\n``` cpp\nAVCodec *avcodec_find_encoder(enum AVCodecID id);\n```\n\n参数 id 是要查找的编码器的ID，它是一个枚举类型 enum AVCodecID。你可以根据需要提供不同的编码器ID来查找对应的编码器。\n\n## avcodec_open2\n\n用于打开编解码器上下文（AVCodecContext）并进行初始化\n函数原型如下：\n\n``` cpp\nint avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);\n```\n\n参数 avctx 是要打开的编解码器上下文（AVCodecContext）的指针，它包含了编解码器的相关配置和状态信息。\n\n参数 codec 是要使用的编解码器（AVCodec）的指针，可以通过 avcodec_find_encoder 或 avcodec_find_decoder 函数获得。\n\n参数 options 是一个指向选项字典（AVDictionary）的指针，用于传递额外的选项给编解码器。可以设置为 NULL，表示不传递任何选项。\n\n函数返回一个整数值，表示操作的结果。返回值为0表示成功，返回值小于0表示出现错误。\n\n---\n\n示例代码:\n此代码逻辑是把这些 YUV 数据重新编码压缩成 H264，生成 AVPacket。\n\n```cpp\nint main()\n{\n\n    int ret = 0; int err;\n    //打开输入文件\n    char filename[] = \"juren-30s.mp4\";\n    AVFormatContext *fmt_ctx = avformat_alloc_context();\n    if (!fmt_ctx) {\n        printf(\"error code %d \\n\",AVERROR(ENOMEM));\n        return ENOMEM;\n    }\n    if((err = avformat_open_input(&fmt_ctx, filename,NULL,NULL)) < 0){\n        printf(\"can not open file %d \\n\",err);\n        return err;\n    }\n\n    //打开解码器\n    AVCodecContext *avctx = avcodec_alloc_context3(NULL);\n    ret = avcodec_parameters_to_context(avctx, fmt_ctx->streams[0]->codecpar);\n    if (ret < 0){\n        printf(\"error code %d \\n\",ret);\n        return ret;\n    }\n    AVCodec *codec = avcodec_find_decoder(avctx->codec_id);\n    if ((ret = avcodec_open2(avctx, codec, NULL)) < 0) {\n        printf(\"open codec faile %d \\n\",ret);\n        return ret;\n    }\n\n\n    AVCodecContext *enc_ctx = NULL;\n    AVPacket *pkt = av_packet_alloc();\n    AVFrame  *frame = av_frame_alloc();\n    AVPacket *pkt_out = av_packet_alloc();\n\n    int frame_num = 0;\n    int read_end = 0;\n    for(;;){\n        if( 1 == read_end ){\n            break;\n        }\n\n        ret = av_read_frame(fmt_ctx, pkt);\n        //跳过不处理音频包\n        if( 1 == pkt->stream_index ){\n            av_packet_unref(pkt);\n            continue;\n        }\n\n        if ( AVERROR_EOF == ret) {\n            //读取完文件，这时候 pkt 的 data 跟 size 应该是 null\n            avcodec_send_packet(avctx, NULL);\n        }else {\n            if( 0 != ret){\n                printf(\"read error code %d \\n\",ret);\n                return ENOMEM;\n            }else{\n                retry:\n                if (avcodec_send_packet(avctx, pkt) == AVERROR(EAGAIN)) {\n                    printf(\"Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\");\n                    //这里可以考虑休眠 0.1 秒，返回 EAGAIN 通常是 ffmpeg 的内部 api 有bug\n                    goto retry;\n                }\n                //释放 pkt 里面的编码数据\n                av_packet_unref(pkt);\n            }\n        }\n\n        //循环不断从解码器读数据，直到没有数据可读。\n        for(;;){\n            //读取 AVFrame\n            ret = avcodec_receive_frame(avctx, frame);\n            /* 释放 frame 里面的YUV数据，\n             * 由于 avcodec_receive_frame 函数里面会调用 av_frame_unref，所以下面的代码可以注释。\n             * 所以我们不需要 手动 unref 这个 AVFrame\n             * */\n            //av_frame_unref(frame);\n\n            if( AVERROR(EAGAIN) == ret ){\n                //提示 EAGAIN 代表 解码器 需要 更多的 AVPacket\n                //跳出 第一层 for，让 解码器拿到更多的 AVPacket\n                break;\n            }else if( AVERROR_EOF == ret ){\n                /* 提示 AVERROR_EOF 代表之前已经往 解码器发送了一个 data 跟 size 都是 NULL 的 AVPacket\n                 * 发送 NULL 的 AVPacket 是提示解码器把所有的缓存帧全都刷出来。\n                 * 通常只有在 读完输入文件才会发送 NULL 的 AVPacket，或者需要用现有的解码器解码另一个的视频流才会这么干。\n                 *\n                 * */\n\n                /* 往编码器发送 null 的 AVFrame，让编码器把剩下的数据刷出来。\n                 * */\n                ret = avcodec_send_frame(enc_ctx, NULL);\n                for(;;){\n                    ret = avcodec_receive_packet(enc_ctx, pkt_out);\n                    //这里不可能返回 EAGAIN，如果有直接退出。\n                    if (ret == AVERROR(EAGAIN)){\n                        printf(\"avcodec_receive_packet error code %d \\n\",ret);\n                        return ret;\n                    }\n                    if ( AVERROR_EOF == ret ){\n                       break;\n                    }\n                    //编码出 AVPacket ，打印一些信息\n                    printf(\"pkt_out size : %d \\n\",pkt_out->size);\n                }\n\n                //跳出 第二层 for，编码结束了。\n                read_end = 1;\n                break;\n            }else if( ret >= 0 ){\n                //只有解码出来一个帧，才可以开始初始化编码器。\n                if( NULL == enc_ctx ){\n                    //打开编码器，并且设置 编码信息。\n                    AVCodec *encode = avcodec_find_encoder(AV_CODEC_ID_H264);\n                    enc_ctx = avcodec_alloc_context3(encode);\n                    enc_ctx->codec_type = AVMEDIA_TYPE_VIDEO;\n                    enc_ctx->bit_rate = 400000;\n                    enc_ctx->framerate = avctx->framerate;\n                    enc_ctx->gop_size = 10;\n                    enc_ctx->max_b_frames = 5;\n                    enc_ctx->profile = FF_PROFILE_H264_MAIN;\n                    /*\n                     * 其实下面这些信息在容器那里也有，也可以一开始直接在容器那里打开编码器\n                     * 我从 AVFrame 里拿这些编码器参数是因为，容器的信息不一样就是最终的信息。\n                     * 因为你解码出来的 AVFrame 可能会经过 filter 滤镜，经过滤镜之后信息就会变化，但是本文没有使用滤镜。\n                     */\n                    //编码器的时间基要取 AVFrame 的时间基，因为 AVFrame 是输入。\n                    enc_ctx->time_base = fmt_ctx->streams[0]->time_base;\n                    enc_ctx->width = fmt_ctx->streams[0]->codecpar->width;\n                    enc_ctx->height = fmt_ctx->streams[0]->codecpar->height;\n                    enc_ctx->sample_aspect_ratio = frame->sample_aspect_ratio;\n                    enc_ctx->pix_fmt = frame->format;\n                    enc_ctx->color_range            = frame->color_range;\n                    enc_ctx->color_primaries        = frame->color_primaries;\n                    enc_ctx->color_trc              = frame->color_trc;\n                    enc_ctx->colorspace             = frame->colorspace;\n                    enc_ctx->chroma_sample_location = frame->chroma_location;\n\n                    /* 注意，这个 field_order 不同的视频的值是不一样的，这里我写死了。\n                     * 因为 本文的视频就是 AV_FIELD_PROGRESSIVE\n                     * 生产环境要对不同的视频做处理的\n                     */\n                    enc_ctx->field_order = AV_FIELD_PROGRESSIVE;\n\n                    if ((ret = avcodec_open2(enc_ctx, encode, NULL)) < 0) {\n                        printf(\"open codec faile %d \\n\",ret);\n                        return ret;\n                    }\n                }\n\n                //往编码器发送 AVFrame，然后不断读取 AVPacket\n                ret = avcodec_send_frame(enc_ctx, frame);\n                if (ret < 0) {\n                    printf(\"avcodec_send_frame fail %d \\n\",ret);\n                    return ret;\n                }\n                for(;;){\n                    ret = avcodec_receive_packet(enc_ctx, pkt_out);\n                    if (ret == AVERROR(EAGAIN)){\n                        break;\n                    }\n                    //前面没有往 编码器发 NULL,所以正常情况 ret 不会小于 0\n                    if (ret < 0){\n                        printf(\"avcodec_receive_packet fail %d \\n\",ret);\n                        return ret;\n                    }\n                    //编码出 AVPacket，打印一些信息。\n                    printf(\"pkt_out size : %d \\n\",pkt_out->size);\n\n                    av_packet_unref(pkt_out);\n                }\n\n\n            }else{\n                printf(\"other fail \\n\");\n                return ret;\n            }\n        }\n\n\n    }\n\n    av_frame_free(&frame);\n    av_packet_free(&pkt);\n    av_packet_free(&pkt_out);\n\n    //关闭编码器，解码器。\n    avcodec_close(avctx);\n    avcodec_close(enc_ctx);\n\n    //释放容器内存。\n    avformat_free_context(fmt_ctx);\n    printf(\"done \\n\");\n\n    return 0;\n}\n```\n\n下面是打开一个编码器的流程，打开编码器的代码量明显比打开解码器要多，这是因为打开解码器可以调 `avcodec_parameters_to_context` 把流的宽高等信息直接复制到 `AVCodecContext。`\n\n而编码器，需要从 `AVFrame` 里面提取宽高，像素格式这些东西。宽高，像素之类的信息，我看到好像在打开文件的时候也能获取到，不需要解码出 `AVFrame。`\n\n但是有一种情况，就是 有可能会使用滤镜，例如裁剪滤镜，这样宽高等信息就变了，所以最好是用 AVFrame 的信息来设置编码器。\n\n打开编码器跟打开解码器有以下不同的地方：\n\n1. 解码器没有设置 time_base （时间基），编码器需要设置时间基。为什么要设置，我也不知道，反正设置了不会有问题。\n2. sample_aspect_ratio ，这个可以理解为像素的宽高比，现在通常是 1:1，但有些电视是矩形像素，不是正方形。\n\n``` cpp\n  //只有解码出来一个帧，才可以开始初始化编码器。\n                if( NULL == enc_ctx ){\n                    //打开编码器，并且设置 编码信息。\n                    AVCodec *encode = avcodec_find_encoder(AV_CODEC_ID_H264);\n                    enc_ctx = avcodec_alloc_context3(encode);\n                    enc_ctx->codec_type = AVMEDIA_TYPE_VIDEO;\n                    enc_ctx->bit_rate = 400000;\n                    enc_ctx->framerate = avctx->framerate;\n                    enc_ctx->gop_size = 10;\n                    enc_ctx->max_b_frames = 5;\n                    enc_ctx->profile = FF_PROFILE_H264_MAIN;\n                    /*\n                     * 其实下面这些信息在容器那里也有，也可以一开始直接在容器那里打开编码器\n                     * 我从 AVFrame 里拿这些编码器参数是因为，容器的信息不一样就是最终的信息。\n                     * 因为你解码出来的 AVFrame 可能会经过 filter 滤镜，经过滤镜之后信息就会变化，但是本文没有使用滤镜。\n                     */\n                    //编码器的时间基要取 AVFrame 的时间基，因为 AVFrame 是输入。\n                    enc_ctx->time_base = fmt_ctx->streams[0]->time_base;\n                    enc_ctx->width = fmt_ctx->streams[0]->codecpar->width;\n                    enc_ctx->height = fmt_ctx->streams[0]->codecpar->height;\n                    enc_ctx->sample_aspect_ratio = frame->sample_aspect_ratio;\n                    enc_ctx->pix_fmt = frame->format;\n                    enc_ctx->color_range            = frame->color_range;\n                    enc_ctx->color_primaries        = frame->color_primaries;\n                    enc_ctx->color_trc              = frame->color_trc;\n                    enc_ctx->colorspace             = frame->colorspace;\n                    enc_ctx->chroma_sample_location = frame->chroma_location;\n\n                    /* 注意，这个 field_order 不同的视频的值是不一样的，这里我写死了。\n                     * 因为 本文的视频就是 AV_FIELD_PROGRESSIVE\n                     * 生产环境要对不同的视频做处理的\n                     */\n                    enc_ctx->field_order = AV_FIELD_PROGRESSIVE;\n\n                    if ((ret = avcodec_open2(enc_ctx, encode, NULL)) < 0) {\n                        printf(\"open codec faile %d \\n\",ret);\n                        return ret;\n                    }\n                }\n```\n\n下面是往编码器发数据跟收数据的代码，如下：\n其实编码过程跟解码过程是类似，发了一个 AVFrame 后，需要循环不断读取 AVPacket 直到返回 EAGAIN 。\n\n``` cpp\n    //往编码器发送 AVFrame，然后不断读取 AVPacket\n                ret = avcodec_send_frame(enc_ctx, frame);\n                if (ret < 0) {\n                    printf(\"avcodec_send_frame fail %d \\n\",ret);\n                    return ret;\n                }\n                for(;;){\n                    ret = avcodec_receive_packet(enc_ctx, pkt_out);\n                    if (ret == AVERROR(EAGAIN)){\n                        break;\n                    }\n                    //前面没有往 编码器发 NULL,所以正常情况 ret 不会小于 0\n                    if (ret < 0){\n                        printf(\"avcodec_receive_packet fail %d \\n\",ret);\n                        return ret;\n                    }\n                    //编码出 AVPacket，打印一些信息。\n                    printf(\"pkt_out size : %d \\n\",pkt_out->size);\n\n                    av_packet_unref(pkt_out);\n                }\n\n```\n\n当读到末尾的时候，也需要往编码器发送一个NULL，告诉编码器没有更多的 AVFrame 输入了，这样编码器内部就知道已经没有更多的输入了，只要把剩下的 AVPacket 全部刷出去，刷完就会返回 AVERROR_EOF\n\n``` cpp\n   }else if( AVERROR_EOF == ret ){\n       /* 提示 AVERROR_EOF 代表之前已经往 解码器发送了一个 data 跟 size 都是 NULL 的 AVPacket\n        * 发送 NULL 的 AVPacket 是提示解码器把所有的缓存帧全都刷出来。\n        * 通常只有在 读完输入文件才会发送 NULL 的 AVPacket，或者需要用现有的解码器解码另一个的视频流才会这么干。\n        *\n        * */\n\n       /* 往编码器发送 null 的 AVFrame，让编码器把剩下的数据刷出来。\n        * */\n       ret = avcodec_send_frame(enc_ctx, NULL);\n       for(;;){\n           ret = avcodec_receive_packet(enc_ctx, pkt_out);\n           //这里不可能返回 EAGAIN，如果有直接退出。\n           if (ret == AVERROR(EAGAIN)){\n               printf(\"avcodec_receive_packet error code %d \\n\",ret);\n               return ret;\n           }\n           if ( AVERROR_EOF == ret ){\n              break;\n           }\n           //编码出 AVPacket ，打印一些信息\n           printf(\"pkt_out size : %d \\n\",pkt_out->size);\n       }\n\n       //跳出 第二层 for，编码结束了。\n       read_end = 1;\n       break;\n```\n","tags":["FFmpeg"],"categories":["FFmpeg"]},{"title":"设置解复用器(demuxer)参数","url":"/2023/11/20/FFmpeg/FFmpegAPI/设置解复用器-demuxer-参数/","content":"\n解复用器 （demuxer）的参数 分为 通用部分 跟 私有部分。通用部分是指所有文件格式都有的属性，例如 formatprobesize 是 MP4 跟 FLV都有的属性。而 export_all 是只有 MP4 自己才有的属性。\n\n通用部分的参数可以通过以下命令来查看：\n\n``` cpp\nffmpeg -h > t.txt\n```\n\n私有部分的参数可以通过指定 解复用器来查看：\n\n```cpp\nffmpeg -hide_banner 1 -h demuxer=mp4\n```\n\n无论是通用还是私有属性，都是使用 `AVDictionary` 来设置 `demuxer` 的属性的，就是最后一个参数 `AVDictionary **options`，如下:\n\n``` cpp\nint avformat_open_input(AVFormatContext **ps, const char *url, ff_const59 AVInputFormat *fmt, AVDictionary **options);\n```\n\n可能会疑惑，设置复用器的属性，直接设置他的字段不就行了，为什么要搞一个 `AVDictionary` 出来。因为 FFmpeg 社区有大量的命令行用户，他们习惯通过 字符串传参 来 设置 复用器，解码器等等的属性。有些用户是不会写 C/C++ 代码的。\n\n`AVDictionary` 这个结构就是为了 命令行的字符串传参 这个需求而设计出来的，它的定义如下：\n\n``` cpp\nstruct AVDictionary {\n    int count;\n    AVDictionaryEntry *elems;\n};\n```\n\n```cpp\ntypedef struct AVDictionaryEntry {\n    char *key;\n    char *value;\n} AVDictionaryEntry;\n```\n\nAVDictionary 就是一个列表，里面存储着多个 AVDictionaryEntry，而 AVDictionaryEntry 是一个 key value 的结构体。\n\n下面就来演示一下如何用 AVDictionary 来设置 MP4 解复用器的属性\n\n``` cpp\n#include <stdio.h>\n#include \"libavformat/avformat.h\"\nint main()\n{\n\n    AVFormatContext *fmt_ctx = NULL;\n    int err;\n    char filename[] = \"juren-30s.mp4\";\n\n    fmt_ctx = avformat_alloc_context();\n    if (!fmt_ctx) {\n      av_log(NULL, AV_LOG_ERROR, \"error code %d \\n\",AVERROR(ENOMEM));\n      return 1;\n    }\n\n    AVDictionary* format_opts = NULL;\n    AVDictionaryEntry *t;\n    av_dict_set(&format_opts, \"formatprobesize\", \"10485760\", AV_DICT_MATCH_CASE);\n    av_dict_set(&format_opts, \"export_all\", \"1\", AV_DICT_MATCH_CASE);\n    av_dict_set(&format_opts, \"export_666\", \"1\", AV_DICT_MATCH_CASE);\n    av_log(NULL, AV_LOG_INFO, \"AVDictionary num is %d \\n\", av_dict_count(format_opts));\n\n    //获取字典里的第一个属性。\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n          av_log(NULL, AV_LOG_INFO, \"Option key: %s , value %s \\n\", t->key, t->value);\n    }\n    if((err = avformat_open_input(&fmt_ctx, filename,NULL,&format_opts)) < 0){\n        av_log(NULL, AV_LOG_ERROR, \"error code %d \\n\",err);\n    }else{\n        av_log(NULL, AV_LOG_INFO, \"open success \\n\");\n        av_log(NULL, AV_LOG_INFO, \"duration: %I64d \\n\",fmt_ctx->duration);\n    }\n\n    //有两个属性被 avformat_open_input 用掉了，num 只剩 1\n    av_log(NULL, AV_LOG_INFO, \"AVDictionary num is %d \\n\", av_dict_count(format_opts));\n    //再次，获取字典里的第一个属性。\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n          av_log(NULL, AV_LOG_INFO, \"Option key: %s , value %s \\n\", t->key, t->value);\n    }\n    av_dict_free(&format_opts);\n\n   return 0;\n}\n```\n\n上面的代码有两个重点：\n\n1. 我没有在代码里申请 AVDictionary 的内存，那他的内存是从哪里来的？\n答：是从 av_dict_set() 函数内部申请的内存，如果你传 NULL 给它，av_dict_set() 内部就会申请一块内存，可以看到函数的第一个参数是一个二级指针。\n**在用完 AVDictionary 之后，需要调 av_dict_free() 手动释放堆内存。**\n\n2. 如何申请一个栈内存的 `AVDictionary` ，也就是局部变量。\n答：无法做到，`AVDictionary` 只能以指针指向堆内存的方式来使用，如果你想创建一个 局部变量 `AVDictionary opts`放在栈内存里面，编译器会报` incomplete type `未实现类型错误。如下：\n这是因为 `AVDictionary` 这个类型的定义 放在`dict.c` 文件里面了，而 这个 `.c`文件已经被编译器编译进去 dll，编译器看不到这个结构体的实现了。\n\n上面讲的是 `demuxer` （解复用器）的参数设置。`muxer` （复用器）的参数也是这样设置的。不过复用器是通过 `avio_open2()` 函数来设置，如下：\n\n``` cpp\nint avio_open2(AVIOContext **s, const char *filename, int flags,\n               const AVIOInterruptCB *int_cb, AVDictionary **options)\n```\n\n最后一个参数就是 AVDictionary **options。可以通过以下命令 查询 复用器支持的参数。\n\n```bash\nffmpeg -hide_banner 1 -h muxer=mp4\n```\n\n<https://ffmpeg.xianwaizhiyin.net/>\n","tags":["FFmpeg"],"categories":["FFmpeg"]},{"title":"AVpacket数据结构","url":"/2023/11/20/FFmpeg/FFmpegAPI/AVpacket数据结构/","content":"\n一个管理压缩后的媒体数据的结构，它本身不包含压缩的媒体数据，而是通过 data 指针指向媒体数据。\n\n这里面的媒体数据通常是一帧视频的数据，或者一帧音频的数据。但是也有一些特殊情况，这个 AVPacket 的 data 是空的，只有 side data 的数据。side data 是一些附加信息。\n\n## AVPacket数据结构\n\n``` cpp\n/**\n * This structure stores compressed data. It is typically exported by demuxers\n * and then passed as input to decoders, or received as output from encoders and\n * then passed to muxers.\n *\n * For video, it should typically contain one compressed frame. For audio it may\n * contain several compressed frames. Encoders are allowed to output empty\n * packets, with no compressed data, containing only side data\n * (e.g. to update some stream parameters at the end of encoding).\n *\n * The semantics of data ownership depends on the buf field.\n * If it is set, the packet data is dynamically allocated and is\n * valid indefinitely until a call to av_packet_unref() reduces the\n * reference count to 0.\n *\n * If the buf field is not set av_packet_ref() would make a copy instead\n * of increasing the reference count.\n *\n * The side data is always allocated with av_malloc(), copied by\n * av_packet_ref() and freed by av_packet_unref().\n *\n * sizeof(AVPacket) being a part of the public ABI is deprecated. once\n * av_init_packet() is removed, new packets will only be able to be allocated\n * with av_packet_alloc(), and new fields may be added to the end of the struct\n * with a minor bump.\n *\n * @see av_packet_alloc\n * @see av_packet_ref\n * @see av_packet_unref\n */\ntypedef struct AVPacket {\n    /**\n     * A reference to the reference-counted buffer where the packet data is\n     * stored.\n     * May be NULL, then the packet data is not reference-counted.\n     */\n    AVBufferRef *buf;\n    /**\n     * Presentation timestamp in AVStream->time_base units; the time at which\n     * the decompressed packet will be presented to the user.\n     * Can be AV_NOPTS_VALUE if it is not stored in the file.\n     * pts MUST be larger or equal to dts as presentation cannot happen before\n     * decompression, unless one wants to view hex dumps. Some formats misuse\n     * the terms dts and pts/cts to mean something different. Such timestamps\n     * must be converted to true pts/dts before they are stored in AVPacket.\n     */\n    int64_t pts; // 显示时间戳\n    /**\n     * Decompression timestamp in AVStream->time_base units; the time at which\n     * the packet is decompressed.\n     * Can be AV_NOPTS_VALUE if it is not stored in the file.\n     */\n    int64_t dts; // 解码时间戳\n    uint8_t *data; // 压缩编码数据\n    int   size; // 压缩编码数据大小\n    int   stream_index; // 所属的AVStream\n    /**\n     * A combination of AV_PKT_FLAG values\n     */\n    int   flags;\n    /**\n     * Additional packet data that can be provided by the container.\n     * Packet can contain several types of side information.\n     */\n    AVPacketSideData *side_data;\n    int side_data_elems;\n\n    /**\n     * Duration of this packet in AVStream->time_base units, 0 if unknown.\n     * Equals next_pts - this_pts in presentation order.\n     */\n    int64_t duration;\n\n    int64_t pos;                            ///< byte position in stream, -1 if unknown\n\n#if FF_API_CONVERGENCE_DURATION\n    /**\n     * @deprecated Same as the duration field, but as int64_t. This was required\n     * for Matroska subtitles, whose duration values could overflow when the\n     * duration field was still an int.\n     */\n    attribute_deprecated\n    int64_t convergence_duration;\n#endif\n} AVPacket;\n```\n\n## 跟读取文件内容 相关的函数如下\n\n1. av_packet_alloc\n   * 初始化一个 `AVPacket。`\n\n2. av_read_frame\n   * 从 `AVFormatContext` 容器里面读取一个 `AVPacket`，需要注意，虽然函数名是 `frame`，但是读取的是 `AVPacket。`\n\n3. av_packet_unref\n   * 减少 `AVPacket` 对编码数据的引用次数。减到 0 会释放 编码数据的内存。\n\n4. av_packet_free\n   * 释放 `AVPacket` 自身的内存。里面会调 `av_packet_unref`\n\n注意：`av_read_frame` 的返回值有很多种情况。\n\n1. 成功读取到一个 `AVPacket` 。\n\n2. 读取到文件末尾。\n\n3. 网络流有问题，或者本地硬盘坏了。导致 `AVFormatContext` 里面的 `pb->error`有异常。\n\n示例:\n\n``` cpp\n#include <stdio.h>\n#include \"libavformat/avformat.h\"\nint main()\n{\n\n    AVFormatContext *fmt_ctx = NULL;\n    int type = 1;\n\n    int err;\n    //提示，要把 juren-30s.mp4 文件放到 Debug 目录下才能找到。\n    char filename[] = \"juren-30s.mp4\";\n\n    fmt_ctx = avformat_alloc_context();\n    if (!fmt_ctx) {\n      printf(\"error code %d \\n\",AVERROR(ENOMEM));\n      return ENOMEM;\n    }\n\n    if((err = avformat_open_input(&fmt_ctx, filename,NULL,NULL)) < 0){\n        printf(\"error code %d \\n\",err);\n        return err;\n    }\n\n    if( 1==type ){\n        AVPacket *pkt = av_packet_alloc();\n        int ret = 0;\n        ret = av_read_frame(fmt_ctx, pkt);\n        if (ret < 0) {\n            printf(\"read fail \\n\");\n            //省略错误处理。\n            return ret;\n        }else{\n            printf(\"read success \\n\");\n            printf(\"stream 0 type : %d \\n\",fmt_ctx->streams[0]->codecpar->codec_type);\n            printf(\"stream 1 type : %d \\n\",fmt_ctx->streams[1]->codecpar->codec_type);\n            printf(\"stream_index : %d \\n\",pkt->stream_index);\n            printf(\"duration : %I64d ,time_base : %d/%d \\n\",pkt->duration,\n                   fmt_ctx->streams[0]->time_base.num,fmt_ctx->streams[0]->time_base.den);\n            printf(\"size : %d \\n\",pkt->size);\n            printf(\"pos : %I64d \\n\",pkt->pos);\n            printf(\"data : %x %x %x %x %x %x %x \\n\",\n                   pkt->data[0],pkt->data[1],pkt->data[2],pkt->data[3],pkt->data[4],\n                   pkt->data[5],pkt->data[6]);\n        }\n        av_packet_free(&pkt);\n    }\n\n    if( 2==type ){\n\n        AVPacket *pkt = av_packet_alloc();\n\n        int ret = 0, i;\n        for(i = 0; i < 100 ;i++){\n            ret = av_read_frame(fmt_ctx, pkt);\n            if (ret < 0) {\n                printf(\"read fail \\n\");\n                //省略错误处理。\n                return ret;\n            }else{\n                printf(\"read success \\n\");\n                printf(\"stream 0 type : %d \\n\",fmt_ctx->streams[0]->codecpar->codec_type);\n                printf(\"stream 1 type : %d \\n\",fmt_ctx->streams[1]->codecpar->codec_type);\n                printf(\"stream_index : %d \\n\",pkt->stream_index);\n                printf(\"duration : %I64d ,time_base : %d/%d \\n\",pkt->duration,\n                       fmt_ctx->streams[1]->time_base.num,fmt_ctx->streams[0]->time_base.den);\n                printf(\"size : %d \\n\",pkt->size);\n                printf(\"pos : %I64d \\n\",pkt->pos);\n                printf(\"data : %x %x %x %x %x %x %x \\n\",\n                       pkt->data[0],pkt->data[1],pkt->data[2],pkt->data[3],pkt->data[4],\n                       pkt->data[5],pkt->data[6]);\n\n                av_packet_unref(pkt);\n            }\n        }\n\n        av_packet_free(&pkt);\n\n    }\n\n\n    return 0;\n}\n\n```\n\n上面的代码只读了一个 AVPacket。\n\n从上图代码可以看出，我用 `av_packet_alloc` 初始化了一个 AVPacket ，那是不是用 `av_read_frame` 读一次数据，就要调一次 `av_packet_alloc` 呢？\n\n不是，因为 `AVPacket` 他本身是没有编码数据的，他只是管理编码数据，也就是说 `av_packet_alloc` 的时候，`AVPacket` 里面还没有编码数据的，是后面通过 `av_read_frame`把 `AVPacket` 里面的 buf 引用指向了编码数据。\n\n如果你要调多次`av_read_frame`，只需要先用 `av_packet_unref` 消除 `AVPacket` 里面对之前的编码数据的引用即可。只有最后用不到 AVPacket 的时候，才需要调 `av_packet_free` 来释放 `AVPacket` 的内存。\n\n注意:\nAVPacket 里面有一个 stream_index 字段，代表这个 AVPacket 属于哪个流，那我们怎么知道这是一个音频包，还是视频包？\n示例如下:\n\n``` cpp\n for(i=0; i<pFormatCtx->nb_streams; i++) \n  if(pFormatCtx->streams[i]->codec->codec_type==AVMEDIA_TYPE_VIDEO){\n   videoindex=i;\n   break;\n  }\n```\n\n`fmt_ctx->streams[0]->codecpar->codec_type`\n通常情况下，`streams[0]` 是视频流，`streams[1]`是音频流\n\n``` cpp\n/**\n * @addtogroup lavu_media Media Type\n * @brief Media Type\n */\n\nenum AVMediaType {\n    AVMEDIA_TYPE_UNKNOWN = -1,  ///< Usually treated as AVMEDIA_TYPE_DATA\n    AVMEDIA_TYPE_VIDEO,\n    AVMEDIA_TYPE_AUDIO,\n    AVMEDIA_TYPE_DATA,          ///< Opaque data information usually continuous\n    AVMEDIA_TYPE_SUBTITLE,\n    AVMEDIA_TYPE_ATTACHMENT,    ///< Opaque data information usually sparse\n    AVMEDIA_TYPE_NB\n};\n```\n\n> todo 待完善，，\n","tags":["FFmpeg"],"categories":["FFmpeg"]},{"title":"FFmpegAPI学习---avformat_open_input","url":"/2023/11/20/FFmpeg/FFmpegAPI/FFmpegAPI学习-avformat-open-input/","content":"\n先看下解码的流程：\n\n![Alt text](../../images/FFmpeg/FFmpeg解码流程.png)\n\n## avformat_open_input打开输入文件\n\n这个函数会生成 AVFormatContext,定义如下:\n\n``` cpp\n/**\n * Open an input stream and read the header. The codecs are not opened.\n * The stream must be closed with avformat_close_input().\n *\n * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).\n *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this\n *           function and written into ps.\n *           Note that a user-supplied AVFormatContext will be freed on failure.\n * @param url URL of the stream to open.\n * @param fmt If non-NULL, this parameter forces a specific input format.\n *            Otherwise the format is autodetected.\n * @param options  A dictionary filled with AVFormatContext and demuxer-private options.\n *                 On return this parameter will be destroyed and replaced with a dict containing\n *                 options that were not found. May be NULL.\n *\n * @return 0 on success, a negative AVERROR on failure.\n *\n * @note If you want to use custom IO, preallocate the format context and set its pb field.\n */\nint avformat_open_input(AVFormatContext **ps, const char *url, ff_const59 AVInputFormat *fmt, AVDictionary **options);\n```\n\n打开文件的方式有两种:\n\n  1. const char *url\n      * 根据文件名的后缀来猜测以什么样的封装格式打开文件，例如 mp4，m4a 后缀的文件 都用 mov 封装格式来打开。\n\n  2. ff_const59 AVInputFormat *fmt\n      * 指定某一种格式，不用猜测。\n  \nFFmpeg 的函数 经常会有 options 这个参数，因为每种封装格式都支持很多定制参数的，例如 mp4 封装格式支持 movflags:faststart，这样可以 在录制完成之后把 moov 移动到文件头部，这样在网络里面播放 mp4 的时候，就会更快一些。(? todo)初学者可以暂时不用管 options 参数，直接传 NULL 即可。\n\n与打开输入文件相关的结构体如下：\n\n1. AVFormatContext\n    * 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装\n           格式相关信息。\n2. AVStream\n   * 视频文件中每个视频（音频）流对应一个该结构体。\n\n示例:\n**这里有个小技巧，将ffmpeg.c函数中的main函数，替换为下面的函数，就可以运行。**\n\n``` cpp\n#include <stdio.h>\n#include \"libavformat/avformat.h\"\nint main()\n{\n\n    AVFormatContext *fmt_ctx = NULL;\n    int type = 2;\n    int err;\n    // 提示，要把 juren-30s.mp4 文件放到自己设置的目录下才能找到。\n    char filename[] = \"juren-30s.mp4\";\n\n    fmt_ctx = avformat_alloc_context();\n    if (!fmt_ctx) {\n      printf(\"error code %d \\n\",AVERROR(ENOMEM));\n      return 1;\n    }\n\n    if(1==type){\n\n        if((err = avformat_open_input(&fmt_ctx, filename,NULL,NULL)) < 0){\n            printf(\"error code %d \\n\",err);\n        }else{\n            printf(\"open success \\n\");\n            printf(\"filename - %s \\n\",fmt_ctx->url);\n            printf(\"duration - %I64d \\n\",fmt_ctx->duration);\n            printf(\"nb_streams - %u \\n\",fmt_ctx->nb_streams);\n            for( int i=0; i < fmt_ctx->nb_streams; i++ ){\n                 printf(\"stream codec_type - %d \\n\",fmt_ctx->streams[i]->codecpar->codec_type);\n            }\n            printf(\"iformat name - %s \\n\",fmt_ctx->iformat->name);\n            printf(\"iformat long name - %s \\n\",fmt_ctx->iformat->long_name);\n       }\n\n    }\n\n    if(2==type){\n        //设置探测大小\n        AVDictionary *format_opts = NULL;\n        av_dict_set(&format_opts, \"probesize\", \"32\", 0);\n\n        if((err = avformat_open_input(&fmt_ctx, filename,NULL,&format_opts)) < 0){\n            printf(\"error code %d \\n\",err);\n        }else{\n            avformat_find_stream_info(fmt_ctx,NULL);\n            printf(\"open success \\n\");\n            printf(\"filename - %s \\n\",fmt_ctx->url);\n            printf(\"duration - %I64d \\n\",fmt_ctx->duration);\n            printf(\"nb_streams - %u \\n\",fmt_ctx->nb_streams);\n            for( int i=0; i < fmt_ctx->nb_streams; i++ ){\n                 printf(\"stream codec_type - %d \\n\",fmt_ctx->streams[i]->codecpar->codec_type);\n            }\n            printf(\"iformat name - %s \\n\",fmt_ctx->iformat->name);\n            printf(\"iformat long name - %s \\n\",fmt_ctx->iformat->long_name);\n       }\n       av_dict_free(&format_opts);\n    }\n\n    return 0;\n}\n```\n\n### AVFormatContext\n\n里面内容太多，先分析一小部分。\n\n``` cpp\ntypedef struct AVFormatContext {\n    /**\n     * A class for logging and @ref avoptions. Set by avformat_alloc_context().\n     * Exports (de)muxer private options if they exist.\n     */\n    const AVClass *av_class;\n\n    /**\n     * The input container format.\n     *\n     * Demuxing only, set by avformat_open_input().\n     */\n    ff_const59 struct AVInputFormat *iformat;\n\n    /**\n     * The output container format.\n     *\n     * Muxing only, must be set by the caller before avformat_write_header().\n     */\n    ff_const59 struct AVOutputFormat *oformat;\n\n    /**\n     * Format private data. This is an AVOptions-enabled struct\n     * if and only if iformat/oformat.priv_class is not NULL.\n     *\n     * - muxing: set by avformat_write_header()\n     * - demuxing: set by avformat_open_input()\n     */\n    void *priv_data;\n\n    /**\n     * Number of elements in AVFormatContext.streams.\n     *\n     * Set by avformat_new_stream(), must not be modified by any other code.\n     */\n    unsigned int nb_streams;  // 通常下是，音频流和视频流\n\n    /**\n     * Position of the first frame of the component, in\n     * AV_TIME_BASE fractional seconds. NEVER set this value directly:\n     * It is deduced from the AVStream values.\n     *\n     * Demuxing only, set by libavformat.\n     */\n    int64_t start_time; // 开始时间\n\n    /**\n     * Duration of the stream, in AV_TIME_BASE fractional\n     * seconds. Only set this value if you know none of the individual stream\n     * durations and also do not set any of them. This is deduced from the\n     * AVStream values if not set.\n     *\n     * Demuxing only, set by libavformat.\n     */\n    int64_t duration; // 时长\n    /**\n     * Total stream bitrate in bit/s, 0 if not\n     * available. Never set it directly if the file_size and the\n     * duration are known as FFmpeg can compute it automatically.\n     */\n    int64_t bit_rate; // 码率\n    ...\n    \n    }\n\n```\n\n从上面代码中可以看到,`AVFormatContext` 里面其实有 `AVInputFormat（输入）跟` `AVOutputFormat` （输出），我们上面只是打开了一个输入文件，所以只有 `AVInputFormat` 被初始化了。\n\n**虽然 `AVFormatContext` 里面有输入输出两个指针，但是他们很少一起使用的，我的意思是 `AVInputFormat` 跟 `AVOutputFormat` 很少会一起初始化，包括 `ffmpeg.c` 里面也没有一起使用。**\n\n如果你想再初始化一个 `AVOutputFormat` 来处理输出，需要调 `avformat_alloc_output_context2` 再搞一个 `AVFormatContext` 出来。\n\n参考:\n<https://ffmpeg.xianwaizhiyin.net/api-ffmpeg/input.html>\n","tags":["FFmpeg"],"categories":["FFmpeg"]},{"title":"FFmpegAPI学习---avformat_find_stream_info","url":"/2023/11/20/FFmpeg/FFmpegAPI/FFmpegAPI学习-avformat-find-stream-info/","content":"\n先看下解码的流程：\n\n![Alt text](../../images/FFmpeg/FFmpeg解码流程.png)\n\n## 函数定义\n\n``` cpp\n/**\n * Read packets of a media file to get stream information. This\n * is useful for file formats with no headers such as MPEG. This\n * function also computes the real framerate in case of MPEG-2 repeat\n * frame mode.\n * The logical file position is not changed by this function;\n * examined packets may be buffered for later processing.\n *\n * @param ic media file handle\n * @param options  If non-NULL, an ic.nb_streams long array of pointers to\n *                 dictionaries, where i-th member contains options for\n *                 codec corresponding to i-th stream.\n *                 On return each dictionary will be filled with options that were not found.\n * @return >=0 if OK, AVERROR_xxx on error\n *\n * @note this function isn't guaranteed to open all the codecs, so\n *       options being non-empty at return is a perfectly normal behavior.\n *\n * @todo Let the user decide somehow what information is needed so that\n *       we do not waste time getting stuff the user does not need.\n */\nint avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);\n\n```\n\n## avformat_find_stream_info 分析\n\n用于从媒体文件中提取和解析音视频流的信息。它的功能是扫描媒体文件的头部，并将关于媒体文件中存在的音视频流的详细信息填充到AVFormatContext 结构体中。\n\n具体而言，avformat_find_stream_info 函数会读取媒体文件的头部，并解析其中的容器格式（如MP4、AVI等）以及其中包含的音视频流。它会获取每个音视频流的编解码器信息、时长、帧率、采样率、分辨率等相关参数，并将这些信息存储在AVStream 结构体中。\n\n通过调用avformat_find_stream_info 函数，你可以获得有关媒体文件的详细信息，以便在后续的音视频处理任务中使用。这个函数是解码音视频流之前的一个重要步骤，它确保你有正确的信息来解码和处理媒体文件中的音视频数据。\n\n实例:\n\n完整代码见 avformat_open_input\n\n``` cpp\nint main(){\n AVFormatContext *pFormatCtx;\n int    i, videoindex;\n AVCodecContext *pCodecCtx;\n AVCodec   *pCodec;\n AVFrame *pFrame,*pFrameYUV;\n uint8_t *out_buffer;\n AVPacket *packet;\n int y_size;\n int ret, got_picture;\n struct SwsContext *img_convert_ctx;\n //输入文件路径\n    char filepath[] = \"/home/lyt/FFmpeg-n4.4.1/Debug/juren-30s.mp4\";\n\n int frame_cnt;\n\n av_register_all();\n avformat_network_init();\n pFormatCtx = avformat_alloc_context();\n\n if(avformat_open_input(&pFormatCtx,filepath,NULL,NULL)!=0){\n  printf(\"Couldn't open input stream.\\n\");\n  return -1;\n }\n if(avformat_find_stream_info(pFormatCtx,NULL)<0){\n  printf(\"Couldn't find stream information.\\n\");\n  return -1;\n }\n ...\n}\n```\n","tags":["FFmpeg"],"categories":["FFmpeg"]},{"title":"FFmpegAPI学习---av_register_all","url":"/2023/11/20/FFmpeg/FFmpegAPI/FFmpegAPI学习-av-register-all/","content":"## 已弃用\n\n先看下解码的流程：\n\n![Alt text](../../images/FFmpeg/FFmpeg解码流程.png)\n\n## av_register_all 分析\n\n在最开始编译FFmpeg的时候，我们做了一个configure的配置，其中开启或者关闭了很多选项。configure的配置会生成两个文件：config.mk和config.h。\n\n* config.mk：就是makefile文件需要包含进去的子模块，会作用在编译阶段，帮助开发者编译出正确的库。\n\n* config.h：作用在运行阶段，主要是确定需要注册那些容器及编解码格式到FFmpeg框架中。\n\n调用 av_register_all 就可以注册config.h里面开发的编解码器，然后会注册所有的Muxer和Demuxer（封装格式），最后注册所有的Protocol（协议）。\n\n这样在configure时开启或者关闭的选项就作用到了运行时，\n\n> 已弃用\n","tags":["FFmpeg"],"categories":["FFmpeg"]},{"title":"FFmpeg简介","url":"/2023/11/18/FFmpeg/FFmpeg/","content":"\n\nFFmpeg一共包含8个库：\n\n* avcodec：编解码（最重要的库）。\n* avformat：封装格式处理。\n* avfilter：滤镜特效处理。\n* avdevice：各种设备的输入输出。\n* avutil：工具库（大部分库都需要这个库的支持）。\n* postproc：后加工。\n* swresample：音频采样数据格式转换。\n* swscale：视频像素数据格式转换。\n\n## FFmpeg解码的函数\n\n* FFmpeg解码的流程图如下所示:\n\n![Alt text](../../images/FFmpeg/FFmpeg解码流程.png)\n\n### FFmpeg解码函数简介\n\n* av_register_all()：注册所有组件。\n* avformat_open_input()：打开输入视频文件。\n* avformat_find_stream_info()：获取视频文件信息。\n* avcodec_find_decoder()：查找解码器。\n* avcodec_open2()：打开解码器。\n* av_read_frame()：从输入文件读取一帧压缩数据。\n* avcodec_decode_video2()：解码一帧压缩数据。\n* avcodec_close()：关闭解码器。\n* avformat_close_input()：关闭输入视频文件。\n\n### FFmpeg解码的数据结构如下图所示\n\n![Alt text](../../images/FFmpeg/FFmpeg解码的数据结构.png)\n\n### FFmpeg数据结构简介\n\n1. 封装格式\n\n   * AVFormatContext\n     * 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装\n           格式相关信息。\n   * AVInputFormat\n     * 每种封装格式（例如FLV, MKV, MP4, AVI）对应一个该结构体。\n   * AVOutputFormat\n     * 复用器对象，每种作为输出的封装格式（例如FLV, MP4、TS等）对应一个该结构体，如libavformat/flvenc.c的ff_flv_muxer；\n   * AVStream\n     * 视频文件中每个视频（音频）流对应一个该结构体。\n\n2. 编解码\n\n   * AVCodecContext\n     * 编码器上下文结构体，保存了视频（音频）编解码相关信息。\n   * AVCodec\n     * 每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体。\n   * AVCodecParameters\n     * 编解码参数，每个AVStream中都含有一个AVCodecParameters，用来存放当前流的编解码参数。\n\n3. 数据存放\n\n   * AVPacket\n     * 存储一帧压缩编码数据。\n   * AVFrame\n     * 存储一帧解码后像素（采样）数据。\n\n4. 网络协议\n\n   * AVIOContext\n     * 管理输入输出数据的结构体；  \n   * URLProtocol\n     * 描述了音视频数据传输所使用的协议，每种传输协议(例如HTTP、RTMP)等，都会对应一个URLProtocol结构，如libavformat/http.c中的ff_http_protocol；\n   * URLContext\n     * 封装了协议对象及协议操作对象。\n\n### FFmpeg数据结构分析\n\n* AVStream\n  * id：序号\n  * codec：该流对应的AVCodecContext\n  * time_base：该流的时基\n  * r_frame_rate：该流的帧率\n* AVCodecContext\n  * codec：编解码器的AVCodec\n  * width, height：图像的宽高（只针对视频）\n  * pix_fmt：像素格式（只针对视频）\n  * sample_rate：采样率（只针对音频）\n  * channels：声道数（只针对音频）\n  * sample_fmt：采样格式（只针对音频）\n* AVCodec\n  * name：编解码器名称\n  * long_name：编解码器长名称\n  * type：编解码器类型\n  * id：编解码器ID\n  * 一些编解码的接口函数\n* AVPacket\n  * pts：显示时间戳\n  * dts ：解码时间戳\n  * data ：压缩编码数据\n  * size ：压缩编码数据大小\n  * stream_index ：所属的AVStream\n* AVFrame\n  * data：解码后的图像像素数据（音频采样数据）。\n  * linesize：对视频来说是图像中一行像素的大小；对音频来说是整个音频帧的大小。\n  * width, height：图像的宽高（只针对视频）。\n  * key_frame：是否为关键帧（只针对视频） 。\n  * pict_type：帧类型（只针对视频） 。例如I，P，B\n\n> todo 不断完善上面的内容。查看内容时，建议按照解码的流程图来学习API。\n  \n原文链接\n  <https://blog.csdn.net/leixiaohua1020>","tags":["FFmpeg"]},{"title":"216.组合的总和III","url":"/2023/11/18/leetcode/回溯算法/216-组合的总和III/","content":"\n## 题目描述\n\n找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：\n\n* 只使用数字1到9\n* 每个数字 最多使用一次\n返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n\n``` cpp\n示例 1:\n\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n解释:\n1 + 2 + 4 = 7\n没有其他符合的组合了。\n示例 2:\n\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n解释:\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\n没有其他符合的组合了。\n示例 3:\n\n输入: k = 4, n = 1\n输出: []\n解释: 不存在有效的组合。\n在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。\n\n提示:\n\n2 <= k <= 9\n1 <= n <= 60\n```\n\n## 三部曲\n\n* 确定递归函数参数\n\n  * targetSum（int）目标和，也就是题目中的n。\n  * k（int）就是题目中要求k个数的集合。\n  * sum（int）为已经收集的元素的总和，也就是path里元素的总和。\n  * startIndex（int）为下一层for循环搜索的起始位置。\n  所以代码如下：\n\n  ```cpp\n  vector<vector<int>> result;\n  vector<int> path;\n  void backtracking(int targetSum, int k, int sum, int startIndex)\n  ```\n\n  其实这里sum这个参数也可以省略，每次targetSum减去选取的元素数值，然后判断如果targetSum为0了，说明收集到符合条件的结果了，我这里为了直观便于理解，还是加一个sum参数。\n\n* 确定终止条件\n\n  在上面已经说了，k其实就已经限制树的深度，因为就取k个元素，树再往下深了没有意义。\n\n  所以如果path.size() 和 k相等了，就终止。\n\n  如果此时path里收集到的元素和（sum） 和targetSum（就是题目描述的n）相同了，就用result收集当前的结果。\n\n  所以 终止代码如下：\n\n  ```cpp\n  if (path.size() == k) {\n      if (sum == targetSum) result.push_back(path);\n      return; // 如果path.size() == k 但sum != targetSum 直接返回\n  }\n  ```\n\n* 单层搜索过程\n\n  ![s](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195717975-20230310113546003.png)\n  **别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！**\n\n  ``` cpp\n  for (int i = startIndex; i <= 9; i++) {\n      sum += i;\n      path.push_back(i);\n      backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex\n      sum -= i; // 回溯\n      path.pop_back(); // 回溯\n  }\n  ```\n\n代码如下:\n\n```cpp\nclass Solution {\nprivate:\n vector<vector<int>> result;\n        vector<int> path;\n        void backtracking(int targetSum, int k, int sum, int startIndex){\n            if(path.size() == k){\n                if(sum == targetSum){\n                    result.push_back(path);\n                    return;\n                }\n            }\n            if(sum > targetSum ){\n                return ;\n            }\n          \n            for(int i = startIndex;i<=9;i++){\n                path.push_back(i);\n                sum+=i;\n                backtracking(targetSum,k,sum,i+1);\n                path.pop_back();\n                sum -=i;\n            }\n        }\n\npublic:\n    vector<vector<int>> combinationSum3(int k, int n) {\n       result.clear();\n       path.clear();\n       backtracking(n,k,0,1);\n       return result;\n\n    }\n};\n```\n\n## 剪枝\n\n* 已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。\n* 和77.组合一样，for循环的范围也可以剪枝，i <= 9 - (k - path.size()) + 1就可以了。\n\n  ``` cpp\n  class Solution {\n  private:\n   vector<vector<int>> result;\n          vector<int> path;\n          void backtracking(int targetSum, int k, int sum, int startIndex){\n              if(path.size() == k){\n                  if(sum == targetSum){\n                      result.push_back(path);\n                      return;\n                  }\n              }\n              if(sum > targetSum ){\n                  return ;\n              }\n            \n              for(int i = startIndex;i<=9 - (k - path.size()) +1;i++){\n                  path.push_back(i);\n                  sum+=i;\n                  backtracking(targetSum,k,sum,i+1);\n                  path.pop_back();\n                  sum -=i;\n              }\n          }\n\n  public:\n      vector<vector<int>> combinationSum3(int k, int n) {\n         result.clear();\n         path.clear();\n         backtracking(n,k,0,1);\n         return result;\n\n      }\n  };\n  ```\n\n参考:\n<https://www.programmercarl.com/>\n","tags":["leetcode"]},{"title":"回溯","url":"/2023/11/18/leetcode/回溯算法/回溯/","content":"\n\n\n## 回溯法解决的问题\n\n* 组合问题：N个数里面按一定规则找出k个数的集合\n* 切割问题：一个字符串按一定规则有几种切割方式\n* 子集问题：一个N个数的集合里有多少符合条件的子集\n* 排列问题：N个数按一定规则全排列，有几种排列方式\n* 棋盘问题：N皇后，解数独等等\n\n**组合不强调元素顺序，排列强调元素顺序。**\n\n## 如何理解回溯法\n\n回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！\n\n因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。\n\n递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）\n\n## 回溯法模板\n\n* 回溯函数模板返回值以及参数\n在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。\n\n回溯算法中函数返回值一般为void。\n\n再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。\n\n但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。\n\n回溯函数伪代码如下：\n\n```cpp\nvoid backtracking(参数)\n```\n\n* 回溯函数终止条件\n什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。\n\n所以回溯函数终止条件伪代码如下：\n\n```cpp\nif (终止条件) {\n    存放结果;\n    return;\n}\n```\n\n* 回溯搜索的遍历过程\n\n在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。\n注意图中，我特意举例集合大小和孩子的数量是相等的！\n回溯函数遍历过程伪代码如下：\n\n```cpp\nfor (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n    处理节点;\n    backtracking(路径，选择列表); // 递归\n    回溯，撤销处理结果\n}\n```\n\nfor循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。\n\nbacktracking这里自己调用自己，实现递归。\n\n大家可以从图中看出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。\n分析完过程，回溯算法模板框架如下：\n\n``` cpp\nvoid backtracking(参数) {\n    if (终止条件) {\n        存放结果;\n        return;\n    }\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n        处理节点;\n        backtracking(路径，选择列表); // 递归\n        回溯，撤销处理结果\n    }\n}\n\n```\n\n参考:\n<https://www.programmercarl.com/>\n","tags":["leetcode"]},{"title":"77.组合","url":"/2023/11/18/leetcode/回溯算法/77-组合/","content":"\n## 题目描述\n\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n\n你可以按 任何顺序 返回答案。\n\n```cpp\n示例 1：\n\n输入：n = 4, k = 2\n输出：\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n示例 2：\n\n输入：n = 1, k = 1\n输出：[[1]]\n```\n\n## 三部曲\n\n* 递归函数的返回值以及参数\n\n    n 中 取 k个排列，排列时无序的。所以  n , k 必须要有。\n  **startIndex 就是防止出现重复的组合。**\n\n    ``` cpp\n    vector<vector<int>> result; // 存放符合条件结果的集合\n    vector<int> path; // 用来存放符合条件结果\n    void backtracking(int n, int k, int startIndex)\n    ```  \n\n* 回溯函数终止条件\n\n    终止条件， 就是拿到k个的排序。\n\n    ``` cpp\n    if(path.size() == k){\n        result.emplace_back(path);\n        return;\n    }\n    ```\n\n* 单层搜索过程\n        用for循环来横向遍历，函数递归来实现纵向的遍历\n    ![Alt text](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)\n\n    ``` cpp\n    for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历\n        path.push_back(i); // 处理节点\n        backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始\n        path.pop_back(); // 回溯，撤销处理的节点\n    }\n    ```\n\n整体代码如下:\n\n ``` cpp\n class Solution {\nprivate:\n vector<vector<int>> result;\n        vector<int> path;\n        void backtracking(int n,int k,int startIndex){\n            if(path.size() == k){\n                result.emplace_back(path);\n                return;\n            }\n        \n            for(int i = startIndex;i <= n;i++){\n                path.push_back(i);\n                backtracking(n,k,i+1);\n                path.pop_back();\n            }\n        }\npublic:\n    vector<vector<int>> combine(int n, int k) {\n       result.clear();\n       path.clear();\n       backtracking(n,k,1);\n       return result;\n    }\n\n};\n ```\n\n时间复杂度: O(n * 2^n)\n空间复杂度: O(n)\n\n## 剪枝优化\n\n来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。因为我们要的序列元素要有4个， 后面 234已经不足以形成要求的序列了。\n\n**所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。**\n\n**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。**\n\n优化过程如下：\n\n1. 已经选择的元素个数：path.size();\n\n2. 还需要的元素个数为: k - path.size();\n\n3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历，\n   这里简单点就是，我还需要3个元素的时候，n-2之后就没必要去找了，就算全部都要，也才2个，不够我所需要的序列。\n\n为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。\n\n举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。\n\n所以优化之后的for循环是：\n\n```cpp\nfor (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置 \n```\n\n优化后整体代码如下：\n\n``` cpp\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(int n, int k, int startIndex) {\n        if (path.size() == k) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方\n            path.push_back(i); // 处理节点\n            backtracking(n, k, i + 1);\n            path.pop_back(); // 回溯，撤销处理的节点\n        }\n    }\npublic:\n\n    vector<vector<int>> combine(int n, int k) {\n        backtracking(n, k, 1);\n        return result;\n    }\n};\n```\n\n参考:\n<https://www.programmercarl.com/>\n","tags":["leetcode"]},{"title":"终章-sylar总结","url":"/2023/11/17/sylar/模块/终章/","content":"\n项目结构\n\n``` cpp\n.\n├── CMakeLists.txt\n├── README.md\n├── bin\n│   ├── examples\n│   ├── root.txt\n│   ├── samples\n│   ├── system.txt\n│   └── tests\n├── build\n│   ├── CMakeCache.txt\n│   ├── CMakeFiles\n│   ├── build.ninja\n│   ├── cmake_install.cmake\n│   ├── compile_commands.json\n│   ├── examples\n│   ├── samples\n│   ├── sylar\n│   └── tests\n├── cmake\n│   ├── FindPackages.cmake\n│   └── utils.cmake\n├── examples\n│   ├── CMakeLists.txt\n│   └── echo_server.cc\n├── lib\n│   └── libsylar.so\n├── samples\n│   ├── CMakeLists.txt\n│   └── my_http_server.cc\n├── script\n│   └── install_thirdparty.sh\n├── sylar\n│   ├── CMakeLists.txt\n│   ├── Doxyfile\n│   ├── address.cc\n│   ├── address.h\n│   ├── application.cc\n│   ├── application.h\n│   ├── bytearray.cc\n│   ├── bytearray.h\n│   ├── config.cc\n│   ├── config.h\n│   ├── daemon.cc\n│   ├── daemon.h\n│   ├── endian.h\n│   ├── env.cc\n│   ├── env.h\n│   ├── fd_manager.cc\n│   ├── fd_manager.h\n│   ├── fiber.cc\n│   ├── fiber.h\n│   ├── hook.cc\n│   ├── hook.h\n│   ├── http\n│   ├── iomanager.cc\n│   ├── iomanager.h\n│   ├── log.cc\n│   ├── log.h\n│   ├── macro.h\n│   ├── noncopyable.h\n│   ├── schedule.cc\n│   ├── schedule.h\n│   ├── singleton.h\n│   ├── socket.cc\n│   ├── socket.h\n│   ├── socket_stream.cc\n│   ├── socket_stream.h\n│   ├── stream.cc\n│   ├── stream.h\n│   ├── tcp_server.cc\n│   ├── tcp_server.h\n│   ├── thread.cc\n│   ├── thread.h\n│   ├── timer.cc\n│   ├── timer.h\n│   ├── uri.h\n│   ├── uri.rl\n│   ├── uri.rl.cc\n│   ├── util.cc\n│   └── util.h\n├── template\n│   └── bin\n├── tests\n│   ├── CMakeLists.txt\n│   ├── test.cc\n│   ├── test_address.cc\n│   ├── test_application.cc\n│   ├── test_byte_array.cc\n│   ├── test_config.cc\n│   ├── test_daemon.cc\n│   ├── test_env.cc\n│   ├── test_fiber.cc\n│   ├── test_hook.cc\n│   ├── test_http.cc\n│   ├── test_http_connection.cc\n│   ├── test_http_parser.cc\n│   ├── test_http_server.cc\n│   ├── test_iomanager.cc\n│   ├── test_lexical_cast.cc\n│   ├── test_pthread.cc\n│   ├── test_schedule.cc\n│   ├── test_socket.cc\n│   ├── test_tcp_server.cc\n│   ├── test_uri.cc\n│   └── test_util.cc\n├── third_party\n│   ├── boost\n│   ├── json-cpp\n│   ├── protobuf\n│   ├── yaml-cpp\n│   └── zlib\n└── tree.txt\n\n26 directories, 86 files\n\n```\n\n* sylar 为项目源码路径\n* tests 为测试代码路径\n* bin 为可执行文件\n  * bin/tests 为测试的可执行文件\n  * bin/examples 为examples对应的可执行文件\n  * bin/samples 为samples对应的可执行文件\n* cmake\n  * FindPackages.cmake 设置所需要的第三方库。\n  * utils.cmake 为sylar中的cmake,其中包含设置__FILE__相对路径显示\n* third_party 所需要的第三方库\n* build\n* lib 这里存放生成的`sylar.so`,也可以设置生成到build/lib下。\n\n## 各个模块之间的关系\n\n![Alt text](../../../images/sylar框架图.png)\n\n## cmake 结构\n\n* 根目录\n  * sylar\n  * tests\n  * examples\n  * samples\n\n### 根目录\n\n``` cmake\ncmake_minimum_required(VERSION 3.22.1)\nproject(sylar)\n\nset(CMAKE_VERBOSE_MAKEFILE ON)\n\nset(CMAKE_CXX_FLAGS \"$ENV{CXXFLAGS} -rdynamic  -O3  -fPIC -g -std=c++11 -Wall -Wno-deprecated -Werror -Wno-unused-function -Wno-builtin-macro-redefined\")\n#-------------------------------------------------------------------------------\n\n# Find packages in the './third_party' directory\ninclude(cmake/FindPackages.cmake)\n\n# 修改log生成绝对路径改为相对路径  重定义 __FILE__\ninclude(cmake/utils.cmake)\n\n# Output compile_commands.json for clangd.\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\n#-------------------------------------------------------------------------------\n\nragelmaker(sylar/uri.rl LIB_SRC ${CMAKE_SOURCE_DIR}/sylar)\nragelmaker(sylar/http/http11_parser.rl LIB_SRC ${CMAKE_SOURCE_DIR}/sylar/http)\nragelmaker(sylar/http/httpclient_parser.rl LIB_SRC ${CMAKE_SOURCE_DIR}/sylar/http)\n\n#-------------------------------------------------------------------------------\n#lib\nadd_subdirectory(sylar)\n\n# test\nadd_subdirectory(tests)\nadd_subdirectory(examples)\nadd_subdirectory(samples)\n\n```\n\n### sylar\n\n``` cmake\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\n# 输出在 build/lib/xx\n# set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\nfile(GLOB_RECURSE LIB_SRC ./*.cc)\n\nadd_library(sylar SHARED ${LIB_SRC})\nforce_redefine_file_macro_for_sources(sylar) #__FILE__\n\ntarget_include_directories(sylar    PUBLIC   \n                                    ${CMAKE_SOURCE_DIR}/sylar\n                                    ${yaml-cpp_INCLUDE_DIRS} \n                                    ${Boost_INCLUDE_DIRS})\n\ntarget_link_libraries(sylar         PUBLIC \n                                    dl # todo  dslym\n                                    pthread\n                                    ${Boost_LIBRARIES}\n                                    ${yaml-cpp_LIBRARIES})\n\n```\n\n### tests\n\n可执行文件可以生成在bin/tests/目录下，也可以设置声成在build/bin/tests/目录下。\n这里设置的是前者。\n\n``` cmake\n# 可执行文件输出位置\nSET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin/tests)\n# # 可执行文件输出位置 build/bin/test\n# set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/tests)\n#----test-----------------------------------------------------------------------\nadd_executable(test test.cc)\nadd_dependencies(test sylar)\nforce_redefine_file_macro_for_sources(test) #__FILE__\ntarget_link_libraries(test sylar)\ntarget_include_directories(test PRIVATE ${CMAKE_SOURCE_DIR})\n\n...\n# 下面生成可执行文件，与上面类似，不再列出，可以去看源码。\n```\n\n### examples\n\n可执行文件可以生成在bin/examples/目录下，也可以设置声成在build/bin/examples/目录下。\n这里设置的是前者。\n\n``` cmake\n# 可执行文件输出位置\nSET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin/examples)\n# # 可执行文件输出位置 build/bin/examples\n# set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/examples)\n#----examples-----------------------------------------------------------------------\nadd_executable(echo_server echo_server.cc)\nforce_redefine_file_macro_for_sources(echo_server) #__FILE__\ntarget_include_directories(echo_server PRIVATE  ${CMAKE_SOURCE_DIR}\n                                                ${yaml-cpp_INCLUDE_DIRS} \n                                                ${Boost_INCLUDE_DIRS})\n\ntarget_link_libraries(echo_server PRIVATE   sylar)\n```\n\n### samples\n\n可执行文件可以生成在bin/samples/目录下，也可以设置声成在build/bin/samples/目录下。\n这里设置的是前者。\n\n``` cmake\n# 可执行文件输出位置\nSET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin/samples)\n# # 可执行文件输出位置 build/bin/samples\n# set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/samples)\n#----examples-----------------------------------------------------------------------\nadd_executable(my_http_server my_http_server.cc)\nforce_redefine_file_macro_for_sources(my_http_server) #__FILE__\n\ntarget_include_directories(my_http_server PRIVATE  ${CMAKE_SOURCE_DIR}\n                                                ${yaml-cpp_INCLUDE_DIRS} \n                                                ${Boost_INCLUDE_DIRS})\n\ntarget_link_libraries(my_http_server PRIVATE sylar)\n```\n","tags":["sylar"],"categories":["sylar"]},{"title":"hook模块","url":"/2023/11/16/sylar/模块/hook模块/","content":"\nhook系统底层和socket相关的API，socket IO相关的API，以及sleep系列的API。hook的开启控制是线程粒度的，可以自由选择。通过hook模块，可以使一些不具异步功能的API，展现出异步的性能，如MySQL。\n\n## hook概述\n\nhook实际上就是对系统调用API进行一次封装，将其封装成一个与原始的系统调用API同名的接口，应用在调用这个接口时，会先执行封装中的操作，再执行原始的系统调用API。\n\nhook技术可以使应用程序在执行系统调用之前进行一些隐藏的操作，比如可以对系统提供malloc()和free()进行hook，在真正进行内存分配和释放之前，统计内存的引用计数，以排查内存泄露问题。\n\n还可以用C++的子类重载来理解hook。在C++中，子类在重载父类的同名方法时，一种常见的实现方式是子类先完成自己的操作，再调用父类的操作，如下：\n\n``` cpp\n\nclass Base {\npublic:\n    void Print() {\n        cout << \"This is Base\" << endl;\n    }\n};\n \nclass Child : public Base {\npublic:\n    /// 子类重载时先实现自己的操作，再调用父类的操作\n    void Print() {\n        cout << \"This is Child\" << endl;\n        Base::Print();\n    }\n};\n//在上面的代码实现中，调用子类的Print方法，会先执行子类的语句，然后再调用父类的Print方法，这就相当于子类hook了父类的Print方法。 \n\n```\n\n由于hook之后的系统调用与原始的系统系统调用同名，所以对于程序开发者来说也很方便，不需要重新学习新的接口，只需要按老的接口调用惯例直接写代码就行了。\n\n## hook功能\n\nhook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。hook和IO协程调度是密切相关的，如果不使用IO协程调度器，那hook没有任何意义，考虑IOManager要在一个线程上按顺序调度以下协程：\n\n1. 协程1：sleep(2) 睡眠两秒后返回。\n2. 协程2：在scoket fd1 上send 100k数据。\n3. 协程3：在socket fd2 上recv直到数据接收成功。\n\n在未hook的情况下，IOManager要调度上面的协程，流程是下面这样的：\n\n1. 调度协程1，协程阻塞在sleep上，等2秒后返回，这两秒内调度线程是被协程1占用的，其他协程无法在当前线程上调度。\n2. 调度协徎2，协程阻塞send 100k数据上，这个操作一般问题不大，因为send数据无论如何都要占用时间，但如果fd迟迟不可写，那send会阻塞直到套接字可写，同样，在阻塞期间，其他协程也无法在当前线程上调度。\n3. 调度协程3，协程阻塞在recv上，这个操作要直到recv超时或是有数据时才返回，期间调度器也无法调度其他协程。\n\n上面的调度流程最终总结起来就是，协程只能按顺序调度，一旦有一个协程阻塞住了，那整个调度线程也就阻塞住了，其他的协程都无法在当前线程上执行。像这种一条路走到黑的方式其实并不是完全不可避免，以sleep为例，调度器完全可以在检测到协程sleep后，将协程yield以让出执行权，同时设置一个定时器，2秒后再将协程重新resume。这样，调度器就可以在这2秒期间调度其他的任务，同时还可以顺利的实现sleep 2秒后再继续执行协程的效果，send/recv与此类似。在完全实现hook后，IOManager的执行流程将变成下面的方式：\n\n1. 调度协程1，检测到协程sleep，那么先添加一个2秒的定时器，定时器回调函数是在调度器上继续调度本协程，接着协程yield，等定时器超时。\n2. 因为上一步协程1已经yield了，所以协徎2并不需要等2秒后才可以执行，而是立刻可以执行。同样，调度器检测到协程send，由于不知道fd是不是马上可写，所以先在IOManager上给fd注册一个写事件，回调函数是让当前协程resume并执行实际的send操作，然后当前协程yield，等可写事件发生。\n3. 上一步协徎2也yield了，可以马上调度协程3。协程3与协程2类似，也是给fd注册一个读事件，回调函数是让当前协程resume并继续recv，然后本协程yield，等事件发生。\n4. 等2秒超时后，执行定时器回调函数，将协程1 resume以便继续执行。\n5. 等协程2的fd可写，一旦可写，调用写事件回调函数将协程2 resume以便继续执行send。\n6. 等协程3的fd可读，一旦可读，调用回调函数将协程3 resume以便继续执行recv。\n\n上面的4、5、6步都是异步的，调度线程并不会阻塞，IOManager仍然可以调度其他的任务，只在相关的事件发生后，再继续执行对应的任务即可。并且，由于hook的函数签名与原函数一样，所以对调用方也很方便，只需要以同步的方式编写代码，实现的效果却是异步执行的，效率很高。\n\n总而言之，在IO协程调度中对相关的系统调用进行hook，可以让调度线程尽可能得把时间片都花在有意义的操作上，而不是浪费在阻塞等待中。\n\nhook的重点是在替换API的底层实现的同时完全模拟其原本的行为，因为调用方是不知道hook的细节的，在调用被hook的API时，如果其行为与原本的行为不一致，就会给调用方造成困惑。比如，所有的socket fd在进行IO调度时都会被设置成NONBLOCK模式，如果用户未显式地对fd设置NONBLOCK，那就要处理好fcntl，不要对用户暴露fd已经是NONBLOCK的事实，这点也说明，除了IO相关的函数要进行hook外，对fcntl, setsockopt之类的功能函数也要进行hook，才能保证API的一致性。\n\n## hook实现\n\nhook 的实现机制就是通过动态库的全局符号介入功能，用自定义的接口来替换掉同名的系统调用接口。由于系统调用接口基本上是由 C 标准函数库 libc 提供的，所以这里要做的事情就是用自定义的动态库来覆盖掉 libc 中的同名符号。\n\n### 首先先了解下dlsym\n\n注意库函数在库中的定义要用extern“c”来声明，\n\n``` cpp\n#include <dlfcn.h>\n\nvoid *dlsym(void *handle, const char *symbol);\n\n1. handle是由dlopen打开动态链接库后返回的指针\n    RTLD_DEFAULT表示按默认的顺序搜索共享库中符号symbol第一次出现的地址\n    RTLD_NEXT表示在当前库以后按默认的顺序搜索共享库中符号symbol第一次出现的地址\n2. symbol就是要求获取的函数的名称\n3. 函数返回值是void*,指向函数的地址，供调用使用。\n\n```\n\n示例:\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#define __USE_GNU     //使用RTLD_DEFAULT和RTLD_NEXT宏需定义\n#include <dlfcn.h>\n \ntypedef size_t (*strlen_t)(const char *); \nstrlen_t strlen_f = NULL, strlen_f1 = NULL;\n \nsize_t strlen(const char *str)\n{\n    printf(\"%s strlen\\n\", __FILE__);\n    return strlen_f1(str);\n}\n \nint main(int argc, char **argv)\n{\n    strlen_f = dlsym(RTLD_DEFAULT, \"strlen\");  \n    //获取到的是当前文件中函数符号strlen的地址\n    if(!strlen_f) {\n        printf(\"default load error %s\\n\", dlerror());\n        return 1;\n    }   \n    strlen_f1 = dlsym(RTLD_NEXT, \"strlen\");\n    //获取到的是当前库后的系统库中函数符号strlen的地址\n    if(!strlen_f1) {\n        printf(\"next load error %s\\n\", dlerror());\n        return 1;\n    }   \n    printf(\"strlen is %p\\n\", strlen);\n    printf(\"strlen_f is %p\\n\", strlen_f);\n    printf(\"strlen_f1 is %p\\n\", strlen_f1);\n    printf(\"strlen_f is %ld\\n\", strlen_f(\"asd\")); //调用当前文件中的函数strlen\n    printf(\"=>>>>>>>>>> <<<<<<<<<<<=\\n\");\n    printf(\"strlen_f1 is %ld\\n\", strlen_f1(\"asd\"));  //相当于调用系统库函数strlen\n    return 0;\n}\n```\n\n``` c\n➜  gcc  dlsym1.c  -ldl \n➜  ./a.out\nstrlen is 0x555662df31a9\nstrlen_f is 0x555662df31a9\nstrlen_f1 is 0x7f2d63f9d9e0\ndlsym1.c strlen\nstrlen_f is 3\n=>>>>>>>>>> <<<<<<<<<<<=\nstrlen_f1 is 3\n```\n\n### 然后再来看sylar的实现\n\n首先定义线程局部变量t_hook_enable，用于表示当前线程是否启用hook，使用线程局部变量表示hook模块是线程粒度的，各个线程可单独启用或关闭hook。然后是获取各个被hook的接口的原始地址， 这里要借助dlsym来获取。\n\n``` cpp\n// hook.h\n#ifdef __cplusplus\n\nextern \"C\" {\n#endif\n\n// sleep\ntypedef unsigned int (*sleep_fun)(unsigned int seconds);\nextern sleep_fun sleep_f;\n\ntypedef int (*usleep_fun)(useconds_t usec);\nextern usleep_fun usleep_f;\n...\n}\n```\n\n**在main函数之前执行一段程序，hook**\n静态实例\n`static _HookIniter s_hook_initer;`\n\n``` cpp\n// hook.cc\n// 实现线程级别的hook\nstatic thread_local bool t_hook_enable = false;\n\n#define HOOK_FUN(XX) \\\n  XX(sleep)          \\\n  XX(usleep)         \\\n  XX(nanosleep)      \\\n  XX(socket)         \\\n  XX(connect)        \\\n  XX(accept)         \\\n  XX(read)           \\\n  XX(readv)          \\\n  XX(recv)           \\\n  XX(recvfrom)       \\\n  XX(recvmsg)        \\\n  XX(write)          \\\n  XX(writev)         \\\n  XX(send)           \\\n  XX(sendto)         \\\n  XX(sendmsg)        \\\n  XX(close)          \\\n  XX(fcntl)          \\\n  XX(ioctl)          \\\n  XX(getsockopt)     \\\n  XX(setsockopt)\n\nvoid hook_init() {\n  static bool is_inited = false;\n  if (is_inited) {\n    return;\n  }\n\n#define XX(name) name##_f = (name##_fun)dlsym(RTLD_NEXT, #name);\n  HOOK_FUN(XX);\n#undef XX\n}\n\nstatic uint64_t s_connect_timeout = -1;\nstruct _HookIniter {\n  _HookIniter() {\n    hook_init();\n    s_connect_timeout = g_tcp_connect_timeout->getValue();\n\n    g_tcp_connect_timeout->addListener([](const int &old_value, const int &new_value) {\n      SYLAR_LOG_INFO(g_logger) << \"tcp connect timeout changed from \" << old_value << \"to\"\n                               << new_value;\n      s_connect_timeout = new_value;\n    });\n  }\n};\n\n// 这里确保 在main函数之前，就初始化好\nstatic _HookIniter s_hook_initer;\n\n...\n\nextern \"C\" {\n\n#endif\n\n#define XX(name) name##_fun name##_f = nullptr;\nHOOK_FUN(XX);\n#undef XX\n\nunsigned int sleep(unsigned int seconds) {\n  if (!sylar::t_hook_enable) {\n    return sleep_f(seconds);\n  }\n  // 返回当前线程正在执行的协程\n  sylar::Fiber::ptr fiber = sylar::Fiber::GetThis();\n  // 用于获取当前线程的调度器的调度协程\n  sylar::IOManager *iom = sylar::IOManager::GetThis();\n  iom->addTimer(seconds * 1000,\n                std::bind((void(sylar::Scheduler::*)(sylar::Fiber::ptr, int thread)) &\n                              sylar::IOManager::schedule,\n                          iom, fiber, -1));\n\n  sylar::Fiber::YieldToHold();\n  return 0;\n\n  ...\n}\nread\nwrite\n...\n}\n\n```\n\n**hook_init() 放在一个静态对象的构造函数中调用，这表示在main函数运行之前就会获取各个符号的地址并保存在全局变量中。**\n`static _HookIniter s_hook_initer;`\n\n### socket fd上下文和FdManager的实现\n\n这两个类用于记录fd上下文和保存全部的fd上下文，它们的关键实现如下：\n\n``` cpp\n/**\n * @brief 文件句柄上下文类\n * @details 管理文件句柄类型(是否socket)\n *          是否阻塞,是否关闭,读/写超时时间\n */\nclass FdCtx : public std::enable_shared_from_this<FdCtx> {\n public:\n  typedef std::shared_ptr<FdCtx> ptr;\n  /**\n   * @brief 通过文件句柄构造FdCtx\n   */\n  FdCtx(int fd);\n  /**\n   * @brief 析构函数\n   */\n  ~FdCtx();\n\n  bool init();\n  bool isInit() const { return m_isInit; }\n  bool isSocket() const { return m_isSocket; }\n  bool isClosed() const { return m_isClosed; }\n  bool close();\n\n  void setUserNonblock(bool v) { m_userNonblock = v; }\n  bool getUserNonblock() const { return m_userNonblock; }\n\n  void setSysNonblock(bool v) { m_sysNonblock = v; }\n  bool getSysNonblock() const { return m_sysNonblock; }\n\n  void setTimeout(int type, uint64_t v);\n  uint64_t getTimeout(int type);\n\n private:\n  /// 是否初始化\n  bool m_isInit : 1;\n  /// 是否socket\n  bool m_isSocket : 1;\n  /// 是否hook非阻塞\n  bool m_sysNonblock : 1;\n  /// 是否用户主动设置非阻塞\n  bool m_userNonblock : 1;\n  /// 是否关闭\n  bool m_isClosed : 1;\n  /// 文件句柄\n  int m_fd;\n  /// 读超时时间毫秒\n  uint64_t m_recvTimeout;\n  /// 写超时时间毫秒\n  uint64_t m_sendTimeout;\n\n};\n\nclass FdManager {\n public:\n  typedef RWMutex RWMutexType;\n  FdManager();\n\n  FdCtx::ptr get(int fd, bool auto_create = false);\n  void del(int fd);\n\n private:\n  RWMutexType m_mutex;\n  std::vector<FdCtx::ptr> m_datas;\n};\n\n/// 文件句柄单例\ntypedef Singleton<FdManager> FdMgr;\n```\n\nFdCtx类在用户态记录了fd的读写超时和非阻塞信息，其中非阻塞包括用户显式设置的非阻塞和hook内部设置的非阻塞，区分这两种非阻塞可以有效应对用户对fd设置/获取NONBLOCK模式的情形。\n\nFdManager类对FdCtx的寻址采用了和IOManager中对FdContext的寻址一样的寻址方式，直接用fd作为数组下标进行寻址。\n\n### sleep/usleep/nanosleep的hook实现\n\n它们的实现思路完全一样，即先添加定时器再yield，比如sleep函数的hook代码如下：\n**这里要主要下是如何bind模板函数的**\n\n``` cpp\nunsigned int sleep(unsigned int seconds) {\n  if (!sylar::t_hook_enable) {\n    return sleep_f(seconds);\n  }\n  // 返回当前线程正在执行的协程\n  sylar::Fiber::ptr fiber = sylar::Fiber::GetThis();\n  // 用于获取当前线程的调度器的调度协程\n  sylar::IOManager *iom = sylar::IOManager::GetThis();\n  iom->addTimer(\n      seconds * 1000,\n      // 模板方法进行bind时，要声明他的bind类型，还有默认参数要写进去，否则会显示没有此函数。\n      std::bind((void(sylar::Scheduler::*)(sylar::Fiber::ptr, int thread)) &\n                    sylar::IOManager::schedule,\n                iom, fiber, -1));\n\n  sylar::Fiber::YieldToHold();\n  return 0;\n}\n\nint usleep(useconds_t usec) {\n  if (!sylar::t_hook_enable) {\n    return usleep_f(usec);\n  }\n\n  sylar::Fiber::ptr fiber = sylar::Fiber::GetThis();\n  sylar::IOManager *iom = sylar::IOManager::GetThis();\n  iom->addTimer(usec / 1000, std::bind((void(sylar::Scheduler::*)(sylar::Fiber::ptr, int thread)) &\n                                           sylar::IOManager::schedule,\n                                       iom, fiber, -1));\n\n  sylar::Fiber::YieldToHold();\n  return 0;\n}\n\n```\n\n### socket接口的hook实现\n\nsocket用于创建套接字，需要在拿到fd后将其添加到FdManager中，代码实现如下：\n\n```cpp\n// socket\nint socket(int domain, int type, int protocol) {\n  if (!sylar::t_hook_enable) {\n    return socket_f(domain, type, protocol);\n  }\n  int fd = socket_f(domain, type, protocol);\n  if (fd == -1) {\n    return fd;\n  }\n  // true 表示,FdMgr没有时会自动创建\n  sylar::FdMgr::GetInstance()->get(fd, true);\n  return fd;\n}\n```\n\n### do_io\n\n``` cpp\ntemplate <typename OriginFun, typename... Args>\nstatic ssize_t do_io(int fd, OriginFun fun, const char *hook_fun_name,\n                     uint32_t event, int timeout_so, Args &&...args) {\n  // 没有hook直接返回原函数\n  if (!sylar::t_hook_enable) {\n    //  read(int fd, void *buf, size_t count)\n    //  return do_io(fd, read_f, \"read\", sylar::IOManager::READ, SO_RCVTIMEO,\n    //  buf, count);\n    return fun(fd, std::forward<Args>(args)...);\n  }\n\n  SYLAR_LOG_DEBUG(g_logger) << \"do_io <\" << hook_fun_name << \">\";\n  // 得到fd 对应的 FdCtx\n  sylar::FdCtx::ptr ctx = sylar::FdMgr::GetInstance()->get(fd);\n  // 不存在则不是socket, 按照原来方式，不管他\n  if (!ctx) {\n    return fun(fd, std::forward<Args>(args)...);\n  }\n  // 存在，且已经关闭了，改errno\n  if (ctx->isClosed()) {\n    // Bad file descriptor\n    errno = EBADF;\n    return -1;\n  }\n\n  // 如果不是socket或者用户已经设置了非阻塞，那我们也不管\n  if (!ctx->isSocket() || ctx->getUserNonblock()) {\n    return fun(fd, std::forward<Args>(args)...);\n  }\n\n  uint64_t to = ctx->getTimeout(timeout_so);\n  // 创建条件\n  std::shared_ptr<timer_info> tinfo = std::make_shared<timer_info>();\n\nretry:\n  // 执行原始方法，异步io\n  ssize_t n = fun(fd, std::forward<Args>(args)...);\n  // EINTR ---Interrupted system call\n  // 如果读到了，就可以直接返回出去--->return n;\n  // 如果没有读到，这种情况下，重试原始方法\n  while (n == -1 && errno == EINTR) {\n    n = fun(fd, std::forward<Args>(args)...);\n  }\n  // 这种是阻塞状态,需要做异步操作\n  if (n == -1 && errno == EAGAIN) {\n    SYLAR_LOG_DEBUG(g_logger) << \"do_io\" << hook_fun_name << \">\";\n    sylar::IOManager *iom = sylar::IOManager::GetThis();\n    sylar::Timer::ptr timer;\n    // 条件变量，\n    std::weak_ptr<timer_info> winfo(tinfo);\n\n    // (uint64_t)-1 = 18446744073709551615 (0xffffffffffffffff)\n    // 就是设置了超时时间的情况时，超时器，超时时间\n    if (to != (uint64_t)-1) {\n      // 等待设置的时间，还没来的话，触发定时器回调，\n      timer = iom->addConditionTimer(\n          to,\n          [winfo, fd, iom, event]() {\n            // 定时器回来时，要lock todo --->shared_ptr lock\n            auto t = winfo.lock();\n            // 如果没有t，或者取消了\n            if (!t || t->cancelled) {\n              return;\n            }\n            t->cancelled = ETIMEDOUT;\n            // 取消事件，强制唤醒 ,到达时间后，强制唤醒\n            iom->cancelEvent(fd, (sylar::IOManager::Event)(event));\n          },\n          winfo);\n    }\n\n    /// 可读可写事件，即可获取协程唤醒的标志，这里默认以当前协程，作为回调函数\n    int rt = iom->addEvent(fd, (sylar::IOManager::Event)(event));\n    // 失败的情况，直接返回。\n    if (SYLAR_UNLIKELY(rt)) {\n      SYLAR_LOG_ERROR(g_logger)\n          << hook_fun_name << \" addEvent(\" << fd << \", \" << event << \")\";\n      //  定时器添加失败\n      if (timer) {\n        timer->cancel();\n      }\n      return -1;\n\n    } else {\n      // 成功\n      // SYLAR_LOG_ERROR(g_logger) << \"do_io<\" << hook_fun_name << \">\";\n      // 让出当前协程的执行时间\n      sylar::Fiber::YieldToHold();\n      // SYLAR_LOG_ERROR(g_logger) << \"do_io<\" << hook_fun_name << \">\";\n      // 有定时器的话，timer，则取消掉\n      // 两种情况到这里\n      // 1. 真的有事件发生了\n      // 2. 设置的定时器超时了，\n      if (timer) {\n        timer->cancel();\n      }\n      // 去掉的里面有cancelld\n      // 的话，说明是通过定时器超时将这里唤醒的，这设置errno\n      if (tinfo->cancelled) {\n        errno = tinfo->cancelled;\n        return -1;\n      }\n      // 否则说明有io时间返回，那我们重新读\n      goto retry;  // todo\n    }\n  }\n  // 读到数据，返回n\n  return n;\n}\n\n```\n\n### connect_with_timeout\n\n``` cpp\nint connect_with_timeout(int fd, const struct sockaddr *addr, socklen_t addrlen,\n                         uint64_t timeout_ms) {\n  // 没有hook\n  if (!sylar::t_hook_enable) {\n    return connect_f(fd, addr, addrlen);\n  }\n  sylar::FdCtx::ptr ctx = sylar::FdMgr::GetInstance()->get(fd);\n  // 文件句柄， 不存在或者关闭\n  if (!ctx || ctx->isClosed()) {\n    errno = EBADF;\n    return -1;\n  }\n  // 不是socket\n  if (!ctx->isSocket()) {\n    return connect_f(fd, addr, addrlen);\n  }\n  // 判断fd是否被用户显式设置为了非阻塞模式，如果是则调用系统的connect函数并返回。\n  if (ctx->getUserNonblock()) {\n    return connect_f(fd, addr, addrlen);\n  }\n\n  // 调用系统的connect函数，由于套接字是非阻塞的，这里会直接返回EINPROGRESS错误。\n  size_t n = connect_f(fd, addr, addrlen);\n  if (n == 0) {\n    return 0;\n  } else if (errno != EINPROGRESS) {\n    return n;\n  }\n\n  sylar::IOManager *iom = sylar::IOManager::GetThis();\n  sylar::Timer::ptr timer;\n  // std::shared_ptr<timer_info> tinfo(new timer_info);\n  std::shared_ptr<timer_info> tinfo = std::make_shared<timer_info>();\n  std::weak_ptr<timer_info> winfo(tinfo);\n  // 如果超时参数有效，则添加一个条件定时器，在定时时间到后通过t->cancelled设置超时标志并触发一次WRITE事件。\n  if (timeout_ms != (uint64_t)-1) {\n    timer = iom->addConditionTimer(\n        timeout_ms,\n        [winfo, fd, iom]() {\n          auto t = winfo.lock();\n          /// 判断tinfo条件是否存在\n          /// 或t->cancelled超时的话\n          if (!t || t->cancelled) {\n            return;\n          }\n          /// 将条件设为超时状态\n          t->cancelled = ETIMEDOUT;\n          /// 取消掉可写事件，会执行cb，由于下面注册空回调\n          /// 因此会回到该线程\n          iom->cancelEvent(fd, sylar::IOManager::WRITE);\n        },\n        winfo);\n  }\n\n  /// 注册可写事件 回调为当前协程\n  /// 连接成功说明已经可写\n  /// 非阻塞connect的完成被认为是使响应套接字可写\n  int rt = iom->addEvent(fd, sylar::IOManager::WRITE);\n  // 这addEvent成功\n  if (rt == 0) {\n    /// 关键点:切换出去，让出CPU执行权\n    // 在这里唤醒时，要么连接成功，要么超时\n    sylar::Fiber::YieldToHold();\n    // 定时器取消\n    if (timer) {\n      timer->cancel();\n    }\n    /// 由于 iom->cancelEvent(fd, pudge::IOManager::WRITE);引起\n    /// 则会触发如下的超时\n    if (tinfo->cancelled) {\n      errno = tinfo->cancelled;\n      return -1;\n    }\n  } else {\n    // 失败时，有定时器的话，取消掉\n    if (timer) {\n      timer->cancel();\n    }\n    SYLAR_LOG_ERROR(g_logger) << \"connect addevent(\" << fd << \",WRITE) error\";\n  }\n  // connect 可写时，就表明连接成功，不需要做其他事情。\n  int error = 0;\n  socklen_t len = sizeof(int);\n  // 取出状态，检查是否有error\n  if (-1 == getsockopt_f(fd, SOL_SOCKET, SO_ERROR, &error, &len)) {\n    return -1;\n  }\n  if (!error) {\n    return 0;\n  } else {\n    errno = error;\n    return -1;\n  }\n}\n```\n\n参考:\n\n<https://xuedaon.blog.csdn.net/article/details/123401531>\n<https://www.midlane.top/wiki/pages/viewpage.action?pageId=16417219>\n","tags":["sylar"],"categories":["sylar"]},{"title":"Address模块","url":"/2023/11/12/sylar/模块/Address模块/","content":"\n\n![Alt text](../../../images/Address类图.png)\n\nAddress：所有网络地址的基类，抽象类，对应sockaddr类型，但只包含抽象方法，不包含具体的成员。除此外，Address作为地址类还提供了网络地址查询及网卡地址查询功能。\n\n## Address\n\n``` cpp\nclass IPAddress;\n\n/**\n * @brief 网络地址的基类,抽象类\n */\nclass Address {\n public:\n  typedef std::shared_ptr<Address> ptr;\n\n  /**\n   * @brief 通过sockaddr指针创建Address\n   * @param[in] addr sockaddr指针\n   * @param[in] addrlen sockaddr的长度\n   * @return 返回和sockaddr相匹配的Address,失败返回nullptr\n   */\n  static Address::ptr Create(const sockaddr *addr, socklen_t addrlen);\n\n  /**\n   * @brief 通过host地址返回对应条件的所有Address\n   * @param[out] result 保存满足条件的Address\n   * @param[in] host 域名,服务器名等.举例: www.sylar.top[:80] (方括号为可选内容)\n   * @param[in] family 协议族(AF_INT, AF_INT6, AF_UNIX)\n   * @param[in] type socketl类型SOCK_STREAM、SOCK_DGRAM 等\n   * @param[in] protocol 协议,IPPROTO_TCP、IPPROTO_UDP 等\n   * @return 返回是否转换成功\n   */\n  static bool Lookup(std::vector<Address::ptr> &result, const std::string &host,\n                     int family = AF_INET, int type = 0, int protocol = 0);\n  /**\n   * @brief 通过host地址返回对应条件的任意Address\n   * @param[in] host 域名,服务器名等.举例: www.sylar.top[:80] (方括号为可选内容)\n   * @param[in] family 协议族(AF_INT, AF_INT6, AF_UNIX)\n   * @param[in] type socketl类型SOCK_STREAM、SOCK_DGRAM 等\n   * @param[in] protocol 协议,IPPROTO_TCP、IPPROTO_UDP 等\n   * @return 返回满足条件的任意Address,失败返回nullptr\n   */\n  static Address::ptr LookupAny(const std::string &host, int family = AF_INET,\n                                int type = 0, int protocol = 0);\n  /**\n   * @brief 通过host地址返回对应条件的任意IPAddress\n   * @param[in] host 域名,服务器名等.举例: www.sylar.top[:80] (方括号为可选内容)\n   * @param[in] family 协议族(AF_INT, AF_INT6, AF_UNIX)\n   * @param[in] type socketl类型SOCK_STREAM、SOCK_DGRAM 等\n   * @param[in] protocol 协议,IPPROTO_TCP、IPPROTO_UDP 等\n   * @return 返回满足条件的任意IPAddress,失败返回nullptr\n   */\n  static std::shared_ptr<IPAddress> LookupAnyIPAddress(const std::string &host,\n                                                       int family = AF_INET,\n                                                       int type = 0,\n                                                       int protocol = 0);\n\n  /**\n   * @brief 返回本机所有网卡的<网卡名, 地址, 子网掩码位数>\n   * @param[out] result 保存本机所有地址\n   * @param[in] family 协议族(AF_INT, AF_INT6, AF_UNIX)\n   * @return 是否获取成功\n   */\n  static bool GetInterfaceAddresses(\n      std::multimap<std::string, std::pair<Address::ptr, uint32_t> > &result,\n      int family = AF_INET);\n  /**\n   * @brief 获取指定网卡的地址和子网掩码位数\n   * @param[out] result 保存指定网卡所有地址\n   * @param[in] iface 网卡名称\n   * @param[in] family 协议族(AF_INT, AF_INT6, AF_UNIX)\n   * @return 是否获取成功\n   */\n  static bool GetInterfaceAddresses(\n      std::vector<std::pair<Address::ptr, uint32_t> > &result,\n      const std::string &iface, int family = AF_INET);\n...\n}\n\n```\n\n``` cpp\nAddress::ptr Address::Create(const sockaddr *address, socklen_t addrlen) {\n  if (address == nullptr) {\n    return nullptr;\n  }\n  Address::ptr result;\n  switch (address->sa_family) {\n    case AF_INET:\n      result.reset(new IPv4Address(*(const sockaddr_in *)address));\n      break;\n    case AF_INET6:\n      result.reset(new IPv6Address(*(const sockaddr_in6 *)address));\n      break;\n    default:\n      result.reset(new UnknownAddress(*address));\n      break;\n  }\n  // SYLAR_LOG_ERROR(g_logger) << \"result: \" << result->toString();\n  return result;\n}\n\n```\n\n下面两个都是调用的`Lookup`\n\n``` cpp\nstd::vector<Address::ptr> result;\nAddress::ptr Address::LookupAny(const std::string &host, int family, int type,\n                                int protocol) {\n  if (Lookup(result, host, family, type, protocol)) {\n    return result[0];\n  }\n  return nullptr;\n}\n\nstd::shared_ptr<IPAddress> Address::LookupAnyIPAddress(const std::string &host,\n                                                       int family, int type,\n                                                       int protocol) {\n  std::vector<Address::ptr> result;\n  if (Lookup(result, host, family, type, protocol)) {\n    for (auto &i : result) {\n      IPAddress::ptr v = std::dynamic_pointer_cast<IPAddress>(i);\n      if (v) {\n        return v;\n      }\n    }\n  }\n  return nullptr;\n}\n\n```\n\n## C 库函数 - memchr()\n\n### 描述\n\nC 库函数` void *memchr(const void *str, int c, size_t n) `在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。\n\n### 声明\n\n```cpp\nvoid *memchr(const void *str, int c, size_t n)\n\n```\n\n### 参数\n\n* str -- 指向要执行搜索的内存块。\n* c -- 以 int 形式传递的值，但是函数在每次字节搜索时是使用该值的无符号字符形式。\n* n -- 要被分析的字节数。\n\n### 返回值\n\n该函数返回一个指向匹配字节的指针，如果在给定的内存区域未出现字符，则返回 NULL。\n\n## substr\n\n函数的形式为`s.substr(pos, count)`（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）\n\n### 描述\n\n返回子串 `[pos, pos + count)`。如果请求的子串越过字符串的结尾，即 `count` 大于 `size() - pos`（例如 `count == npos`），那么返回的子串是 `[pos, size())`。\n\n### 参数\n\n* pos - 要包含的首个字符的位置\n* count - 子串的长度\n\n返回值\n含子串 `[pos, pos + count)` 或 `[pos, size())` 的字符串。\n\n异常\n在`pos > size()` 时抛出 `std::out_of_range。`\n\n如果因为任何原因抛出了异常，那么此函数无效果（强异常安全保证）。\n\n## host.c_str()\n\n`c_str()`函数返回一个指向正规C字符串的指针, 内容与本string串相同.\n\nC++中 `c_str( )`主要用法就是这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数`c_str()`把string 对象转换成c中的字符串样式。\n\n`c_str()` 以` char* `形式传回 `string` 内含字符串。\n\n示例：\n`(const char *)memchr(host.c_str() + 1, ']', host.size() - 1);`\n\n## getaddrinfo\n\n`int getaddrinfo( const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result );`\n函数的作用是帮你设置之后需要的struct，\n可用于将IP 地址的文本字符串表示形式转换为addrinfo 结构，该结构包含IP 地址和其他信息的sockaddr 结构\n\ngetaddrinfo 函数返回的是一个链表，因为一个主机名可能对应多个IP地址（IPv4和IPv6）。在实际使用中，你可以根据自己的需求选择合适的IP地址进行网络通信。\n\n### 参数说明\n\n* hostname​​参数是你想进行连接的服务器的域名，或者IP地址。\n* service：​​参数可以是个端口号，比如“​​80​​​”，或者是一个特定服务的名称，比如“​​http​​​”、“​​ftp​​​”、“​​telnet​​​”、“​​smtp​​” 等。\n* hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：指定的服务既可支持TCP也可支持UDP，所以调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。\n* result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。\n* 返回值：0——成功，非0——出错\n\n## Lookup\n\n``` cpp\n  /**\n   * @brief 通过host地址返回对应条件的所有Address\n   * @param[out] result 保存满足条件的Address\n   * @param[in] host 域名,服务器名等.举例: www.sylar.top[:80] (方括号为可选内容)\n   * @param[in] family 协议族(AF_INT, AF_INT6, AF_UNIX)\n   * @param[in] type socketl类型SOCK_STREAM、SOCK_DGRAM 等\n   * @param[in] protocol 协议,IPPROTO_TCP、IPPROTO_UDP 等\n   * @return 返回是否转换成功\n   */\n   bool Address::Lookup(std::vector<Address::ptr> &result, const std::string &host,\n                     int family, int type, int protocol) {\n  addrinfo hints, *results, *next;\n  hints.ai_flags = 0;\n  hints.ai_family = family;\n  hints.ai_socktype = type;\n  hints.ai_protocol = protocol;\n  hints.ai_addrlen = 0;\n  hints.ai_addr = NULL;\n  hints.ai_canonname = NULL;\n  hints.ai_next = NULL;\n\n  std::string node;\n  const char *service = NULL;\n\n  // 检查 ipv6address service 处理[:80] // 为什么时0,大小端问题？\n  if (!host.empty() && host[0] == '[') {\n    const char *endipv6 =\n        (const char *)memchr(host.c_str() + 1, ']', host.size() - 1);\n        // 找到 ']'\n    if (endipv6) {\n      // todo check out of range\n      if (*(endipv6 + 1) == ':') {\n        service = endipv6 + 2;\n      }\n      node = host.substr(1, endipv6 - host.c_str() - 1);\n    }\n  }\n  //检查 node serivce\n  if (node.empty()) {\n    service = (const char *)memchr(host.c_str(), ':', host.size());\n    if (service) {\n      if (!memchr(service + 1, ':', host.c_str() + host.size() - service - 1)) {\n        node = host.substr(0, service - host.c_str());\n        ++service;\n      }\n    }\n  }\n\n  if (node.empty()) {\n    node = host;\n  }\n\n  int error = getaddrinfo(node.c_str(), service, &hints, &results);\n  if (error) {\n    SYLAR_LOG_ERROR(g_logger)\n        << \"Address::Lookup getaddress(\" << host << \",\" << family << \",\" << type\n        << \") err=\" << error << \"errstr=\" << strerror(errno);\n    return false;\n  }\n\n  next = results;\n  while (next) {\n    result.push_back(Create(next->ai_addr, (socklen_t)next->ai_addrlen));\n    // SYLAR_LOG_INFO(g_logger) << ((sockaddr_in\n    // *)next->ai_addr)->sin_addr.s_addr;\n    next = next->ai_next;\n  }\n  freeaddrinfo(results);\n  return !result.empty();\n}\n```\n\n## IPAddress\n\n### create\n\n``` cpp\nIPAddress::ptr IPAddress::Create(const char *address, uint16_t port) {\n  addrinfo hints, *results;\n  memset(&hints, 0, sizeof(hints));\n\n  // AI_NUMERICHOST 标志用于指示 getaddrinfo\n  // 函数将主机名参数视为一个数值IP地址而不是一个主机名字符串。这对于需要直接使用IP地址而不是主机名的情况很有用。\n  // 当设置了 AI_NUMERICHOST 标志时，getaddrinfo\n  // 将不会尝试解析主机名，而是直接将主机名参数作为一个IP地址处理。\n  hints.ai_flags = AI_NUMERICHOST;\n  // ​ai_family​​​设置成了​​AF_UNSPEC​​​，也就意味着我压根不在意我们用IPv4还是IPv6,解析过程中支持多种地址类型。\n  hints.ai_family = AF_UNSPEC;\n  // ​getaddrinfo()​​​会在堆内存中创建​​results​指向的链表，使用完之后一定要使用​​freeaddrinfo()​​进行内存释放。\n  int error = getaddrinfo(address, NULL, &hints, &results);\n  if (error) {\n    SYLAR_LOG_DEBUG(g_logger) << \"IPAddress::Create(\" << address << \", \" << port\n                              << \") error=\" << error << \" errno=\" << errno\n                              << \" errstr=\" << strerror(errno);\n    return nullptr;\n  }\n\n  try {\n    IPAddress::ptr result = std::dynamic_pointer_cast<IPAddress>(\n        Address::Create(results->ai_addr, (socklen_t)results->ai_addrlen));\n\n    if (result) {\n      result->setPort(port);\n    }\n    freeaddrinfo(results);\n    return result;\n  } catch (...) {\n    freeaddrinfo(results);\n    return nullptr;\n  }\n}\n```\n\n## IPv4Address\n\n``` cpp\nIPv4Address::ptr IPv4Address::Create(const char *address, uint16_t port) {\n  // 创建 IPv4Address 对象的智能指针\n  IPv4Address::ptr rt = std::make_shared<IPv4Address>();\n\n  // 设置端口号，字节序转换为大端序\n  rt->m_addr.sin_port = byteswapOnBigEndian(port);\n\n  // 将字符串形式的 IP 地址转换为二进制形式\n  int result = inet_pton(AF_INET, address, &rt->m_addr.sin_addr);\n\n  // 检查转换是否成功\n  if (result <= 0) {\n    // 转换失败，记录错误日志并返回空指针\n    SYLAR_LOG_ERROR(g_logger) << \"IPv4Address::Create(\" << address << \", \"\n                              << port << \") rt=\" << result << \" errno=\" << errno\n                              << \" errstr=\" << strerror(errno);\n    return nullptr;\n  }\n\n  // 返回创建的 IPv4Address 对象智能指针\n  return rt;\n}\n```\n\n``` cpp\nstd::ostream &IPv4Address::insert(std::ostream &os) const {\n  // 将 IPv4 地址的二进制形式进行字节序转换\n  uint32_t addr = byteswapOnBigEndian(m_addr.sin_addr.s_addr);\n\n  // 将转换后的地址按照点分十进制形式输出到流中\n  os << ((addr >> 24) & 0xff) << \".\" << ((addr >> 16) & 0xff) << \".\"\n     << ((addr >> 8) & 0xff) << \".\" << (addr & 0xff);\n\n  // 输出端口号（字节序已转换）\n  os << \": \" << byteswapOnBigEndian(m_addr.sin_port);\n\n  // 返回更新后的输出流对象\n  return os;\n} \n```\n\n这个函数使用了模板，其中 T 是一个类型参数，表示返回值的类型。函数的目的是创建一个掩码，用于设置指定位数为1。\n\n函数内部，首先通过 sizeof(T) 获取类型 T 的字节大小，乘以8得到总位数。然后，从总位数中减去 bits 得到需要设置为0的位数。\n\n接下来，使用位操作符 << 将1左移需要设置为0的位数的位置，然后减去1。这样，就得到了一个掩码，其中指定位数为1，其余位数为0。\n\n``` cpp\ntemplate <class T>\nstatic T CreateMask(uint32_t bits) {\n  return (1 << (sizeof(T) * 8 - bits)) - 1;\n}\n```\n\n``` cpp\nIPAddress::ptr IPv4Address::broadcastAddress(uint32_t prefix_len) {\n  if (prefix_len > 32) {\n    // 前缀长度超过32，无效，返回空指针\n    return nullptr;\n  }\n\n  // 创建一个与当前地址相同的 sockaddr_in 结构体对象\n  sockaddr_in baddr(m_addr);\n\n  // 将广播地址的主机部分设置为前缀位全为1\n  baddr.sin_addr.s_addr |=\n      byteswapOnBigEndian(CreateMask<uint32_t>(prefix_len));\n\n  // 创建并返回一个指向新的 IPv4Address 对象的智能指针\n  return std::make_shared<IPv4Address>(baddr);\n}\n```\n\nnetworkAddress 函数，用于计算指定前缀长度的网络地址。它接受一个 prefix_len 参数作为前缀长度，并返回一个指向 IPv4Address 对象的智能指针，表示计算得到的网络地址。\n\n在函数内部，首先检查传入的前缀长度 prefix_len 是否超过了有效范围。如果超过了32，表示无效的前缀长度，函数返回空指针。\n\n接着，代码创建了一个与当前地址相同的 sockaddr_in 结构体对象 baddr，即使用当前地址的 IP 地址和端口号初始化了 baddr。\n\n然后，代码使用 CreateMask 函数创建一个前缀位全为1的掩码，并将其与网络地址的主机部分进行按位与操作，将主机部分的相应位设置为0，从而得到网络地址。\n\n最后，通过调用`std::make_shared<IPv4Address>(baddr)` 创建一个新的 IPv4Address 对象，并返回指向该对象的智能指针。\n\n``` cpp\nIPAddress::ptr IPv4Address::networkAddress(uint32_t prefix_len) {\n  if (prefix_len > 32) {\n    // 前缀长度超过32，无效，返回空指针\n    return nullptr;\n  }\n\n  // 创建一个与当前地址相同的 sockaddr_in 结构体对象\n  sockaddr_in baddr(m_addr);\n\n  // 将网络地址的主机部分设置为前缀位全为0\n  baddr.sin_addr.s_addr &=\n      byteswapOnBigEndian(CreateMask<uint32_t>(prefix_len));\n\n  // 创建并返回一个指向新的 IPv4Address 对象的智能指针\n  return std::make_shared<IPv4Address>(baddr);\n}\n```\n\n计算指定前缀长度的子网掩码。它接受一个 prefix_len 参数作为前缀长度，并返回一个指向 IPv4Address 对象的智能指针，表示计算得到的子网掩码。\n\n在函数内部，首先创建一个 sockaddr_in 结构体对象 subnet，并使用 memset 函数将其内存空间初始化为0。然后，设置 subnet 的地址族为 AF_INET，表示IPv4地址族。\n\n代码使用 CreateMask 函数创建一个前缀位全为1的掩码，并对其进行按位取反操作 ~，将前缀位设置为0。\n\n最后，将计算得到的子网掩码的主机部分赋值给 subnet.sin_addr.s_addr，表示子网掩码的二进制形式。\n\n``` cpp\nIPAddress::ptr IPv4Address::subnetMask(uint32_t prefix_len) {\n  sockaddr_in subnet;\n  memset(&subnet, 0, sizeof(subnet));\n  subnet.sin_family = AF_INET;\n\n  // 将子网掩码的主机部分设置为前缀位全为0\n  subnet.sin_addr.s_addr =\n      ~byteswapOnBigEndian(CreateMask<uint32_t>(prefix_len));\n\n  // 创建并返回一个指向新的 IPv4Address 对象的智能指针\n  return std::make_shared<IPv4Address>(subnet);\n}\n```\n","tags":["sylar"],"categories":["sylar"]},{"title":"配置模块","url":"/2023/11/05/sylar/模块/配置模块/","content":"\n## sylar配置模块设计\n\n采用约定优于配置的思想\n\n[维基百科：约定优于配置](https://zh.wikipedia.org/wiki/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE)\n\n### ConfigVarBase\n\n配置项基类，虚基类，定义了配置项公有的成员和方法。\n\nsylar对每个配置项都包括名称和描述两项成员，以及toString/fromString两个纯虚函数方法。ConfigVarBase并不包含配置项类型和值，这些由继承类实现，由继承类实现的还包括具体类型的toString/fromString方法，用于和YAML字符串进行相互转换。\n\n``` cpp\n\nclass ConfigVarBase {\n public:\n  using ptr = std::shared_ptr<ConfigVarBase>;\n\n  /**\n   * @brief 构造函数\n   * @param[in] name 配置参数名称[0-9a-z_.]\n   * @param[in] description 配置参数描述\n   */\n  ConfigVarBase(const std::string &name, const std::string &description)\n      : m_name(name), m_description(description) {}\n  virtual ~ConfigVarBase() {}\n\n  const std::string &getName() const { return m_name; }\n  const std::string &getDescription() const { return m_description; }\n  /**\n   * @brief 转成字符串\n   */\n  virtual std::string toString() = 0;\n  /**\n   * @brief 从字符串初始化值\n   */\n  virtual bool fromString(const std::string &val) = 0;\n  /**\n   * @brief 返回配置参数值的类型名称\n   */\n  virtual std::string getTypeName() const = 0;\n\n protected:\n  /// 配置参数的名称\n  std::string m_name;\n  /// 配置参数的描述\n  std::string m_description;\n};\n\n```\n\n### LexicalCast\n\nsylar从一个基本类型的转换类开始，特化出了剩余类型的转换类。\n这里的LexicalCast类是一个仿函数，关于访函数看这里。它支持`LexicalCast<F, T>()(const F &v)`调用，可将传入的F类型的参数v进行转换，并返回T类型的结果。实际的转换语句是`boost::lexical_cast<T>(v)`。但是，受限于`boost::lexical_cast`, `LexicalCast`当前只能实现基本数据类型和`std::string`的相互转换。\n\n```cpp\n/**\n * @brief 类型转换模板类(F 源类型, T 目标类型)\n */\n// F from_type , T to_type\ntemplate <class F, class T>\nclass LexicalCast {\n public:\n  /**\n   * @brief 类型转换\n   * @param[in] v 源类型值\n   * @return 返回v转换后的目标类型\n   * @exception 当类型不可转换时抛出异常\n   */\n  T operator()(const F &v) { return boost::lexical_cast<T>(v); }\n};\n```\n\nsylar了实现YAML字符串和vector/list/set/unordered_set/map/unordered_map的相互转换。\n每个类型都进行特化，分别实现其转换类，下面仅列出YAML字符串和vector的相互转换实现，其他的见源码：\n\n``` cpp\n\n// 类型和类内成员的二义性，typename\n// string to vector\n/**\n * @brief 类型转换模板类片特化(YAML String 转换成 std::vector<T>)\n */\ntemplate <class T>\nclass LexicalCast<std::string, std::vector<T>> {\n public:\n  std::vector<T> operator()(const std::string &v) {\n    YAML::Node node = YAML::Load(v);\n    typename std::vector<T> vec;\n    std::stringstream ss;\n    for (size_t i = 0; i < node.size(); ++i) {\n      // 清空ss\n      ss.str(\"\");\n      ss << node[i];\n      vec.push_back(LexicalCast<std::string, T>()(ss.str()));\n    }\n    return vec;\n  }\n};\n\n/**\n * @brief 类型转换模板类片特化(std::vector<T> 转换成 YAML String)\n */\n// vector to string\ntemplate <class T>\nclass LexicalCast<std::vector<T>, std::string> {\n public:\n  std::string operator()(const std::vector<T> &v) {\n    YAML::Node node;\n    for (const auto &i : v) {\n      // 可以嵌套\n      node.push_back(YAML::Load(LexicalCast<T, std::string>()(i)));\n    }\n    std::stringstream ss;\n    ss << node;\n    return ss.str();\n  }\n};\n```\n\n上面分别实现了`LexicalCast<std::string, std::vector<T>>`和`LexicalCast<std::vector<T>, std::string>`，其中在转换单个的数组元素时，再次用到了`LexicalCast<std::string, T>`和`LexicalCast<T, std::string>`，\n\n* 如果这里T是基本数据类型，那么就可以用最开始的基本类型的转换类进行模板实例化并完成转换了。\n* 这里的模板实例化是可以嵌套的，如果T不是基本类型，则继续嵌套。`node.push_back(YAML::Load(LexicalCast<T, std::string>()(i)));`这里T可以继续是`vector<T>`。\n\n### ConfigVar\n\n具体的配置参数类，继承自ConfigVarBase，并且是一个模板类，有3个模板参数。第一个模板参数是类型T，表示配置项的类型。另外两个模板参数是FromStr和ToStr，这两个参数是仿函数，FromStr用于将YAML字符串转类型T，ToStr用于将T转YAML字符串。这两个模板参数具有默认值LexicalCast<std::string, T>和LexicalCast<T, std::string>，根据不同的类型T，FromStr和ToStr具有不同的偏特化实现。\n\n``` cpp\n/**\n * @brief 配置参数模板子类,保存对应类型的参数值\n * @details T 参数的具体类型\n *          FromStr 从std::string转换成T类型的仿函数\n *          ToStr 从T转换成std::string的仿函数\n *          std::string 为YAML格式的字符串\n */\ntemplate <class T, class FromStr = LexicalCast<std::string, T>,\n          class ToStr = LexicalCast<T, std::string>>\nclass ConfigVar : public ConfigVarBase {\n public:\n  typedef RWMutex RWMutexType;\n  using ptr = std::shared_ptr<ConfigVar>;\n  using on_change_cb =\n      std::function<void(const T &old_value, const T &new_value)>;\n\n  /**\n   * @brief 通过参数名,参数值,描述构造ConfigVar\n   * @param[in] name 参数名称有效字符为[0-9a-z_.]\n   * @param[in] default_value 参数的默认值\n   * @param[in] description 参数的描述\n   */\n  ConfigVar(const std::string name, const T &default_value,\n            const std::string description)\n      : ConfigVarBase(name, description), m_val(default_value) {}\n\n  /**\n   * @brief 将参数值转换成YAML String\n   * @exception 当转换失败抛出异常\n   */\n  std::string toString() override {\n    try {\n      // return boost::lexical_cast<std::string>(m_val);\n      RWMutexType::ReadLock lock(m_mutex);\n      return ToStr()(m_val);\n    } catch (std::exception &e) {\n      SYLAR_LOG_ERROR(SYLAR_LOG_ROOT())\n          << \"configVar::toString exception\" << e.what()\n          << \" convert: \" << typeid(m_val).name() << \"to string\";\n    }\n    return \"\";\n  }\n\n  /**\n   * @brief 从YAML String 转成参数的值\n   * @exception 当转换失败抛出异常\n   */\n  bool fromString(const std::string &val) override {\n    try {\n      // boost::lexical_cast<T>(m_val);\n      setValue(FromStr()(val));\n    } catch (std::exception &e) {\n      SYLAR_LOG_ERROR(SYLAR_LOG_ROOT())\n          << \"configVar::toString exception\" << e.what()\n          << \" convert: to string \" << typeid(m_val).name() << \" - \" << val;\n    }\n    return false;\n  }\n\n  /**\n   * @brief 获取当前参数的值\n   */\n  const T getValue() {\n    RWMutexType::ReadLock lock(m_mutex);\n    return m_val;\n  }\n\n  /**\n   * @brief 设置当前参数的值\n   * @details 如果参数的值有发生变化,则通知对应的注册回调函数\n   */\n  void setValue(T val) {\n    {  // 加括号是 产生一个局部域，出了括号，就会释放锁\n      RWMutexType::ReadLock lock(m_mutex);\n      if (val == m_val) {\n        return;\n      }\n    }\n    RWMutexType::WriteLock lock(m_mutex);\n    for (auto &i : m_cbs) {\n      // func\n      i.second(m_val, val);\n    }\n    m_val = val;\n  }\n\n  /**\n   * @brief 返回参数值的类型名称(typeinfo)\n   */\n  std::string getTypeName() const override { return typeid(T).name(); }\n\n  /**\n   * @brief 添加变化回调函数\n   * @return 返回该回调函数对应的唯一id,用于删除回调\n   */\n  u_int64_t addListener(on_change_cb cb) {\n    static u_int64_t s_fun_id = 0;\n    RWMutexType::WriteLock lock(m_mutex);\n    ++s_fun_id;\n    m_cbs[s_fun_id] = cb;\n    return s_fun_id;\n  }\n\n  /**\n   * @brief 删除回调函数\n   * @param[in] key 回调函数的唯一id\n   */\n  void delListener(u_int64_t key, on_change_cb) {\n    RWMutexType::WriteLock lock(m_mutex);\n    m_cbs.erase(key);\n  }\n\n  /**\n   * @brief 获取回调函数\n   * @param[in] key 回调函数的唯一id\n   * @return 如果存在返回对应的回调函数,否则返回nullptr\n   */\n  on_change_cb getListener(u_int64_t key) {\n    RWMutexType::ReadLock lock(m_mutex);\n    auto it = m_cbs.find(key);\n    return it == m_cbs.end() ? nullptr : it->second;\n  }\n  /**\n   * @brief 清理所有的回调函数\n   *\n   */\n  void clearListener() { m_cbs.clear(); }\n\n private:\n  RWMutexType m_mutex;\n  T m_val;\n  // 变更回调函数组，u_int64_t key 要求唯一， 一般可以用hash\n  std::map<u_int64_t, on_change_cb> m_cbs;\n};\n```\n\n### Config\n\nConfigVar的管理类，负责管理全部的ConfigVar对象，单例模式。\n\n提供Lookup方法，用于根据配置名称查询配置项。如果调用Lookup查询时同时提供了默认值和配置项的描述信息，那么在未找到对应的配置时，会自动创建一个对应的配置项，这样就保证了配置模块定义即可用的特性。\n\n``` cpp\n  /**\n   * @brief 获取/创建对应参数名的配置参数\n   * @param[in] name 配置参数名称\n   * @param[in] default_value 参数默认值\n   * @param[in] description 参数描述\n   * @details 获取参数名为name的配置参数,如果存在直接返回\n   *          如果不存在,创建参数配置并用default_value赋值\n   * @return 返回对应的配置参数,如果参数名存在但是类型不匹配则返回nullptr\n   * @exception 如果参数名包含非法字符[^0-9a-z_.] 抛出异常 std::invalid_argument\n   */\n  template <class T>\n  static typename ConfigVar<T>::ptr Lookup(const std::string &name,\n                                           const T &default_value,\n                                           const std::string &description) {\n    RWMutexType::WriteLock lock(GetMutex());\n    auto it = GetDatas().find(name);\n    if (it != GetDatas().end()) {\n      auto tmp = std::dynamic_pointer_cast<ConfigVar<T>>(it->second);\n\n      if (tmp) {\n        SYLAR_LOG_INFO(SYLAR_LOG_ROOT())\n            << \"Lookup name = \" << name << \" exists\";\n        return tmp;\n      } else {\n        SYLAR_LOG_ERROR(SYLAR_LOG_ROOT())\n            << \"Lookup name= \" << name << \" exits but type not \"\n            << typeid(T).name() << \" read_type= \" << it->second->getTypeName()\n            << \" \" << it->second->toString();\n        return nullptr;\n      }\n    }\n\n    if (name.find_first_not_of(\"abcdefghijklmnopqrstuvwxyz._12345678\") !=\n        std::string::npos) {\n      SYLAR_LOG_INFO(SYLAR_LOG_ROOT()) << \"Lookup name invalid \" << name;\n      throw std::invalid_argument(name);\n    }\n\n    typename ConfigVar<T>::ptr v =\n        std::make_shared<ConfigVar<T>>(name, default_value, description);\n    // s_datas[name] = v;\n    GetDatas()[name] = v;\n    return v;\n  }\n\n```\n\nLoadFromYaml用于从YAML对象指定的配置文件路径中加载配置。\n\n```cpp\nvoid Config::LoadFromYaml(const YAML::Node &root) {\n  std::list<std::pair<std::string, const YAML::Node>> all_nodes;\n  ListAllMember(\"\", root, all_nodes);\n\n  for (auto &i : all_nodes) {\n    std::string key = i.first;\n    if (key.empty()) {\n      continue;\n    }\n\n    std::transform(key.begin(), key.end(), key.begin(), ::tolower);\n    ConfigVarBase::ptr var = LookupBase(key);\n\n    if (var) {\n      if (i.second.IsScalar()) {\n        var->fromString(i.second.Scalar());\n      } else {\n        std::stringstream ss;\n        ss << i.second;\n        var->fromString(ss.str());\n      }\n    }\n  }\n}\n\n```\n\nConfig的全部成员变量和方法都是static类型，保证了全局只有一个实例。这里要注意静态函数和静态变量初始化问题：\n静态函数先初始化，静态变量还未初始化，就到用此静态变量时，会出现问题。\n\n``` cpp\n  // 创建全局变量，静态成员的话，静态成员的初始化的顺序，比调用此成员的方法晚，就会出现内存错误\n  /**\n   * @brief 配置项的RWMutex\n   */\n  static RWMutexType &GetMutex() {\n    static RWMutexType s_mutex;\n    return s_mutex;\n  }\n```\n\n## 参考\n\n<https://www.midlane.top/wiki/pages/viewpage.action?pageId=10061021>\n","tags":["sylar"],"categories":["sylar"]},{"title":"C++中string::npos","url":"/2023/11/02/sylar/c++/C-中string-npos/","content":"\nnpos是一个常数，表示size_t的最大值（Maximum value for size_t）\n\n``` cpp\nType: const size_type (aka const unsigned long)\nValue = 18446744073709551615 (0xffffffffffffffff)\n```\n\n## npos的用法\n\nnpos可以表示string的结束位置，是string::type_size 类型的。\nstring 类提供了 6 种查找函数,每种函数以不同形式的 find 命名。这些操作全都返回 string::size_type 类型的值，以下标形式标记查找匹配所发生的位置；或者返回一个名为 string::npos 的特殊值，说明查找没有匹配。string 类将 npos 定义为保证大于任何有效下标的值。\n\n## sylar\n\n``` cpp\n  template <class T>\n  static typename ConfigVar<T>::ptr Lookup(const std::string &name,\n                                           const T &default_value,\n                                           const std::string &description) {\n    RWMutexType::WriteLock lock(GetMutex());\n    auto it = GetDatas().find(name);\n    if (it != GetDatas().end()) {\n      auto tmp = std::dynamic_pointer_cast<ConfigVar<T>>(it->second);\n\n      if (tmp) {\n        SYLAR_LOG_INFO(SYLAR_LOG_ROOT())\n            << \"Lookup name = \" << name << \" exists\";\n        return tmp;\n      } else {\n        SYLAR_LOG_ERROR(SYLAR_LOG_ROOT())\n            << \"Lookup name= \" << name << \" exits but type not \"\n            << typeid(T).name() << \" read_type= \" << it->second->getTypeName()\n            << \" \" << it->second->toString();\n        return nullptr;\n      }\n    }\n\n    if (name.find_first_not_of(\"abcdefghijklmnopqrstuvwxyz._12345678\") !=\n        std::string::npos) {\n      SYLAR_LOG_INFO(SYLAR_LOG_ROOT()) << \"Lookup name invalid \" << name;\n      throw std::invalid_argument(name);\n    }\n\n    typename ConfigVar<T>::ptr v =\n        std::make_shared<ConfigVar<T>>(name, default_value, description);\n    // s_datas[name] = v;\n    GetDatas()[name] = v;\n    return v;\n  }\n```\n\n`find_first_not_of`\n在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::npos\n","tags":["sylar"]},{"title":"IO协程调度模块","url":"/2023/11/02/sylar/模块/IOManager/","content":"# IO协程调度模块\n\n继承自协程调度器，封装了epoll，支持为socket fd注册读写事件回调函数。\n![Alt text](../../../images/iomanager.drawio.png)\n\nIO协程调度还解决了调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。\n\n## IO协程调度概述\n\n在前面的协程调度模块中，调度器对协程的调度是无条件执行的，在调度器已经启动调度的情况下，任务一旦添加成功，就会排队等待调度器执行。调度器不支持删除调度任务，并且调度器在正常退出之前一定会执行完全部的调度任务，所以在某种程度上可以认为，把一个协程添加到调度器的任务队列，就相当于调用了协程的resume方法。\n\nIO协程调度支持协程调度的全部功能，因为IO协程调度器是直接继承协程调度器实现的。除了协程调度，IO协程调度还增加了IO事件调度的功能，这个功能是针对描述符（一般是套接字描述符）的。IO协程调度支持为描述符注册可读和可写事件的回调函数，当描述符可读或可写时，执行对应的回调函数。（这里可以直接把回调函数等效成协程，所以这个功能被称为IO协程调度）\n\n## sylar IO协程调度模块设计\n\n对于IO协程调度来说，每次调度都包含一个三元组信息，分别是描述符-事件类型（可读或可写）-回调函数，调度器记录全部需要调度的三元组信息，其中描述符和事件类型用于epoll_wait，回调函数用于协程调度。这个三元组信息在源码上通过FdContext结构体来存储，在执行epoll_wait时通过epoll_event的私有数据指针data.ptr来保存FdContext结构体信息。\n\nIO协程调度器在idle时会epoll_wait所有注册的fd，如果有fd满足条件，epoll_wait返回，从私有数据中拿到fd的上下文信息，并且执行其中的回调函数。（实际是idle协程只负责收集所有已触发的fd的回调函数并将其加入调度器的任务队列，真正的执行时机是idle协程退出后，调度器在下一轮调度时执行）\n\n与协程调度器不一样的是，IO协程调度器支持取消事件。取消事件表示不关心某个fd的某个事件了，如果某个fd的可读或可写事件都被取消了，那这个fd会从调度器的epoll_wait中删除。\n\n## sylar IO协程调度器实现\n\n### read和write\n\n``` cpp\nssize_t read(int fd, void *buf, size_t count);\n参数：\nfd：文件描述符\n\nbuf：存数据的缓冲区\n\ncount：缓冲区大小\n\n返回值：\n0：读到文件末尾。\n\n成功； > 0 读到的字节数。\n\n失败： -1， 设置 errno\n\n\nssize_t write(int fd,const void*buf,size_t count);\n参数说明：\n  fd:是文件描述符\n  buf:通常是一个字符串，需要写入的字符串\n  count：是每次写入的字节数\n\n返回值：\n成功：返回写入的字节数\n失败：返回-1并设置errno\nps： 写常规文件时，write的返回值通常等于请求写的字节数count， 而向终端设备或者网络写时则不一定\n```\n\n### IO协程调度器对应IOManager\n\n这个类直接继承自Scheduler和TimerManager\n\n``` cpp\n\nclass IOManager : public Scheduler ，public TimerManager {\npublic:\n    typedef std::shared_ptr<IOManager> ptr;\n    typedef RWMutex RWMutexType;\n...\n}\n```\n\n### 首先是读写事件的定义，这里直接继承epoll的枚举值\n\n```cpp\n/**\n * @brief IO事件，继承自epoll对事件的定义\n * @details 这里只关心socket fd的读和写事件，其他epoll事件会归类到这两类事件中\n */\nenum Event {\n    /// 无事件\n    NONE = 0x0,\n    /// 读事件(EPOLLIN)\n    READ = 0x1,\n    /// 写事件(EPOLLOUT)\n    WRITE = 0x4,\n};\n```\n\n### 描述符-事件类型-回调函数三元组的定义\n\n这个三元组也称为fd上下文，使用结构体FdContext来表示。由于fd有可读和可写两种事件，每种事件的回调函数也可以不一样，所以每个fd都需要保存两个事件类型-回调函数组合。FdContext结构体定义如下：\n\n```cpp\n/**\n * @brief socket fd上下文类\n * @details 每个socket fd都对应一个FdContext，包括fd的值，fd上的事件，以及fd的读写事件上下文\n */\nstruct FdContext {\n    typedef Mutex MutexType;\n    /**\n     * @brief 事件上下文类\n     * @details fd的每个事件都有一个事件上下文，保存这个事件的回调函数以及执行回调函数的调度器\n     *          sylar对fd事件做了简化，只预留了读事件和写事件，所有的事件都被归类到这两类事件中\n     */\n    struct EventContext {\n        /// 执行事件回调的调度器\n        Scheduler *scheduler = nullptr;\n        /// 事件回调协程\n        Fiber::ptr fiber;\n        /// 事件回调函数\n        std::function<void()> cb;\n    };\n \n    /**\n     * @brief 获取事件上下文类\n     * @param[in] event 事件类型\n     * @return 返回对应事件的上下文\n     */\n    EventContext &getEventContext(Event event);\n \n    /**\n     * @brief 重置事件上下文\n     * @param[in, out] ctx 待重置的事件上下文对象\n     */\n    void resetEventContext(EventContext &ctx);\n \n    /**\n     * @brief 触发事件\n     * @details 根据事件类型调用对应上下文结构中的调度器去调度回调协程或回调函数\n     * @param[in] event 事件类型\n     */\n    void triggerEvent(Event event);\n \n    /// 读事件上下文\n    EventContext read;\n    /// 写事件上下文\n    EventContext write;\n    /// 事件关联的句柄\n    int fd = 0;\n    /// 该fd添加了哪些事件的回调函数，或者说该fd关心哪些事件\n    Event events = NONE;\n    /// 事件的Mutex\n    MutexType mutex;\n};\n```\n\n### IOManager的成员变量\n\nIOManager包含一个epoll实例的句柄m_epfd以及用于tickle的一对pipe fd，还有全部的fd上下文m_fdContexts，如下：\n\n``` cpp\n/// epoll 文件句柄\nint m_epfd = 0;\n/// pipe 文件句柄，fd[0]读端，fd[1]写端\nint m_tickleFds[2];\n/// 当前等待执行的IO事件数量\nstd::atomic<size_t> m_pendingEventCount = {0};\n/// IOManager的Mutex\nRWMutexType m_mutex;\n/// socket事件上下文的容器\nstd::vector<FdContext *> m_fdContexts;\n```\n\n### 继承类IOManager中改造协程调度器\n\n使其支持epoll，并重载tickle和idle，实现通知调度协程和IO协程调度功能。\n**IOManager创建即可调度协程**\n\n``` cpp\n/**\n * @brief 构造函数\n * @param[in] threads 线程数量\n * @param[in] use_caller 是否将调用线程包含进去\n * @param[in] name 调度器的名称\n */\nIOManager::IOManager(size_t threads, bool use_caller, const std::string &name)\n    : Scheduler(threads, use_caller, name) {\n    // 创建epoll实例\n    m_epfd = epoll_create(5000);\n    SYLAR_ASSERT(m_epfd > 0);\n     \n    // 创建pipe，获取m_tickleFds[2]，其中m_tickleFds[0]是管道的读端，m_tickleFds[1]是管道的写端\n    int rt = pipe(m_tickleFds);\n    SYLAR_ASSERT(!rt);\n \n    // 注册pipe读句柄的可读事件，用于tickle调度协程，通过epoll_event.data.fd保存描述符\n    epoll_event event;\n    memset(&event, 0, sizeof(epoll_event));\n    event.events  = EPOLLIN | EPOLLET;\n    event.data.fd = m_tickleFds[0];\n \n    // 非阻塞方式，配合边缘触发\n    rt = fcntl(m_tickleFds[0], F_SETFL, O_NONBLOCK);\n    SYLAR_ASSERT(!rt);\n \n    // 将管道的读描述符加入epoll多路复用，如果管道可读，idle中的epoll_wait会返回\n    rt = epoll_ctl(m_epfd, EPOLL_CTL_ADD, m_tickleFds[0], &event);\n    SYLAR_ASSERT(!rt);\n \n    contextResize(64);\n \n    // 这里直接开启了Schedluer，也就是说IOManager创建即可调度协程\n    start();\n}\n \n/**\n * @brief 通知调度器有任务要调度\n * @details 写pipe让idle协程从epoll_wait退出，待idle协程yield之后Scheduler::run就可以调度其他任务\n * 如果当前没有空闲调度线程，那就没必要发通知\n */\nvoid IOManager::tickle() {\n    SYLAR_LOG_DEBUG(g_logger) << \"tickle\";\n    // 如果没有空闲线程，就直接返回\n    if(!hasIdleThreads()) {\n        return;\n    }\n    int rt = write(m_tickleFds[1], \"T\", 1);\n    SYLAR_ASSERT(rt == 1);\n}\n\n /**\n * @brief idle协程\n * @details\n * 对于IO协程调度来说，应阻塞在等待IO事件上，idle退出的时机是epoll_wait返回，对应的操作是tickle或注册的IO事件就绪\n * 调度器无调度任务时会阻塞idle协程上，对IO调度器而言，idle状态应该关注两件事，一是有没有新的调度任务，对应Schduler::schedule()，\n * 如果有新的调度任务，那应该立即退出idle状态，并执行对应的任务；二是关注当前注册的所有IO事件有没有触发，如果有触发，那么应该执行\n * IO事件对应的回调函数\n */\nvoid IOManager::idle() {\n  // 一次epoll_wait最多检测256个就绪事件，如果就绪事件超过了这个数，那么会在下轮epoll_wati继续处理\n  const uint64_t MAX_EVNETS = 256;\n  epoll_event *events = new epoll_event[MAX_EVNETS]();\n  std::shared_ptr<epoll_event> shared_events(events, [](epoll_event *ptr) {\n    // delete[] events; //error\n    // 传进来的是ptr\n    delete[] ptr;\n  });\n\n  while (true) {\n    uint64_t next_timeout = 0;\n    if (stopping(next_timeout)) {\n      SYLAR_LOG_INFO(g_logger) << \"name=\" << getName() << \"idle stopping exit\";\n      break;\n    }\n\n    int rt = 0;\n    do {\n      static const int MAX_TIMEOUT = 3000;\n      if (next_timeout != ~0ull) {\n        next_timeout = static_cast<int>(next_timeout) > MAX_TIMEOUT ? MAX_TIMEOUT : next_timeout;\n      } else {\n        next_timeout = MAX_TIMEOUT;\n      }\n      // 阻塞在epoll_wait上，等待事件发生\n      rt = epoll_wait(m_epfd, events, 64, static_cast<int>(next_timeout));\n\n      if (rt < 0 && errno == EINTR) {\n      } else {\n        break;\n      }\n    } while (true);\n\n    std::vector<std::function<void()>> cbs;\n    listExpiredCb(cbs);\n\n    if (!cbs.empty()) {\n      schedule(cbs.begin(), cbs.end());\n      cbs.clear();\n    }\n\n    // 遍历所有发生的事件，根据epoll_event的私有指针找到对应的FdContext，进行事件处理\n    for (int i = 0; i < rt; ++i) {\n      epoll_event &event = events[i];\n      // SYLAR_LOG_INFO(g_logger) << event.data.fd;\n      // 处理tickle() 的情况\n      if (event.data.fd == m_tickleFds[0]) {\n        // ticklefd[0]用于通知协程调度，这时只需要把管道里的内容读完即可，本轮idle结束Scheduler::run会重新执行协程调度\n        u_int8_t dummy;\n\n        while (read(m_tickleFds[0], &dummy, 1) == 1)\n          ;\n\n        continue;\n      }\n      // 通过epoll_event的私有指针获取FdContext\n      FdContext *fd_ctx = static_cast<FdContext *>(event.data.ptr);\n      FdContext::MutexType::Lock lock(fd_ctx->mutex);\n      /**\n       * EPOLLERR: 出错，比如写读端已经关闭的pipe\n       * EPOLLHUP: 套接字对端关闭\n       * 出现这两种事件，应该同时触发fd的读和写事件，否则有可能出现注册的事件永远执行不到的情况\n       */\n      if (event.events & (EPOLLERR | EPOLLHUP)) {\n        event.events |= (EPOLLIN | EPOLLOUT) & fd_ctx->events;\n      }\n      int real_events = NONE;\n      if (event.events & EPOLLIN) {\n        real_events |= READ;\n      }\n      if (event.events & EPOLLOUT) {\n        real_events |= WRITE;\n      }\n\n      if ((fd_ctx->events & real_events) == NONE) {\n        continue;\n      }\n\n      // 剔除已经发生的事件，将剩下的事件重新加入epoll_wait，\n      // 如果剩下的事件为0，表示这个fd已经不需要关注了，直接从epoll中删除\n      int left_events = (fd_ctx->events & ~real_events);\n      int op = left_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;\n      event.events = EPOLLET | left_events;\n\n      int rt2 = epoll_ctl(m_epfd, op, fd_ctx->fd, &event);\n      if (rt2) {\n        SYLAR_LOG_ERROR(g_logger) << \"epoll_ctl(\" << m_epfd << \",\" << op << \", \" << fd_ctx->fd\n                                  << \",\" << event.events << \"):\" << rt2 << \"(\" << errno << \") (\"\n                                  << strerror(errno) << \")\";\n        continue;\n      }\n\n      // 处理已经发生的事件，也就是让调度器调度指定的函数或协程\n      if (real_events & READ) {\n        // 有trigger 数量减一\n        fd_ctx->triggerEvent(READ);\n        --m_pendingEventCount;\n      }\n\n      if (real_events & WRITE) {\n        fd_ctx->triggerEvent(WRITE);\n        --m_pendingEventCount;\n      }\n    }\n\n    /**\n     * 一旦处理完所有的事件，idle协程swapOut，这样可以让调度协程(Scheduler::run)重新检查是否有新任务要调度\n     * 上面triggerEvent实际也只是把对应的fiber重新加入调度，要执行的话还要等idle协程退出.\n     */\n    Fiber::ptr cur = Fiber::GetThis();\n    auto raw_ptr = cur.get();\n    cur.reset();\n\n    // 切换到调度协程，执行任务\n    raw_ptr->swapOut();\n  }\n}\n```\n\n### 注册事件回调addEvent\n\n``` cpp\n/**\n * @brief 添加事件\n * @details fd描述符发生了event事件时执行cb函数\n * @param[in] fd socket句柄\n * @param[in] event 事件类型\n * @param[in] cb 事件回调函数，如果为空，则默认把当前协程作为回调执行体\n * @return 添加成功返回0,失败返回-1\n */\nint IOManager::addEvent(int fd, Event event, std::function<void()> cb) {\n  FdContext *fd_ctx = nullptr;\n  // 读锁\n  RWMutexType::ReadLock lock(m_mutex);\n  if (static_cast<int>(m_fdContexts.size()) > fd) {\n    // 优化 直接在if中加读锁\n    fd_ctx = m_fdContexts[fd];\n    lock.unlock();\n  } else {\n    lock.unlock();\n    RWMutexType::WriteLock lock2(m_mutex);\n    contextResize(fd * 1.5);\n    fd_ctx = m_fdContexts[fd];\n  }\n  // 同一个fd不允许重复添加相同的事件\n  FdContext::MutexType::Lock lock2(fd_ctx->mutex);\n  if (fd_ctx->events & event) {\n    SYLAR_LOG_ERROR(g_logger) << \"addEvent assert fd = \" << fd << \"event= \" << event\n                              << \"fd_ctx->events=\" << fd_ctx->events;\n    SYLAR_ASSERT(!(fd_ctx->events & event));\n  }\n\n  // 将新的事件加入epoll_wait，使用epoll_event的私有指针存储FdContext的位置\n  int op = fd_ctx->events ? EPOLL_CTL_MOD : EPOLL_CTL_ADD;\n  epoll_event epevent;\n  epevent.events = EPOLLET | fd_ctx->events | event;\n  epevent.data.ptr = fd_ctx;\n\n  int rt = epoll_ctl(m_epfd, op, fd, &epevent);\n  if (rt) {\n    SYLAR_LOG_ERROR(g_logger) << \"epoll_ctl(\" << m_epfd << \",\" << op << \", \" << fd << \",\"\n                              << epevent.events << \"):\" << rt << \"(\" << errno << \") (\"\n                              << strerror(errno) << \")\";\n    return -1;\n  }\n\n  // 待执行IO事件数加1\n  ++m_pendingEventCount;\n\n  // 找到这个fd的event事件对应的EventContext，对其中的scheduler, cb, fiber进行赋值\n  fd_ctx->events = (Event)(fd_ctx->events | event);\n  FdContext::EventContext &event_ctx = fd_ctx->getContext(event);\n  SYLAR_ASSERT(!event_ctx.scheduler && !event_ctx.fiber && !event_ctx.cb);\n\n  // 赋值scheduler和回调函数，如果回调函数为空，则把当前协程当成回调执行体\n  event_ctx.scheduler = Scheduler::GetThis();\n  if (cb) {\n    event_ctx.cb.swap(cb);\n  } else {\n    event_ctx.fiber = Fiber::GetThis();\n    SYLAR_ASSERT2(event_ctx.fiber->getState() == Fiber::EXEC,\n                  \"state=\" << event_ctx.fiber->getState());\n  }\n  return 0;\n}\n```\n\n### 删除事件回调delEvent\n\n``` cpp\n/**\n * @brief 删除事件\n * @param[in] fd socket句柄\n * @param[in] event 事件类型\n * @attention 不会触发事件\n * @return 是否删除成功\n */\nbool IOManager::delEvent(int fd, Event event) {\n  RWMutexType::ReadLock lock(m_mutex);\n  if (static_cast<int>(m_fdContexts.size()) <= fd) {\n    return false;\n  }\n  // 直接使用fd的值作为FdContext数组的下标\n  FdContext *fd_ctx = m_fdContexts[fd];\n  lock.unlock();\n  FdContext::MutexType::Lock lock2(fd_ctx->mutex);\n  if (!(fd_ctx->events & event)) {\n    return false;\n  }\n\n  // 清除指定的事件，表示不关心这个事件了，如果清除之后结果为0，则从epoll_wait中删除该文件描述符\n  Event new_events = (Event)(fd_ctx->events & ~event);\n  int op = new_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;\n  epoll_event epevent;\n  epevent.events = EPOLLET | new_events;\n  epevent.data.ptr = fd_ctx;\n\n  int rt = epoll_ctl(m_epfd, op, fd, &epevent);\n  if (rt) {\n    SYLAR_LOG_ERROR(g_logger)\n        << \"epoll_ctl(\" << m_epfd << \",\" << op << \", \" << fd << \",\"\n        << epevent.events << \"):\" << rt << \"(\" << errno << \") (\"\n        << strerror(errno) << \")\";\n    return false;\n  }\n\n  --m_pendingEventCount;\n  // 重置该fd对应的event事件上下文\n  fd_ctx->events = new_events;\n  FdContext::EventContext &event_ctx = fd_ctx->getContext(event);\n  fd_ctx->resetContext(event_ctx);\n  return true;\n}\n```\n\n### 取消事件回调cancelEvent\n\n``` cpp\n/**\n * @brief 取消事件\n * @param[in] fd socket句柄\n * @param[in] event 事件类型\n * @attention 如果该事件被注册过回调，那就触发一次回调事件\n * @return 是否删除成功\n */\nbool IOManager::cancelEvent(int fd, Event event) {\n  RWMutexType::ReadLock lock(m_mutex);\n  if (static_cast<int>(m_fdContexts.size()) <= fd) {\n    return false;\n  }\n  FdContext *fd_ctx = m_fdContexts[fd];\n  lock.unlock();\n\n  FdContext::MutexType::Lock lock2(fd_ctx->mutex);\n  if (!(fd_ctx->events & event)) {\n    return false;\n  }\n  // 删除事件 \n  Event new_events = (Event)(fd_ctx->events & ~event);\n  int op = new_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;\n  epoll_event epevent;\n  epevent.events = EPOLLET | new_events;\n  epevent.data.ptr = fd_ctx;\n\n  int rt = epoll_ctl(m_epfd, op, fd, &epevent);\n  if (rt) {\n    SYLAR_LOG_ERROR(g_logger)\n        << \"epoll_ctl(\" << m_epfd << \",\" << op << \", \" << fd << \",\"\n        << epevent.events << \"):\" << rt << \"(\" << errno << \") (\"\n        << strerror(errno) << \")\";\n    return false;\n  }\n\n  // 删除之前触发一次事件\n  fd_ctx->triggerEvent(event);\n  --m_pendingEventCount;\n  return true;\n}\n```\n\n### 取消全部事件cancelAll\n\n``` cpp\n/**\n * @brief 取消所有事件\n * @details 所有被注册的回调事件在cancel之前都会被执行一次\n * @param[in] fd socket句柄\n * @return 是否删除成功\n */\nbool IOManager::cancelAll(int fd) {\n  RWMutexType::ReadLock lock(m_mutex);\n  if (static_cast<int>(m_fdContexts.size()) <= fd) {\n    return false;\n  }\n  FdContext *fd_ctx = m_fdContexts[fd];\n  lock.unlock();\n\n  FdContext::MutexType::Lock lock2(fd_ctx->mutex);\n  if (!(fd_ctx->events)) {\n    return false;\n  }\n\n  // 删除全部事件\n  int op = EPOLL_CTL_DEL;\n  epoll_event epevent;\n  epevent.events = 0;\n  epevent.data.ptr = fd_ctx;\n\n  int rt = epoll_ctl(m_epfd, op, fd, &epevent);\n  if (rt) {\n    SYLAR_LOG_ERROR(g_logger)\n        << \"epoll_ctl(\" << m_epfd << \",\" << op << \", \" << fd << \",\"\n        << epevent.events << \"):\" << rt << \"(\" << errno << \") (\"\n        << strerror(errno) << \")\";\n    return false;\n  }\n\n  // 触发全部已注册的事件\n  if (fd_ctx->events & READ) {\n    fd_ctx->triggerEvent(READ);\n    --m_pendingEventCount;\n  }\n  if (fd_ctx->events & WRITE) {\n    fd_ctx->triggerEvent(WRITE);\n    --m_pendingEventCount;\n  }\n  SYLAR_ASSERT(fd_ctx->events == 0);\n  return true;\n}\n\nIOManager *IOManager::GetThis() {\n  return dynamic_cast<IOManager *>(Scheduler::GetThis());\n}\n```\n\n### 重载的onTimerInsertedAtFront\n\n``` cpp\nvoid IOManager::onTimerInsertedAtFront() { tickle(); }\n```\n\n1. sylar的IO协程调度模块可分为两部分，第一部分是对协程调度器的改造，将epoll与协程调度融合，重新实现tickle和idle，并保证原有的功能不变。第二部分是基于epoll实现IO事件的添加、删除、调度、取消等功能。\n2. IO协程调度关注的是FdContext信息，也就是描述符-事件-回调函数三元组，IOManager需要保存所有关注的三元组，并且在epoll_wait检测到描述符事件就绪时执行对应的回调函数。\n3. epoll是线程安全的，即使调度器有多个调度线程，它们也可以共用同一个epoll实例，而不用担心互斥。由于空闲时所有线程都阻塞的epoll_wait上，所以也不用担心CPU占用问题。\n4. addEvent是一次性的，比如说，注册了一个读事件，当fd可读时会触发该事件，但触发完之后，这次注册的事件就失效了，后面fd再次可读时，并不会继续执行该事件回调，如果要持续触发事件的回调，那每次事件处理完都要手动再addEvent。\n5. cancelEvent和cancelAll都会触发一次事件，但delEvent不会。\n6. FdContext的寻址问题，sylar直接使用fd的值作为FdContext数组的下标，这样可以快速找到一个fd对应的FdContext。由于关闭的fd会被重复利用，所以这里也不用担心FdContext数组膨胀太快，或是利用率低的问题。\n7. IO协程调度器的退出，不但所有协程要完成调度，所有IO事件也要完成调度。\n\n参考：\n<https://www.midlane.top/wiki/pages/viewpage.action?pageId=10061031>\n","tags":["sylar"],"categories":["sylar"]},{"title":"仿函数","url":"/2023/11/02/sylar/c++/仿函数/","content":"\n仿函数就是仿造的函数，它并不是一个真正意义上的函数。它是一个类中的运算符（）重载，但它具有函数的功能。\n\n1.仿函数不是函数是类\n\n2.仿函数重载了()运算符，拥有函数的行为\n\n示例1：\n\n``` cpp\n//回调函数\nvoid showFunc(int item) {\n    std::cout << \"调用回调函数：\" << item <<< std::endl;\n}\n\n//仿函数\nclass showFuncObj {\npublic:\n    showFuncObj() : m_count(0) {}\n\n    void operator()(int item) {\n        std::cout << \"调用仿函数：\" << item << std::endl;\n        m_count++;\n    }\n\n    void count() { return m_count; }\nprivate:\n    m_count;\n};\n\nint main() {\n    std::vector<int> vec {1,2,3,4,5,6,7};\n\n    for_each(vec.begin(), vec.end(), showFunc);\n\n    showFuncObj s;\n    s = for_each(vec.begin(), vec.end(), s); //仿函数是按值传参\n    // std::for_each(vec.begin(), vec.end(), showFuncObj()) 也可以这样用\n\n\n    s.count();\n\n    return 0;\n}\n\n```\n\n``` cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n//回调函数\nvoid showFunc(int item) { std::cout << \"调用回调函数：\" << item << std::endl; }\n\n//仿函数\n\ntemplate <typename T>\nclass showFuncObj {\n public:\n  void operator()(T& item) { std::cout << \"调用仿函数：\" << item << std::endl; }\n};\n\nint main() {\n  std::vector<int> vec{1, 2, 3, 4, 5, 6, 7};\n\n  for_each(vec.begin(), vec.end(), showFunc);\n\n  for_each(vec.begin(), vec.end(), showFuncObj<int>());\n\n  return 0;\n}\n\n```\n\n示例2：\n\n``` cpp\ntemplate <typename F, typename T>\nclass LexicalCast {\n public:\n  T operator()(const F &v) { return boost::lexical_cast<T>(v); }\n};\n\nint main() {\n  // 示例：将字符串转换为整数\n  LexicalCast<std::string, int> lexicalCast;\n  std::string str = \"123\";\n  int num = lexicalCast(str);\n  std::cout << num << std::endl;  // 输出: 123\n\n\n  // 还可以这样使用  ***************\n  // 示例：将字符串转换为整数\n  std::string str = \"123\";\n  auto num = LexicalCast<std::string, int>()(str);\n  std::cout << num << std::endl;  // 输出: 123\n}\n\n```\n\n示例3:\n\n``` cpp\ntemplate <typename F, typename T>\nclass LexicalCast {\n public:\n  T operator()(const F &v) { return boost::lexical_cast<T>(v); }\n};\n\ntemplate <class T>\nclass LexicalCast<std::string, std::vector<T>> {\n public:\n  std::vector<T> operator()(const std::string &v) {\n    YAML::Node node = YAML::Load(v);\n    typename std::vector<T> vec;\n    std::stringstream ss;\n    for (size_t i = 0; i < node.size(); ++i) {\n      // 清空ss\n      ss.str(\"\");\n      ss << node[i];\n      vec.push_back(LexicalCast<std::string, T>()(ss.str()));\n    }\n    return vec;\n  }\n};\n\n\nint main(){\n\n  // 示例：将字符串转换为整数向量\n  LexicalCast<std::string, std::vector<int>> lexicalCast2;\n  std::string str2 = \"[1, 2, 3, 4, 5]\";\n  std::vector<int> vec = lexicalCast2(str);\n  for (const auto &num : vec) {\n    std::cout << num << \" \";\n  }\n  // 输出: 1 2 3 4 5\n\n  // 示例：将字符串转换为整数向量 还可以这样使用\n  std::string str3 = \"[1, 2, 3, 4, 5]\";\n  std::vector<int> vec2 = LexicalCast<std::string, std::vector<int>>()(str3);\n  for (const auto &num : vec2) {\n    std::cout << num << \" \";\n  }\n  // 输出: 1 2 3 4 5\n\n}\n```\n\n`std::vector<int> vec2 = LexicalCast<std::string, std::vector<int>>()(str3);`\n\n这种用法利用了函数对象的临时对象创建和函数调用运算符的重载。通过在模板类名后添加 ()，我们创建了一个 `LexicalCast<std::string, std::vector<int>>` 的临时对象，并直接在创建时传递了字符串`str3` 作为参数。\n然后，通过调用该临时对象的函数调用运算符 operator()，进行类型转换并得到结果。\n\n所谓临时变量，就是一种无名对象。有的时候可以制造一些临时对象，可以使程序干净清爽。可以制造临时对象的方法是，在类别名称之后直接加一对小括号，并可指定初值，其意义相当于调用相应的constructor且不指定对象名称。\n\n## 函数对象的临时对象创建和函数调用运算符的重载\n\n当我们在C++中创建一个类时，我们可以重载函数调用运算符 operator()，这样我们可以像调用函数一样来调用这个类的对象。这样的类被称为函数对象（Function Object）或仿函数（Functor）。\n在例子中，`LexicalCast<std::string, std::vector<int>>` 就是一个函数对象类。当你使用 `LexicalCast<std::string, std::vector<int>>()` 这样的语法时，它实际上创建了一个该类的临时对象。\n\n接下来，我们可以使用函数调用运算符 operator() 来调用这个临时对象。函数调用运算符的重载使得我们可以像调用函数一样，使用圆括号将参数传递给函数对象，并得到相应的结果。\n在例子中，临时对象 `LexicalCast<std::string, std::vector<int>>()` 被调用时，它接受一个字符串` \"[1, 2, 3]\" `作为参数，并使用相应的转换逻辑将其转换为 `std::vector<int>` 类型的向量。最后，函数调用运算符返回转换后的结果。\n\n因此，使用 `LexicalCast<std::string, std::vector<int>>()()` 这样的语法，我们可以创建函数对象的临时对象，并直接调用函数调用运算符来进行转换操作。\n\n## sylar 示例\n\n``` cpp\n/**\n * @brief 类型转换模板类(F 源类型, T 目标类型)\n */\n// F from_type , T to_type\ntemplate <class F, class T>\nclass LexicalCast {\n public:\n  /**\n   * @brief 类型转换\n   * @param[in] v 源类型值\n   * @return 返回v转换后的目标类型\n   * @exception 当类型不可转换时抛出异常\n   */\n  T operator()(const F &v) { return boost::lexical_cast<T>(v); }\n};\n\n// 类型和类内成员的二义性，typename\n// string to vector\n/**\n * @brief 类型转换模板类片特化(YAML String 转换成 std::vector<T>)\n */\ntemplate <class T>\nclass LexicalCast<std::string, std::vector<T>> {\n public:\n  std::vector<T> operator()(const std::string &v) {\n    YAML::Node node = YAML::Load(v);\n    typename std::vector<T> vec;\n    std::stringstream ss;\n    for (size_t i = 0; i < node.size(); ++i) {\n      // 清空ss\n      ss.str(\"\");\n      ss << node[i];\n      vec.push_back(LexicalCast<std::string, T>()(ss.str()));\n    }\n    return vec;\n  }\n};\n\n```\n","tags":["sylar","c++"],"categories":["c++"]},{"title":"__builtin_expect 说明","url":"/2023/10/30/sylar/c++/builtin-expect-说明/","content":"\n\n从GCC的说明中可知，__builtin_expect的主要作用就是：帮助编译器判断条件跳转的预期值，避免因执行jmp跳转指令造成时间浪费。\n作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：__builtin_expect(EXP, N)。\n意思是：EXP==N的概率很大。\n\n## sylar\n\n``` cpp\n#if defined __GNUC__ || defined __llvm__\n/// LIKCLY 宏的封装, 告诉编译器优化,条件大概率成立\n#define SYLAR_LICKLY(x) __builtin_expect(!!(x), 1)\n/// LIKCLY 宏的封装, 告诉编译器优化,条件大概率不成立\n#define SYLAR_UNLICKLY(x) __builtin_expect(!!(x), 0)\n#else\n#define SYLAR_LICKLY(x) (x)\n#define SYLAR_UNLICKLY(x) (x)\n#endif\n```\n\n## likely() 与 unlikely()\n\n首先明确\n\n```cpp\nif(likely(value))  //等价于 if(value)\nif(unlikely(value))  //也等价于 if(value)\n```\n\n`__builtin_expect()` 是 `GCC(version >= 2.96)`提供给程序员使用的，目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。\n`__builtin_expect((x),1)`表示 `x` 的值为真的可能性更大；\n`__builtin_expect((x),0)`表示 `x` 的值为假的可能性更大。\n\n也就是说，使用`likely()`，执行 `if` 后面的语句的机会更大，使用`unlikely()`，执行 `else` 后面的语句的机会更大。通过这种方式，编译器在编译过程中，会将可能性更大的代码紧跟着起面的代码，从而减少指令跳转带来的性能上的下降。\n\n参考：<https://www.jianshu.com/p/2684613a300f>\n<http://velep.com/archives/795.html>\n","tags":["sylar"]},{"title":"定时器模块","url":"/2023/10/30/sylar/模块/定时器模块/","content":"\n## 定时器设计\n\nsylar的定时器采用最小堆设计，所有定时器根据绝对的超时时间点进行排序，每次取出离当前时间最近的一个超时时间点，计算出超时需要等待的时间，然后等待超时。超时时间到后，获取当前的绝对时间点，然后把最小堆里超时时间点小于这个时间点的定时器都收集起来，执行它们的回调函数。\n\n注意，在注册定时事件时，一般提供的是相对时间，比如相对当前时间3秒后执行。sylar会根据传入的相对时间和当前的绝对时间计算出定时器超时时的绝对时间点，然后根据这个绝对时间点对定时器进行最小堆排序。因为依赖的是系统绝对时间，所以需要考虑校时因素，这点会在后面讨论。\n\nTimer类的成员变量包括定时器的绝对超时时间点，是否重复执行，回调函数，以及一个指向TimerManager的指针，提供cancel/reset/refresh方法用于操作定时器。\n构造Timer时可以传入超时时间，也可以直接传入一个绝对时间。Timer的构造函数被定义成私有方式，只能通过TimerManager类来创建Timer对象。除此外，Timer类还提供了一个仿函数Comparator，用于比较两个Timer对象，比较的依据是绝对超时时间。\n\n**创建定时器时只传入了相对超时时间，内部要先进行转换，根据当前时间把相对时间转化成绝对时间。**\n\n### Timer\n\n``` cpp\n\n/**\n * @brief 定时器\n */\nclass Timer : public std::enable_shared_from_this<Timer> {\n  friend class TimerManager;\n\n public:\n  typedef std::shared_ptr<Timer> ptr;\n  /**\n   * @brief 取消定时器\n   *\n   * @return true\n   * @return false\n   */\n  bool cancel();\n\n  /**\n   * @brief 刷新设置定时器的执行时间\n   *\n   * @return true\n   * @return false\n   */\n  bool refresh();\n\n  /**\n   * @brief 重置定时器时间\n   *\n   * @param ms 定时器执行间隔时间(毫秒)\n   * @param from_now  是否从当前时间开始计算\n   * @return true\n   * @return false\n   */\n  bool reset(uint64_t ms, bool from_now);\n\n private:\n  Timer(uint64_t ms, std::function<void()> cb, bool resurring,\n        TimerManager *manager);\n  Timer(uint64_t next);\n\n private:\n  bool m_recurring = false;  // 是否循环定时器\n  uint64_t m_ms = 0;         // 执行周期\n  uint64_t m_next = 0;       // 精确的执行时间\n  std::function<void()> m_cb;\n  TimerManager *m_manager = nullptr;\n\n private:\n  struct Comparator {\n    bool operator()(const Timer::ptr &lhs, const Timer::ptr &rhs) const;\n  };\n};\n```\n\n### Timer构造函数\n\n可以看出sylar会根据传入的相对时间和当前的绝对时间计算出定时器超时时的绝对时间点。然后根据这个绝对时间点对定时器进行最小堆排序\n\n``` cpp\nTimer::Timer(uint64_t ms, std::function<void()> cb, bool resurring,\n             TimerManager *manager)\n    : m_recurring(resurring), m_ms(ms), m_cb(cb), m_manager(manager) {\n  m_next = sylar::GetCurrentMS() + m_ms;\n}\n```\n\n### cancel取消定时器\n\n就是从TimerManager的m_timers中找到对应的Timer::ptr，然后删除(erase)到\n\n```cpp\nbool Timer::cancel() {\n  TimerManager::RWMutexType::WriteLock lock(m_manager->m_mutex);\n  if (m_cb) {\n    m_cb = nullptr;\n    auto it = m_manager->m_timers.find(shared_from_this());\n    m_manager->m_timers.erase(it);\n    return true;\n  }\n  return false;\n}\n```\n\nrefresh刷新设置定时器的执行时间，就是将TimerManager(m_manager)中的m_timers找到对应的timer,刷新其定时器的执行时间。\n\n``` cpp\nbool Timer::refresh() {\n  TimerManager::RWMutexType::WriteLock lock(m_manager->m_mutex);\n  if (!m_cb) {\n    return false;\n  }\n\n  auto it = m_manager->m_timers.find(shared_from_this());\n  if (it == m_manager->m_timers.end()) {\n    return false;\n  }\n\n  //  先移除掉，重置时间，然后塞回去\n  // operator是基于时间来做的，如果直接改时间，会影响他的比较位置，整个数据结构都会有问题。\n  // set  不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素\n  m_manager->m_timers.erase(it);\n  m_next = sylar::GetCurrentMS() + m_ms;\n  m_manager->m_timers.insert(shared_from_this());\n  return true;\n}\n```\n\n### reset重置定时器时间\n\n重置的是将要执行的时间和执行周期(m_ms)\n\n三种情况\n\n1. `ms == m_ms` 并且 `from_now == false`,周期不变并且时间也不从当前开始计算，则不改变，直接返回。\n2. `ms != m_ms` 并且 `from_now == true`,那么起始时间设置为现在，并且改变 m_ms,设置m_next，添加到m_timers\n3. `ms != m_ms` 并且 `from_now == false`,起始时间设置为(m_next -m_ms),`m_ms = ms;`, `m_next = start + m_ms;`,添加到m_timers\n\n``` cpp\nbool Timer::reset(uint64_t ms, bool from_now) {\n  /// 不从现在开始计时\n  if (ms == m_ms && !from_now) {\n    return true;\n  }\n  TimerManager::RWMutexType::WriteLock lock(m_manager->m_mutex);\n  if (!m_cb) {\n    return false;\n  }\n\n  auto it = m_manager->m_timers.find(shared_from_this());\n  if (it == m_manager->m_timers.end()) {\n    return false;\n  }\n\n  m_manager->m_timers.erase(it);\n  uint64_t start = 0;\n  // 是否从当前时间开始计算\n  if (from_now) {\n    /// 改为现在开始\n    start = sylar::GetCurrentMS();\n  } else {\n    /// 获取起始时间\n    start = m_next - m_ms;\n  }\n  m_ms = ms;\n  m_next = start + m_ms;\n  m_manager->addTimer(shared_from_this(), lock);\n\n  return true;\n}\n```\n\n### TimerManager实现对所有Timer的管理\n\nTimerManager包含一个std::set类型的Timer集合(`std::set<Timer::ptr, Timer::Comparator> m_timers;`)，`m_timers`就是定时器的最小堆结构，因为set里的元素总是排序过的，所以总是可以很方便地获取到当前的最小定时器。\n\nTimerManager提供创建定时器，到最近一个定时器执行的时间间隔(毫秒)(`getNextTimer`)，以及获取全部已经超时的定时器回调函数的方法(`void TimerManager::listExpiredCb(std::vector<std::function<void()>> &cbs)`)，并且提供了一个onTimerInsertedAtFront()方法，这是一个虚函数，由IOManager继承时实现，当新的定时器插入到Timer集合的首部时，TimerManager通过该方法来通知IOManager立刻更新当前的epoll_wait超时。TimerManager还负责检测是否发生了校时，由detectClockRollover方法实现。\n\n### TimerManager\n\n``` cpp\nclass TimerManager {\n  friend class Timer;\n\n public:\n  typedef RWMutex RWMutexType;\n\n  TimerManager();\n  virtual ~TimerManager();\n\n  /**\n   * @brief 添加定时器\n   * @param[in] ms 定时器执行间隔时间\n   * @param[in] cb 定时器回调函数\n   * @param[in] recurring 是否循环定时器\n   */\n  Timer::ptr addTimer(uint64_t ms, std::function<void()> cb,\n                      bool recurring = false);\n  /**\n   * @brief 添加条件定时器\n   * @param[in] ms 定时器执行间隔时间\n   * @param[in] cb 定时器回调函数\n   * @param[in] weak_cond 条件\n   * @param[in] recurring 是否循环\n   */\n  Timer::ptr addConditionTimer(uint64_t ms, std::function<void()> cb,\n                               std::weak_ptr<void> weak_cond,\n                               bool recurring = false);\n  /**\n   * @brief 到最近一个定时器执行的时间间隔(毫秒)\n   *\n   * @return uint64_t\n   */\n  uint64_t getNextTimer();\n\n  /**\n   * @brief 获取需要执行的定时器的回调函数列表\n   *\n   * @param[out] cbs 回调函数数组\n   */\n  void listExpiredCb(std::vector<std::function<void()>> &cbs);\n  /**\n   * @brief 是否有定时器\n   */\n  bool hasTimer();\n\n protected:\n  /**\n   * @brief 当有新的定时器插入到定时器的首部,执行该函数,IoManager来实现\n   */\n  virtual void onTimerInsertedAtFront() = 0;\n  /**\n   * @brief 将定时器添加到管理器中\n   */\n  void addTimer(Timer::ptr val, RWMutexType::WriteLock &lock);\n\n private:\n  /**\n   * @brief 检测服务器时间是否被调后了\n   */\n  bool detextClockRollover(uint64_t now_ms);\n\n private:\n  RWMutexType m_mutex;\n  /// 这个参数不代表映射对象，而是传递一个比较结构体\n  /// 定时器集合\n  std::set<Timer::ptr, Timer::Comparator> m_timers;\n  /// 是否触发onTimerInsertedAtFront\n  bool m_tickled = false;\n  /// 上次执行时间\n  uint64_t m_previousTime = 0;\n};\n```\n\n### 到最近一个定时器执行的时间间隔(毫秒)\n\n``` cpp\nuint64_t TimerManager::getNextTimer() {\n  RWMutexType::ReadLock lock(m_mutex);\n  m_tickled = false;\n  if (m_timers.empty()) {\n    // Value = 18446744073709551615 (0xffffffffffffffff)\n    return ~0ull;\n  }\n\n  const Timer::ptr &next = *m_timers.begin();\n  uint64_t now_ms = sylar::GetCurrentMS();\n   /// 已经超时了，返回 0\n  if (now_ms >= next->m_next) {\n    return 0;\n  } else {\n     /// 还未超时，返回从现在开始到执行这个定时器，需要等待的时间。\n    return next->m_next - now_ms;\n  }\n}\n```\n\n``` cpp\n// 传进来的时间比他小，并且比他一个小时之前按还小，有问题\nbool TimerManager::detextClockRollover(uint64_t now_ms) {\n  bool rollover = false;\n  // 现在的时间比上次执行的时间还小，并且比上次执行的时间的一小时之前还小，有问题\n  if (now_ms < m_previousTime && now_ms < (m_previousTime - 60 * 60 * 1000)) {\n    rollover = true;\n  }\n  m_previousTime = now_ms;\n  return rollover;\n}\n```\n\n### 获取全部已经超时的定时器回调函数\n\n1. 获取当前的时间\n2. 检查是否时间调后了，会导致任务无法按时执行。\n    1. 没有重调时间，且超时任务还没到达，直接返回\n    2. 重调时间了，那么就说明出现问题了，这里的处理是，将之前的m_timers中的定时器全部执行。\n3. 没有重调时间，并且有任务，先找到第一个大于或等于now_timer的迭代器\n4. 处理找到的迭代器的执行时间等于now_timer的情况，这里的方案是，也将其加入超时的定时器中。\n5. 先将已经超时的定时器，加入预先分配的`vector<Timer::ptr>`中，然后将这些定时器在m_timers中删除。\n6. 将这些超时的定时器的cb放入`std::vector<std::function<void()>> &cbs`中：\n    1. 在放入时，需要检查m_recurring(是否循环执行此定时器)选项，如果为true，则需要重置其下一次的执行时间，并将其再次放入待执行的定时器集合中(m_timers)\n    2. 为false，则`timer->m_cb = nullptr;`,将其回调函数置为空。\n\n```cpp\nvoid TimerManager::listExpiredCb(std::vector<std::function<void()>> &cbs) {\n  uint64_t now_ms = sylar::GetCurrentMS();\n  std::vector<Timer::ptr> expired;\n  {\n    RWMutexType::ReadLock lock(m_mutex);\n    if (m_timers.empty()) {\n      return;\n    }\n  }\n  RWMutexType::WriteLock lock(m_mutex);\n\n  bool rollover = detextClockRollover(now_ms);\n  if (!rollover && ((*m_timers.begin())->m_next > now_ms)) {\n    return;\n  }\n  Timer::ptr now_timer(new Timer(now_ms));\n  // Timer::ptr now_timer = std::make_shared<Timer>(now_ms);\n  // todo\n  auto it = rollover ? m_timers.end() : m_timers.lower_bound(now_timer);\n\n  while (it != m_timers.end() && (*it)->m_next == now_ms) {\n    ++it;\n  }\n  expired.insert(expired.begin(), m_timers.begin(), it);\n  m_timers.erase(m_timers.begin(), it);\n  cbs.reserve(expired.size());\n\n  for (auto &timer : expired) {\n    cbs.push_back(timer->m_cb);\n    if (timer->m_recurring) {\n      timer->m_next = now_ms + timer->m_ms;\n      m_timers.insert(timer);\n\n    } else {\n      timer->m_cb = nullptr;\n    }\n  }\n}\n```\n\n### 添加timer\n\n最终执行的下面的函数\n\n当TimerManager检测到新添加的定时器的超时时间比当前最小的定时器还要小时，TimerManager通过这个方法来通知IOManager立刻更新当前的epoll_wait超时，\n否则新添加的定时器的执行时间将不准确。\n实际实现时，只需要在`onTimerInsertedAtFront()`方法内执行一次`tickle`就行了，`tickle`之后，`epoll_wait`会立即退出，并重新从`TimerManager`中获取最近的超时时间，这时拿到的超时时间就是新添加的最小定时器的超时时间了。\n\n``` cpp\nvoid TimerManager::addTimer(Timer::ptr timer, RWMutexType::WriteLock &lock) {\n  auto it = m_timers.insert(timer).first;\n  bool at_front = (it == m_timers.begin()) && !m_tickled;\n  if (at_front) {\n    m_tickled = true;\n  }\n  lock.unlock();\n    ///是否在最靠前\n  if (at_front) {\n    onTimerInsertedAtFront();\n  }\n}\n```\n\n### 关于校时问题\n\nsylar的定时器以gettimeofday()来获取绝对时间点并判断超时，所以依赖于系统时间，如果系统进行了校时，比如NTP时间同步，那这套定时机制就失效了。sylar的解决办法是设置一个较小的超时步长，比如3秒钟，也就是epoll_wait最多3秒超时，假设最近一个定时器的超时时间是10秒以后，那epoll_wait需要超时3次才会触发。每次超时之后除了要检查有没有要触发的定时器，还顺便检查一下系统时间有没有被往回调。如果系统时间往回调了1个小时以上，那就触发全部定时器。其实只需要换个时间源就可以解决校时问题，换成clock_gettime(CLOCK_MONOTONIC_RAW)的方式获取系统的单调时间，就可以解决这个问题了。\n\n参考：\n<https://www.midlane.top/wiki/pages/viewpage.action?pageId=16417216>\n","tags":["sylar"],"categories":["sylar"]},{"title":"error: pointer of type ‘void *’ used in arithmetic [-Werror=pointer-arith]","url":"/2023/10/30/error/error-pointer-of-type-‘void-’-used-in-arithmetic-Werror-pointer-arith/","content":"\n\n``` cpp\nvoid ByteArray::write(const void *buf, size_t size) {\n  if (size == 0) {\n    return;\n  }\n  addCapacity(size);\n  // 当前位置\n  size_t npos = m_position % m_baseSize;\n  // 当前容量\n  size_t ncap = m_cur->size - npos;\n  size_t bpos = 0;\n\n  while (size > 0) {\n    // 当前的容量可以容纳要写入的大小\n    if (ncap >= size) {\n      // todo bpos当前写入的偏移量\n      memcpy(m_cur->ptr + npos, buf + bpos, size);  // error\n      if (m_cur->size == (npos + size)) {\n        m_cur = m_cur->next;\n      }\n      ...\n    }\n...\n  }\n...\n\n}\n```\n\n``` cpp\n error: pointer of type ‘void *’ used in arithmetic [-Werror=pointer-arith]\n  327 |       memcpy(m_cur->ptr + npos, buf + bpos, size);\n```\n\n\n\n由于 void* 是指向未知类型的指针，因此您无法对其进行指针算术，因为编译器不知道指向的东西有多大。\n\n修改为\n`memcpy(m_cur->ptr + npos, (const char *)buf + bpos, size);`","tags":["error"]},{"title":"final和override的作用","url":"/2023/10/26/sylar/c++/final和override的作用/","content":"\n## override关键字\n\n覆写（override）虚函数\n\n1. 让编译器来检查我们又没有正确覆写父类的虚函数。因此，任何子类覆写虚函数后导致函数签名的变化，都会导致编译器报错。\n2. 建议做法： 最顶层的虚函数上加上virtual关键字后，其余的子类覆写后就不再加virtual了，但是要统一加上override。\n\n``` cpp\nstruct Base {\n  virtual void doSomething(int i) const {\n    std::cout << \"This is from Base with \" << i << std::endl;\n  }\n};\n\nstruct Derived : Base {\n  void doSomething(int i) override {\n    std::cout << \"This is from Derived with \" << i << std::endl;\n  }\n};\n\nvoid letDoSomething(Base& base) { base.doSomething(419); }\nint main() {\n  Derived d;\n  letDoSomething(d);  //输出结果： \"This is from Base with 419\"\n  return 0;\n}\n```\n\n上面代码子类doSomething缺少const,会导致编译器报错。\n\n## final\n\n1. final 关键字来限制某个类不能被继承\n使用 final 关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。\n\n    > 在使用final 来限制某个类不能别继承时，这个类中的虚方法也就不用写final了。因为这个类不能被继承，覆盖其方法更是不可能了。有点画蛇添足了。\n\n    ``` cpp\n    class Base\n    {\n    public:\n        virtual void test()\n        {\n            cout << \"Base class...\";\n        }\n    };\n\n    class Child final: public Base\n    {\n    public:\n        void test()\n        {\n            cout << \"Child class...\";\n        }\n    };\n\n    // error, 语法错误\n    class GrandChild : public Child\n    {\n    public:\n    };\n    ```\n\n2. 防止子类再覆写父类的虚函数(只能修饰虚函数)了---->即父类的某些特性或方法被设计成不想再被改变。\n    只写一个final并不会像override那样检查覆写类型，所以最好还是两个都写上`final override`。\n    DateTimeFormatItem::format 不能被覆写了。但是写一个新的子类继承LogFormatter::FormatItem再覆写format还是允许的。\n\n    > `override final`和`final override`并没有什么区别\n\n``` cpp\nclass DateTimeFormatItem : public LogFormatter::FormatItem {\n public:\n  DateTimeFormatItem(const std::string &format = \"%Y-%m-%d %H:%M:%S\") : m_format(format) {\n    if (m_format.empty()) {\n      m_format = \"%Y-%m-%d %H:%M:%S\";\n    }\n  }\n\n  void format(std::ostream &os, Logger::ptr logger, LogLevel::Level level,\n              LogEvent::ptr event) final override {\n    struct tm tm;\n    time_t time = event->getTime();\n    localtime_r(&time, &tm);\n    char buf[64];\n    std::strftime(buf, sizeof(buf), m_format.c_str(), &tm);\n    os << buf;\n  }\n\n private:\n  std::string m_format;\n};\n```\n\n> 1. 当你看到一个函数标记了virtual时，弄清楚它是不是顶层虚函数，这个时候我建议你多用用你的编译器，当你使用override报错时，也有可能它确实就是顶层virtual函数了。\n>\n> 2. 使用final需要更多的权衡,override就无所谓了，随便用。\n\n## 去虚拟化(Devirtualization)\n\n虚函数需要通过虚函数表(vtable)进行间接调用，相对于直接调用来说，间接调用更加昂贵，因为它会受到分支预测和指令缓存的影响，同时，间接调用还阻止了编译期对代码的更进一步的优化，例如，例如，通过将代码内联来提升运行时性能。\n去虚拟化是一项编译期优化措施，它可以在编译期解析出虚函数调用，而不是在运行时进行决断。这项优化解决了上面谈到的问题，因此它可以显著的提升代码的性能。\n\n## final指示符带来的性能提升\n\n通过在代码中使用final指示符，编译器可以获得更多的机会执行去虚拟化。因为如果代码中使用到了final，就表示类的虚函数可以在编译期进行解析，从而使得编译器可以进行去虚拟化。\n\n> todo 给sylar添加上 final","tags":["sylar","c++"],"categories":["c++"]},{"title":"可变参数模板消除重复代码","url":"/2023/10/26/sylar/c++/可变参数模板消除重复代码/","content":"\n\n可变参数模板和普通模板函数的语义是一样的，只是语法上稍有区别，声明可变参数模板时需要在typename或class后面带上省略号\"...\"。\n省略号作用有两个：\n\n* 声明一个参数包，这个参数包中可以包含0到任意个模板函数。\n* 在模板定义的右边，可以将参数包展开成一个一个独立的参数。\n\n``` cpp\ntemplate <class... T>\nvoid f(T... args) {\n  std::cout << sizeof...(args) << std::endl;  // 打印变参的个数\n}\n\nstd::vector<int> vec{1, 2, 3};\n\n  f(1, 2, 3);       // 3\n  f(1, 2.9, \"asd\"); // 3\n  f(vec);           // 1\n```\n\n## 可变参数模板和std::forword\n\n首先先看下下面的示例：\n\n``` cpp\n#include <iostream>\n#include <utility>\n\nvoid Print(int x, int y, int z) {\n  std::cout << \"x = \" << x << \"\\n\"\n            << \"y = \" << y << \"\\n\"\n            << \"z = \" << z << \"\\n\";\n}\n\nvoid PrintScore(std::string s, int score) {\n  std::cout << \"name = \" << s << \"\\n\"\n            << \"score = \" << score << \"\\n\";\n}\ntemplate <class T, class OriFun, class... Args>\nvoid Fun(T t, OriFun fun, Args... args) {\n  std::cout << \"运行fun前的处理\"\n            << \"t:\" << t << \"\\n\";\n  fun(std::forward<Args>(args)...);\n}\n\nint main() {\n  Fun(6, Print, 3, 6, 9);\n  Fun(5, PrintScore, \"asd\", 33);\n  return 0;\n}\n\n输出结果：\n➜   g++ forward.cc -o forward\n➜   ./forward\n运行fun前的处理t:6\nx = 3\ny = 6\nz = 9\n运行fun前的处理t:5\nname = asd\nscore = 33\n```\n\n**可以消除大量的重复代码以及去掉参数个数的限定。**\n\n最后附上sylar里Hook的代码示例：\n\n``` cpp\n// 通用模板函数\ntemplate <typename OriginFun, typename... Args>\nstatic ssize_t do_io(int fd, OriginFun fun, const char *hook_fun_name, uint32_t event,\n                     int timeout_so, Args &&...args) {\n  if (!sylar::t_hook_enable) {\n    //  read(int fd, void *buf, size_t count)\n    //  return do_io(fd, read_f, \"read\", sylar::IOManager::READ, SO_RCVTIMEO, buf, count);\n    return fun(fd, std::forward<Args>(args)...);\n  }\n\n  SYLAR_LOG_DEBUG(g_logger) << \"do_io <\" << hook_fun_name << \">\";\n  // 得到fd 对应的 FdCtx\n  sylar::FdCtx::ptr ctx = sylar::FdMgr::GetInstance()->get(fd);\n  if (!ctx) {\n    return fun(fd, std::forward<Args>(args)...);\n  }\n  if (ctx->isClosed()) {\n    // Bad file descriptor\n    errno = EBADF;\n    return -1;\n  }\n\n  // 判断传入的fd是否为套接字，如果不为套接字，则调用系统的connect函数并返回。\n  // 判断fd是否被显式设置为了非阻塞模式，如果是则调用系统的connect函数并返回。\n  if (!ctx->isSocket() || ctx->getUserNonblock()) {\n    return fun(fd, std::forward<Args>(args)...);\n  }\n\n  uint64_t to = ctx->getTimeout(timeout_so);\n  // todo  make_shared\n  std::shared_ptr<timer_info> tinfo = std::make_shared<timer_info>();\n\nretry:\n  ssize_t n = fun(fd, std::forward<Args>(args)...);\n  // EINTR ---Interrupted system call\n  while (n == -1 && errno == EINTR) {\n    n = fun(fd, std::forward<Args>(args)...);\n  }\n  if (n == -1 && errno == EAGAIN) {\n    SYLAR_LOG_DEBUG(g_logger) << \"do_io\" << hook_fun_name << \">\";\n    sylar::IOManager *iom = sylar::IOManager::GetThis();\n    sylar::Timer::ptr timer;\n    std::weak_ptr<timer_info> winfo(tinfo);\n\n    // (uint64_t)-1 = 18446744073709551615 (0xffffffffffffffff)\n    if (to != (uint64_t)-1) {\n      timer = iom->addConditionTimer(\n          to,\n          [winfo, fd, iom, event]() {\n            auto t = winfo.lock();\n            if (!t || t->cancelled) {\n              return;\n            }\n            t->cancelled = ETIMEDOUT;\n            iom->cancelEvent(fd, (sylar::IOManager::Event)(event));\n          },\n          winfo);\n    }\n    // int c = 0;\n    // uint64_t now = 0;\n\n    int rt = iom->addEvent(fd, (sylar::IOManager::Event)(event));\n    if (rt) {\n      SYLAR_LOG_ERROR(g_logger) << hook_fun_name << \" addEvent(\" << fd << \", \" << event << \")\";\n\n      if (timer) {\n        timer->cancel();\n      }\n      return -1;\n    } else {\n      SYLAR_LOG_ERROR(g_logger) << \"do_io<\" << hook_fun_name << \">\";\n      sylar::Fiber::YieldToHold();\n      SYLAR_LOG_ERROR(g_logger) << \"do_io<\" << hook_fun_name << \">\";\n      if (timer) {\n        timer->cancel();\n      }\n      if (tinfo->cancelled) {\n        errno = tinfo->cancelled;\n        return -1;\n      }\n\n      goto retry;  // todo\n    }\n  }\n\n  return n;\n}\n\n...\n\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {\n  int fd = do_io(sockfd, accept_f, \"accept\", sylar::IOManager::READ, SO_RCVTIMEO, addr, addrlen);\n  if (fd >= 0) {\n    sylar::FdMgr::GetInstance()->get(fd, true);\n  }\n  return fd;\n}\n\n// read\nssize_t read(int fd, void *buf, size_t count) {\n  return do_io(fd, read_f, \"read\", sylar::IOManager::READ, SO_RCVTIMEO, buf, count);\n}\n\nssize_t readv(int fd, const struct iovec *iov, int iovcnt) {\n  return do_io(fd, readv_f, \"readv\", sylar::IOManager::READ, SO_RCVTIMEO, iov, iovcnt);\n}\n\nssize_t recv(int sockfd, void *buf, size_t len, int flags) {\n  return do_io(sockfd, recv_f, \"recv\", sylar::IOManager::READ, SO_RCVTIMEO, buf, len, flags);\n}\n\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr,\n                 socklen_t *addrlen) {\n  return do_io(sockfd, recvfrom_f, \"recvfrom\", sylar::IOManager::READ, SO_RCVTIMEO, buf, len, flags,\n               src_addr, addrlen);\n}\n\nssize_t recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  return do_io(sockfd, recvmsg_f, \"recvmsg\", sylar::IOManager::READ, SO_RCVTIMEO, msg, flags);\n}\n\n// write\nssize_t write(int fd, const void *buf, size_t count) {\n  return do_io(fd, write_f, \"write\", sylar::IOManager::WRITE, SO_SNDTIMEO, buf, count);\n}\n\nssize_t writev(int fd, const struct iovec *iov, int iovcnt) {\n  return do_io(fd, writev_f, \"writev\", sylar::IOManager::WRITE, SO_SNDTIMEO, iov, iovcnt);\n}\n\nssize_t send(int sockfd, const void *buf, size_t len, int flags) {\n  return do_io(sockfd, send_f, \"send\", sylar::IOManager::WRITE, SO_SNDTIMEO, buf, len, flags);\n}\n\nssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr,\n               socklen_t addrlen) {\n  return do_io(sockfd, sendto_f, \"sendto\", sylar::IOManager::WRITE, SO_SNDTIMEO, buf, len, flags,\n               dest_addr, addrlen);\n}\n\nssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags) {\n  return do_io(sockfd, sendmsg_f, \"sendmsg\", sylar::IOManager::WRITE, SO_SNDTIMEO, msg, flags);\n}\n```\n","tags":["sylar","c++"],"categories":["c++"]},{"title":"error: invalid new-expression of abstract class type ‘sylar::IPAddress’","url":"/2023/10/25/error/error-invalid-new-expression-of-abstract-class-type-‘sylar-IPAddress’/","content":"\nerror:\n\n``` cpp\nerror: invalid new-expression of abstract class type ‘sylar::IPAddress’\n  162 |         { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n      |           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\n``` cpp\nbool Address::GetInterfaceAddresses(std::vector<std::pair<Address::ptr, uint32_t>> &result,\n                                    const std::string &iface, int family) {\n  if (iface.empty() || iface == \"*\") {\n    if (family == AF_INET || family == AF_UNSPEC) {\n      // result.push_back(std::make_pair(Address::ptr(new IPv4Address()), 0u));\n      result.push_back(\n          std::make_pair(std::dynamic_pointer_cast<Address>(std::make_shared<IPAddress>()), 0u));\n    }\n    if (family == AF_INET6 || family == AF_UNSPEC) {\n      result.push_back(std::make_pair(Address::ptr(new IPv6Address()), 0u));\n    }\n    return true;\n  }\n  ...\n}\n```\n\n\n1. 这个报错代表一个尝试在实例化一个抽象类，也就是说父类的接口中有纯虚函数在子类中没有实现；\n2. 实例化了父类，而父类中包含了纯虚函数，virtual　＝０是不能实例化的，相当于抽象类只能继承，不能实例化． --->这里IPAddress,Address都是抽象类，IPAddress是address的子类。\n\n解决方法：　实例化子类　 --->IPv4Address\n\n**应该修改为：**\n\n``` cpp\nbool Address::GetInterfaceAddresses(std::vector<std::pair<Address::ptr, uint32_t>> &result,\n                                    const std::string &iface, int family) {\n  if (iface.empty() || iface == \"*\") {\n    if (family == AF_INET || family == AF_UNSPEC) {\n      // result.push_back(std::make_pair(Address::ptr(new IPv4Address()), 0u));\n      result.push_back(\n          std::make_pair(std::dynamic_pointer_cast<Address>(std::make_shared<IPv4Address>()), 0u));\n    }\n    if (family == AF_INET6 || family == AF_UNSPEC) {\n      result.push_back(std::make_pair(Address::ptr(new IPv6Address()), 0u));\n    }\n    return true;\n  }\n  ...\n}\n```\n","tags":["error","sylar"]},{"title":"位域操作","url":"/2023/10/23/sylar/c++/位域操作/","content":"\n位域（bit-field）是一种在结构体或类中使用的特殊成员变量类型，它允许你将多个成员变量压缩到特定数量的位中，以节省内存空间。位域的主要目的是在存储空间有限的情况下，有效地利用位。\n\n在实际编程中，有时候我们的变量只有0和1两种值，或者值的范围远小于所定义的变量类型，这时采用位字段的方式就可以节省程序运行时的空间大小。除了内存以外，位字段还可以充分利用所有位。\n\n``` cpp\n private:\n  /// 是否初始化\n  bool m_isInit : 1;\n  bool m_isSocket : 1;\n  bool m_sysNonblock : 1;\n  bool m_userNonblock : 1;\n  bool m_isClosed : 1;\n```\n\n``` cpp\n// bit_fields1.cpp\n// compile with: /LD\nstruct Date {\n   unsigned short nWeekDay  : 3;    // 0..7   (3 bits)\n   unsigned short nMonthDay : 6;    // 0..31  (6 bits)\n   unsigned short nMonth    : 5;    // 0..12  (5 bits)\n   unsigned short nYear     : 8;    // 0..100 (8 bits)\n};\n```\n\nDate类型的对象的概念上的内存布局如下图所示：\n\n![Alt text](../../images/位域_1.png)\n`nYear`的长度为 8 位，这会溢出声明类型`unsigned short(16 bit)`的字边界。 因此，它始于新`unsigned short`的开头。 并不必使所有位域均适合基础类型的对象；根据声明中请求的位数来分配新的存储单元。\n\n如果结构的声明包含长度为 0 的未命名字段（如以下示例所示）：\n\n``` cpp\n// bit_fields2.cpp\n// compile with: /LD\nstruct Date {\n   unsigned nWeekDay  : 3;    // 0..7   (3 bits)\n   unsigned nMonthDay : 6;    // 0..31  (6 bits)\n   unsigned           : 0;    // Force alignment to next boundary.\n   unsigned nMonth    : 5;    // 0..12  (5 bits)\n   unsigned nYear     : 8;    // 0..100 (8 bits)\n};\n```\n\n则内存布局如下图中所示：\n\n* 宽度为 0 的未命名位域强制将下一个位域与下一个类型边界对齐，其中类型是成员的类型。\n![Alt text](../../images/位域_2.png)\n位域的基础类型必须是整数类型，如[内置类型](https://learn.microsoft.com/zh-cn/cpp/cpp/fundamental-types-cpp?view=msvc-170)中所述。\n\n如果对类型const T&的引用的初始值设定项是引用类型为T的位域的 lvalue，引用不会直接绑定到位域。 相反，引用会绑定到一个临时初始值设定项以保留位域的值。\n\n## 位域的限制\n\n以下列表详述了位域的错误操作：\n\n1. 采用位域的地址。\n\n2. 使用位域初始化非 const 引用。\n","tags":["sylar","c++"],"categories":["c++"]},{"title":"尽量使用make_shared初始化","url":"/2023/10/23/sylar/c++/尽量使用make-shared初始化/","content":"\n\n**为什么尽可能使用 make_shared，这几乎总是如此？**\n主要原因有两个：简单和高效。\n\n1. 使用 make_shared 代码更简单。首先要确保清晰和正确。\n\n2. 使用 make_shared 效率更高。\n\nShared_ptr 实现必须在由引用给定对象的所有shared_ptr 和weak_ptr 共享的控制块中维护内务信息。特别是，内务信息必须不仅包括一个引用计数，还必须包括两个引用计数：\n\n* 强引用, 用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放).\n\n* 用于跟踪当前观察对象的weak_ptr数量的“弱引用”计数。当最后一个弱引用消失时，共享内务管理控制块将被销毁并释放（如果尚未释放共享对象，则将其释放）。\n\n## 原始new 和 make_shared的区别\n\n* 如果你通过使用原始的 new 表达式分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块:如示例2(a) 和图2(a) 所示。\n\n``` cpp\n// Example 2(a): Separate allocation\nauto sp1 = shared_ptr<widget>{ new widget{} };\nauto sp2 = sp1;\n```\n\n![Alt text](../../images/new_shared.png)\n\n* 我们希望避免在这里进行两次单独的分配。如果您使用 make_shared 一次性分配对象和共享指针，那么实现可以将它们折叠在一次分配中，如示例 2(b) 和图 2(b) 所示。\n\n``` cpp\n// Example 2(b): Single allocation\nauto sp1 = make_shared<widget>();\nauto sp2 = sp1;\n```\n\n![Alt text](../../images/make_shared.png)\n\n**组合分配有两个主要优点：**\n\n* 它减少了分配开销，包括内存碎片。首先，最明显的方法是减少分配请求的数量，这通常是更昂贵的操作。这也有助于减少分配器的争用（某些分配器不能很好地扩展）。其次，仅使用一块内存而不是两块可以减少每次分配的开销。每当您请求一块内存时，系统必须至少为您提供那么多字节，并且由于使用固定大小的池或在每次分配时添加内务信息，通常会为您提供更多字节。因此，通过使用单个内存块，我们倾向于减少总的额外开销。最后，我们还自然地减少了导致碎片的“死”额外间隙的数量。\n\n* 它改善了局部性。引用计数经常与对象一起使用，并且对于小对象可能位于同一缓存行，这提高了缓存性能（只要没有某个线程在紧密循环中复制智能指针；不要去做）。\n\n## 避免异常安全问题\n\n使用 make_shared 可以避免显式 new 并避免异常安全问题。\n\n如果我们在调用processWidget的时候使用computePriority()，并且用new而不是std::make_shared：\n\n``` cpp\nprocessWidget(std::shared_ptr<Widget>(new Widget),  //潜在的资源泄露 \n              computePriority());\n```\n\n就像注释指示的那样，上面的代码会导致new创造出来的Widget发生泄露。那么到底是怎么泄露的呢？调用代码和被调用函数都用到了std::shared_ptr，并且std::shared_ptr就是被设计来阻止资源泄露的。当最后一个指向这儿的std::shared_ptr消失时，它们会自动销毁它们指向的资源。如果每个人在每个地方都使用std::shared_ptr，那么这段代码是怎么导致资源泄露的呢？\n\n答案和编译器的翻译有关，编译器把源代码翻译到目标代码，在运行期，函数的参数必须在函数被调用前被估值，所以在调用processWidget时，下面的事情肯定发生在processWidget能开始执行之前：\n\n1. 表达式“new Widget”必须被估值，也就是，一个Widget必须被创建在堆上。\n2. std::shared_ptr（负责管理由new创建的指针）的构造函数必须被执行。\n3. computePriority必须跑完。\n\n编译器不需要必须产生这样顺序的代码。但“new Widget”必须在std::shared_ptr的构造函数被调用前执行，因为new的结构被用为构造函数的参数，但是computePriority可能在这两个调用前（后，或很奇怪地，中间）被执行。也就是，编译器可能产生出这样顺序的代码：\n\n``` cpp\n执行“new Widget”。\n执行computePriority。\n执行std::shared_ptr的构造函数。\n```\n\n如果这样的代码被产生出来，并且在运行期，computePriority产生了一个异常，则在第一步动态分配的Widget就会泄露了，因为它永远不会被存放到在第三步才开始管理它的std::shared_ptr中。\n\n使用std::make_shared可以避免这样的问题。调用代码将看起来像这样：\n\n``` cpp\nprocessWidget(std::make_shared<Widget>(),       //没有资源泄露\n              computePriority());           \n```\n\n在运行期，不管std::make_shared或computePriority哪一个先被调用。如果std::make_shared先被调用，则在computePriority调用前，指向动态分配出来的Widget的原始指针能安全地被存放到被返回的std::shared_ptr中。如果computePriority之后产生一个异常，std::shared_ptr的析构函数将发现它持有的Widget需要被销毁。并且如果computePriority先被调用并产生一个异常，std::make_shared就不会被调用，因此这里就不需要考虑动态分配的Widget了。\n\n如果使用std::unique_ptr和std::make_unique来替换std::shared_ptr和std::make_shared，事实上，会用到同样的理由。因此，使用std::make_unique代替new就和“使用std::make_shared来写出异常安全的代码”一样重要。\n\n有以下情况，您不能使用 make_shared（或 allocate_shared）来创建您知道将由共享指针拥有的对象\n\n1. 如果您需要自定义删除器，例如因为使用共享指针来管理非共享对象内存资源或分配在非标准内存区域的对象，不能使用make_shared，因为它不支持指定删除器；\n2. 如果您采用指向从其他（通常是遗留）代码传递给您的对象的原始指针，您将直接从该原始指针构造一个shared_ptr。\n3. 构造函数是保护或私有时,无法使用 make_shared,[解决方法](<https://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const>)\n\n> todo sylar 将 `new` 修改为 `std::make_shared`\n\n参考：\n<https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/>\n\n<https://www.jianshu.com/p/03eea8262c11>\n","tags":["sylar","c++"],"categories":["c++"]},{"title":"error: template with C linkage","url":"/2023/10/22/error/error-template-with-C-linkage/","content":"\n在sylar项目中涉及到了编译C/C++混用\n\n1. 某个头文件中extern “C”的使用存在问题，如果包含这个有问题的头文件之后，又包含<map>,<vector>等就会出现这个问题。\n2. 不要在extern \"C\"的中引用C++ STL库的头文件，如<map>, <vector>等具有template的头文件。标准库文件，尽量不要放到extern \"C\" 中。\n\n\n出现错误的代码\n``` cpp\n// #include\"endian.h\"\n#ifndef SYLAR_ENDIAN_H_\n#define SYLAR_ENDIAN_H_\n// todo\n\n#define SYLAR_LITTLE_ENDIAN 1  // 小端\n#define SYLAR_BIG_ENDIAN 2     //大端\n\n#include <byteswap.h>\n#include <cstdint>\n#include <type_traits>\nnamespace sylar {\ntemplate <class T>\ntypename std::enable_if<sizeof(T) == sizeof(uint64_t), T>::type byteswap(T value) {\n  return (T)bswap_64((uint64_t)value);\n}\n\ntemplate <class T>\ntypename std::enable_if<sizeof(T) == sizeof(uint32_t), T>::type byteswap(T value) {\n  return (T)bswap_32((uint32_t)value);\n}\n\ntemplate <class T>\ntypename std::enable_if<sizeof(T) == sizeof(uint16_t), T>::type byteswap(T value) {\n  return (T)bswap_16((uint16_t)value);\n}\n\n#if BYTE_ORDER == BIG_ENDIAN\n#define SYLAR_BYTE_ORDER SYLAR_BIG_ENDIAN\n#else\n#define SYLAR_BYTE_ORDER SYLAR_LITTLE_ENDIAN\n#endif\n\n#if SYLAR_BYTE_ORDER == SYLAR_BIG_ENDIAN\ntemplate <class T>\nT byteswapOnLittleEndian(T t) {\n  return t;\n}\n\ntemplate <class T>\nT byteswapOnBigEndian(T t) {\n  // todo\n  return byteswap(t);\n}\n\n#else\n\ntemplate <class T>\nT byteswapOnLittleEndian(T t) {\n  return byteswap(t);\n}\n\ntemplate <class T>\nT byteswapOnBigEndian(T t) {\n  return t;\n}\n\n#endif\n}  // namespace sylar\n\n#endif  // SYLAR_ENDIAN_H_\n\n```\n\n**error:**\n\n``` cpp\n/usr/include/c++/11/type_traits:2958:3: error: template with C linkage\n 2958 |   template<typename _Fn, typename _Tp>\n      |   ^~~~~~~~\nIn file included from /usr/include/features.h:486,\n                 from /usr/include/x86_64-linux-gnu/sys/types.h:25,\n                 from /home/lyt/my_sylar/sylar/fiber.h:4,\n                 from /home/lyt/my_sylar/sylar/fiber.cc:1:\n/usr/include/x86_64-linux-gnu/sys/types.h:27:1: note: ‘extern \"C\"’ linkage started here\n   27 | __BEGIN_DECLS\n      | ^~~~~~~~~~~~~\n```\n\n**解决方案**\n   \n1. 在原文件添加`extern \"C++\"`\n\n``` cpp\n#ifndef SYLAR_ENDIAN_H_\n#define SYLAR_ENDIAN_H_\n// todo\n\nextern \"C++\" {  // add\n\n#define SYLAR_LITTLE_ENDIAN 1  // 小端\n#define SYLAR_BIG_ENDIAN 2     //大端\n\n#include <byteswap.h>\n#include <cstdint>\n#include <type_traits>\nnamespace sylar {\ntemplate <class T>\ntypename std::enable_if<sizeof(T) == sizeof(uint64_t), T>::type byteswap(T value) {\n  return (T)bswap_64((uint64_t)value);\n}\n\ntemplate <class T>\ntypename std::enable_if<sizeof(T) == sizeof(uint32_t), T>::type byteswap(T value) {\n  return (T)bswap_32((uint32_t)value);\n}\n\ntemplate <class T>\ntypename std::enable_if<sizeof(T) == sizeof(uint16_t), T>::type byteswap(T value) {\n  return (T)bswap_16((uint16_t)value);\n}\n\n#if BYTE_ORDER == BIG_ENDIAN\n#define SYLAR_BYTE_ORDER SYLAR_BIG_ENDIAN\n#else\n#define SYLAR_BYTE_ORDER SYLAR_LITTLE_ENDIAN\n#endif\n\n#if SYLAR_BYTE_ORDER == SYLAR_BIG_ENDIAN\ntemplate <class T>\nT byteswapOnLittleEndian(T t) {\n  return t;\n}\n\ntemplate <class T>\nT byteswapOnBigEndian(T t) {\n  // todo\n  return byteswap(t);\n}\n\n#else\n\ntemplate <class T>\nT byteswapOnLittleEndian(T t) {\n  return byteswap(t);\n}\n\ntemplate <class T>\nT byteswapOnBigEndian(T t) {\n  return t;\n}\n\n#endif\n}  // namespace sylar\n\n} // add 解决error\n#endif  // SYLAR_ENDIAN_H_\n\n```\n**第二种方法**\n2. 将 `endian.h` 改为`endian.hpp` 错误解决。why??","tags":["error","sylar"],"categories":["sylar"]},{"title":"关于 C++ 中的 extern \"C\"","url":"/2023/10/20/sylar/c++/关于-C-中的-extern-C/","content":"\n C++为了支持函数重载，函数在被C++编译后在符号库中的名字与C语言的不同。假如某个函数的原型为void foo(int x, int y);该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生_foo_int_int之类的名字。_foo_int_int这样的名字是包含了函数名以及形参，C++就是靠这种机制来实现函数重载的。\n  \n被extern “C”修饰的函数或者变量是按照C语言方式编译和链接的，所以可以用一句话来概括extern “C”的真实目的：实现C++与C的混合编程。\n\n## extern\n\nextern是C/C++语言中表明函数和全局变量的作用范围的关键字，该关键字告诉编译器，其申明的函数和变量可以在本模块或其他模块中使用。\n\n**语句：extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，也并未为a分配空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出错。**\n\n通常来说，**在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字extern生命。** 例如，如果模块B要引用模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但并不会报错；它会在链接阶段从模块A编译生成的目标代码中找到该函数。\n\n**被extern \"C\"修饰的变量和函数是按照C语言方式进行编译和链接的：这点很重要！！！！**\n\nextern \"C\"示例：\n\n```cpp\n/* c语言头文件：cExample.h */\n#ifndef C_EXAMPLE_H\n#define C_EXAMPLE_H\nint add(int x, int y);\n#endif\n```\n\n``` cpp\n/* c语言实现文件：cExample.c */\n#include \"cExample.h\"\nint add( int x, int y )\n{\n    return x + y;\n}\n```\n\n``` cpp\n\n// c++实现文件，调用add：main.cpp\n#include <iostream>\nextern \"C\" {\n#include \"cExample.h\"\n}\n// #include \"cExample.h\"\nint main(int argc, char* argv[]) {\n  std::cout << add(2, 3) << std::endl;\n  return 0;\n}\n```\n\n``` cpp\ngcc -c cExample.c              \ng++  cExample.o main.cc -o main\n执行结果：5\n```\n\n``` cpp\n// c++实现文件，调用add：main.cpp\n#include <iostream>\n// extern \"C\" {\n// #include \"cExample.h\"\n// }\n#include \"cExample.h\"\nint main(int argc, char* argv[]) {\n  std::cout << add(2, 3) << std::endl;\n  return 0;\n}\n```\n\n去掉 extern \"C\",则会报错。\n\n``` cpp\nerror:g++  cExample.o main.cc -o main\n/usr/bin/ld: /tmp/cc1T0Ttv.o: in function `main':\nmain.cc:(.text+0x1e): undefined reference to `add(int, int)'\ncollect2: error: ld returned 1 exit status\n```\n\n**extern \"C\"的使用要点总结**\n\n* **使用extern \"C\"的时候，要在声明和定义处同时使用。**\n\n* 可以是如下的单一语句\n\n``` cpp\nextern \"C\" double sqrt(double);\n```\n\n* 可以是复合语句, 相当于复合语句中的声明都加了extern \"C\"\n\n```cpp\nextern \"C\"\n{\n      double sqrt(double);\n      int min(int, int);\n}\n```\n\n* 可以包含头文件，相当于头文件中的声明都加了extern \"C\".\n\n```cpp\nextern \"C\"\n{\n    ＃include <cmath>\n}\n```\n\n**sylar**\n\n```cpp\n// hook.h\nextern \"C\" {\n\n// sleep\ntypedef unsigned int (*sleep_fun)(unsigned int seconds);\nextern sleep_fun sleep_f;\n\ntypedef int (*usleep_fun)(useconds_t usec);\nextern usleep_fun usleep_f;\n...\n}\n```\n\n```cpp\n// hook.cc\nextern \"C\" {\n#define XX(name) name##_fun name##_f = nullptr;\nHOOK_FUN(XX);\n#undef XX\n\nunsigned int sleep(unsigned int seconds) {\n  if (!sylar::t_hook_enable) {\n    return sleep_f(seconds);\n  }\n\n  sylar::Fiber::ptr fiber = sylar::Fiber::GetThis();\n  sylar::IOManager *iom = sylar::IOManager::GetThis();\n  //   iom->addEvent(seconds * 1000,\n  // std::bind(&sylar::IOManager::schedule<sylar::Fiber::ptr>, iom, fiber));\n  iom->addTimer(seconds * 1000, [iom, fiber]() { iom->schedule(fiber); });\n  sylar::Fiber::YieldToHold();\n  return 0;\n}\n...\n}\n\n```\n","tags":["sylar"],"categories":["c++"]},{"title":"set自定义比较函数","url":"/2023/10/19/sylar/c++/set自定义比较函数/","content":"\n使用insert()将元素插入到集合中去的时候，集合会根据设定的比较函数将该元素放到该放的节点上去。在定义集合的时候，如果没有指定比较函数，那么采用默认的比较函数(按键值由小到大的顺序插入元素)。\n\n自定义数据结构时，在使用 std::set 的过程中， **std::set 会默认调用自定义数据结构的 operator< 操作符函数**来比较两个对象的大小来进行排序（std::set 是有序的关联容器）\n\n## 重载<操作符\n\n**记住一个准则：永远让比较函数对相同元素返回false。**\nset容器在判定已有元素a和新插入元素b是否相等时，是这么做的：1）将a作为左操作数，b作为有操作数，调用比较函数，并返回比较值  2）将b作为左操作数，a作为有操作数，再调用一次比较函数，并返回比较值。如果1、2两步的返回值都是false，则认为a、b是相等的，则b不会被插入set容器中；如果1、2两步的返回值都是true，则可能发生未知行为，因此，记住一个准则：**永远让比较函数对相同元素返回false。**\n\n> 我们的操作符函数需要被定义成安全的 const 成员函数，其中 std::set 默认调用了不修改自定结构的值的 operator< 操作符，因此我们应该提供 const 版本的操作符重载版本：\n\n``` cpp\n\n// 按照id去重，按照score排序\n#include <iostream>\n#include <set>\nusing namespace std;\nstruct Person {\n  int m_id;\n  int m_score;\n  Person(int id, int score) {\n    this->m_id = id;\n    this->m_score = score;\n  }\n//   我们的操作符函数需要被定义成安全的 const 成员函数，其中 std::set 默认调用了不修改自定结构的值的 operator< 操作符，因此我们应该提供 const 版本的操作符重载版本：\n  bool operator<(const struct Person& right) const  //重载<运算符\n  {\n    if (this->m_id == right.m_id)  //根据id去重\n      return false;\n    else {\n      if (this->m_score != right.m_score) {\n        return this->m_score > right.m_score;  //按照分数降序，排序\n      } else {\n        return this->m_id > right.m_id;\n      }\n    }\n  }\n};\n\nint main() {\n  std::set<Person> mySet;\n  Person s1(10, 100);\n  Person s2(20, 200);\n  Person s3(20, 300);\n  Person s4(30, 200);\n  Person s5(30, 300);\n  mySet.insert(s1);  //插入s1\n  mySet.insert(s2);  //插入s2\n  mySet.insert(s3);  // s3和s2的id相同，不插入\n  mySet.insert(s4);  //插入s4\n  for (auto it : mySet) {\n    std::cout << \"id:\" << it.m_id << \",score:\" << it.m_score << std::endl;\n  }\n  std::cout << \"end\" << std::endl;\n  return 0;\n};\n```\n\n``` cpp\n结果如下：\nid:30,score:200\nid:20,score:200\nid:10,score:100\nend\n```\n\n## 重载（）运算符\n\n``` cpp\n// 按照id去重，按照score排序\n#include <iostream>\n#include <set>\nusing namespace std;\nstruct Person {\n  int m_id;\n  int m_score;\n  Person(int id, int score) {\n    this->m_id = id;\n    this->m_score = score;\n  }\n\n  // bool operator<(const struct Person& right) const  //重载<运算符\n  // {\n  //   if (this->m_id == right.m_id)  //根据id去重\n  //     return false;\n  //   else {\n  //     if (this->m_score != right.m_score) {\n  //       return this->m_score > right.m_score;  //降序\n  //     } else {\n  //       return this->m_id > right.m_id;\n  //     }\n  //   }\n  // }\n};\n\nstruct Cmp {\n  bool operator()(const Person &lhs, const Person &rhs) const {\n    if (lhs.m_id == rhs.m_id) {\n      return false;\n    } else {\n      if (lhs.m_score != rhs.m_score) {\n        return lhs.m_score > rhs.m_score;  //按照分数降序，排序\n      } else {\n        return lhs.m_id > rhs.m_id;  //相同分数，按照id排序\n      }\n    }\n  }\n};\n\nint main() {\n  std::set<Person, Cmp> mySet;\n  Person s1(10, 100);\n  Person s2(20, 200);\n  Person s3(20, 300);\n  Person s4(30, 200);\n  Person s5(30, 300);\n  mySet.insert(s1);  //插入s1\n  mySet.insert(s2);  //插入s2\n  mySet.insert(s3);  // s3和s2的id相同，不插入\n  mySet.insert(s4);  //插入s4\n\n  for (auto it : mySet) {\n    std::cout << \"id:\" << it.m_id << \",score:\" << it.m_score << std::endl;\n  }\n  std::cout << \"end\" << std::endl;\n  return 0;\n};\n```\n\n> 再比如说，你想要利用 `std::find` 来将一个 `std::vector` 中的自定义数据结构对象进行查找，这里就隐含需要调用自定义数据结构的`operator==`操作符。\n","tags":["sylar"],"categories":["c++"]},{"title":"协程调度模块","url":"/2023/10/17/sylar/模块/scheduler/","content":"\n\n\n协程调度最难理解的地方是当caller线程也参与调度时调度协程和主线程切换的情况，注意对照源码进行理解。\n\n## 协程调度器\n\n当你有很多协程时，如何把这些协程都消耗掉，这就是协程调度。\n引入协程调度后，则可以先创建一个协程调度器，然后把这些要调度的协程传递给调度器，由调度器负责把这些协程一个一个消耗掉。\n\n**调度任务的定义**\n对于协程调度器来说，协程当然可以作为调度任务，但实际上，函数也应可以，因为函数也是可执行的对象，调度器应当支持直接调度一个函数。这在代码实现上也很简单，只需要将函数包装成协程即可，协程调度器的实现重点还是以协程为基础。\n\n**多线程**，通过前面协程模块的知识我们可以知道，**一个线程同一时刻只能运行一个协程**，所以，作为协程调度器，势必要用到多线程来提高调度的效率，因为有多个线程就意味着有多个协程可以同时执行，这显然是要好过单线程的。\n\n既然多线程可以提高协程调度的效率，那么，能不能把调度器所在的线程（称为caller线程）也加入进来作为调度线程呢？\n比如典型地，在main函数中定义的调度器，能不能把main函数所在的线程也用来执行调度任务呢？答案是肯定的，在实现相同调度能力的情况下（指能够同时调度的协程数量），线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。\n甚至，调度器完全可以不创建新的线程，而只使用caller线程来进行协程调度，比如只使用main函数所在的线程来进行协程调度。\n\n**调度器如何运行**\n这里可以简单地认为，调度器创建后，内部首先会创建一个调度线程池，调度开始后，所有调度线程按顺序从任务队列里取任务执行，调度线程数越多，能够同时调度的任务也就越多，当所有任务都调度完后，调度线程就停下来等新的任务进来。\n\n**添加调度任务**\n添加调度任务的本质就是往调度器的任务队列里塞任务，但是，只添加调度任务是不够的，还应该有一种方式用于通知调度线程有新的任务加进来了，因为调度线程并不一定知道有新任务进来了。当然调度线程也可以不停地轮询有没有新任务，但是这样CPU占用率会很高。\n\n**调度器的停止**\n调度器应该支持停止调度的功能，以便回收调度线程的资源，只有当所有的调度线程都结束后，调度器才算真正停止。\n\n**通过上面的描述，一个协程调度器的大概设计也就出炉了：**\n调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。调度线程可以包含caller线程。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。\n\n**scheduler**\n\n* 封装的是N-M的协程调度器\n* 内部有一个线程池,支持协程在线程池里面切换\n\n---\n\n## sylar协程调度模块设计\n\n> sylar的协程调度模块支持多线程，支持使用caller线程进行调度，支持添加函数或协程作为调度对象，并且支持将函数或协程绑定到一个具体的线程上执行。\n\n**协程调度器的初始化**\nsylar的协程调度器在初始化时支持传入线程数和一个布尔型的**use_caller**参数，表示是否使用caller线程。在**使用caller线程的情况下，线程数自动减一，并且调度器内部会初始化一个属于caller线程的调度协程并保存起来（比如，在main函数中创建的调度器，如果use_caller为true，那调度器会初始化一个属于main函数线程的调度协程）。**\n\n**添加调度任务**\n调度器创建好后，即可调用调度器的**schedule**方法向调度器添加调度任务，但此时调度器并不会立刻执行这些任务，而是将它们保存到内部的一个任务队列中。\n\n**启动调度**\nstart方法调用后会创建调度线程池，线程数量由初始化时的线程数和use_caller确定。调度线程一旦创建，就会立刻从任务队列里取任务执行。比较特殊的一点是，如果初始化时指定线程数为1且use_caller为true，那么start方法什么也不做，因为不需要创建新线程用于调度。并且，由于没有创建新的调度线程，那只能由caller线程的调度协程来负责调度协程，而caller线程的调度协程的执行时机与start方法并不在同一个地方。\n\n**调度协程**\n对应run方法。调度协程负责从调度器的任务队列中取任务执行。取出的任务即子协程，这里调度协程和子协程的切换模型即为前一章介绍的非对称模型，每个子协程执行完后都必须返回调度协程，由调度协程重新从任务队列中取新的协程并执行。如果任务队列空了，那么调度协程会切换到一个idle协程，这个idle协程什么也不做，等有新任务进来时，idle协程才会退出并回到调度协程，重新开始下一轮调度。\n\n这里有点绕，细细体会。\n**在非caller线程里**，**调度协程就是执行此调度的线程中的主协程**，**但在caller线程里，调度协程并不是caller线程的主协程，而是相当于caller线程的子协程**，这在协程切换时会有大麻烦（这点是sylar协程调度模块最难理解的地方），如何处理这个问题将在下面的章节专门进行讨论。\n\n**添加调度任务**\n对应schedule方法，这个方法支持传入协程或函数，并且支持一个线程号参数，表示是否将这个协程或函数绑定到一个具体的线程上执行。如果任务队列为空，那么在添加任务之后，要调用一次tickle方法以通知各调度线程的调度协程有新任务来了。\n\n**子协程中创建并运行新的子协程**\n在执行调度任务时，还可以通过调度器的GetThis()方法获取到当前调度器，再通过schedule方法继续添加新的任务，这就变相实现了在子协程中创建并运行新的子协程的功能。\n\n**调度器的停止**\n\n* 首先是use_caller为false的情况，这种情况下，由于没有使用caller线程进行调度，那么只需要简单地等各个调度线程的调度协程退出就行了。\n* 如果use_caller为true，表示caller线程也要参于调度，这时，调度器初始化时记录的属于caller线程的调度协程就要起作用了，在调度器停止前，应该让这个caller线程的调度协程也运行一次，让caller线程完成调度工作后再退出。如果调度器只使用了caller线程进行调度，那么所有的调度任务要在调度器停止时才会被调度。\n\n## 调度协程切换问题\n\n1. 线程数为1，且use_caller为false，对应额外创建一个线程进行协程调度、main函数线程不参与调度的情况。\n2. 线程数为1，且use_caller为true，对应只使用main函数线程进行协程调度的情况。\n\n解决单线程环境下caller线程主协程-调度协程-任务协程之间的上下文切换，是sylar协程调度实现的关键。\n\n**第一种情况**\n因为有单独的线程用于协程调度，那只需要让新线程的入口函数作为调度协程，从任务队列里取任务执行就行了，main函数与调度协程完全不相关，main函数只需要向调度器添加任务，然后在适当的时机停止调度器即可。当调度器停止时，main函数要等待调度线程结束后再退出，参考下面的图示：\n\n![Alt text](../../../images/schedule_user_call_false.drawio.png)\n\n**第二种情况**\n因为没有额外的线程进行协程调度，那只能用main函数所在的线程来进行调度，而梳理一下main函数线程要运行的协程，会发现有以下三类协程：\n\n1. main函数对应的主协程\n\n2. 调度协程\n\n3. 待调度的任务协程\n\n在main函数线程里这三类协程运行的顺序是这样的：\n\n1. main函数主协程运行，创建调度器\n\n2. 仍然是main函数主协程运行，向调度器添加一些调度任务\n\n3. 开始协程调度，main函数主协程让出执行权，切换到调度协程，调度协程从任务队列里按顺序执行所有的任务\n\n4. 每次执行一个任务，调度协程都要让出执行权，再切到该任务的协程里去执行，任务执行结束后，还要再切回调度协程，继续下一个任务的调度\n\n5. 所有任务都执行完后，调度协程还要让出执行权并切回main函数主协程，以保证程序能顺利结束。\n\n* 这里t_scheduler_fiber(m_rootFiber)是main函数中的调度协程，**注意这个协程不是主协程**。主协程是t_threadFiber，后续还需要t_threadFiber切换回main，这里这里的操作主要是解决程序跑飞问题。\n上面的过程也可以总结为：main函数先攒下一波协程，然后切到调度协程里去执行，等把这些协程都消耗完后，再从调度协程切回来。\n参考下面图示：\n![Alt text](../../../images/image2.png)\n\n## 其他情况讨论\n\n**调度器的退出问题**\n\n 调度器内部有一个协程任务队列，调度器调度的实质就是内部的线程池从这个任务队列拿任务并执行，那么，停止调度时，如果任务队列还有任务剩余，要怎么处理？这里可以简化处理，强制规定只有所有的任务都完成调度时，调度器才可以退出，如果有一个任务没有执行完，那调度器就不能退出。\n\n**主动调用yield让出了执行权问题**\n\n任务协程执行过程中主动调用yield让出了执行权，调度器要怎么处理？半路yield的协程显然并没有执行完，一种处理方法是调度器来帮协程擦屁股，在检测到协程从resume返回时，如果状态仍为READY，那么就把协程重新扔回任务列，使其可以再次被调度，这样保证一个协程可以执行结束。但这种策略是画蛇添足的，从生活经验的角度来看，一个成熟的协程肯定要学会自我管理，既然你自己yield了，那么你就应该自己管理好自己，而不是让别人来帮你，这样才算是一个成熟的协程。\n\n对于主动yield的协程，我们的策略是，调度器直接认为这个任务已经调度完了，不再将其加入任务队列。如果协程想完整地运行，那么在yield之前，协程必须先把自己再扔回当前调度器的任务队列里，然后再执行yield，这样才能确保后面还会再来调度这个协程。\n\nsylar的处理方法比较折衷一些，sylar定义了两种yield操作，一种是yield to ready，这种yield调度器会再次将协程加入任务队列并等待调度，另一种是yield to hold，这种yield调度器不会再将协程加入任务队列，协程在yield之前必须自己先将自己加入到协程的调度队列中，否则协程就处于逃逸状态。再说一点，sylar定义的yield to ready，在整个sylar框架内一次都没用到，看来sylar也同意，一个成熟的协程要学会自我管理。\n\n**只使用调度器所在的线程进行调度**\n\n典型的就是main函数中定义调度器并且只使用main函数线程执行调度任务。这种场景下，可以认为是main函数先攒下一波协程，然后切到调度协程，把这些协程消耗完后再从调度协程切回main函数协程。每个协程在运行时也可以继续创建新的协程并加入调度。如果所有协程都调度完了，并且没有创建新的调度任务，那么下一步就是讨论idle该如何处理。\n\n**idle如何处理**\n\n也就是当调度器没有协程可调度时，调度协程该怎么办。直觉上来看这里应该有一些同步手段，比如，没有调度任务时，调度协程阻塞住，比如阻塞在一个idle协程上，等待新任务加入后退出idle协程，恢复调度。然而这种方案是无法实现的，因为每个线程同一时间只能有一个协程在执行，如果调度线程阻塞在idle协程上，那么除非idle协程自行让出执行权，否则其他的协程都得不到执行，这里就造成了一个**先有鸡还是先有蛋**的问题：只有创建新任务idle协程才会退出，只有idle协程退出才能创建新任务。为了解决这个问题，sylar采取了一个简单粗暴的办法，如果任务队列空了，调度协程会不停地检测任务队列，看有没有新任务，俗称忙等待，CPU使用率爆表。这点可以从sylar的源码上发现，一是Scheduler的tickle函数什么也不做，因为根本不需要通知调度线程是否有新任务，二是idle协程在协程调度器未停止的情况下只会yield to hold，而调度协程又会将idle协程重新swapIn，相当于idle啥也不做直接返回。这个问题在sylar框架内无解，只有一种方法可以规避掉，那就是设置autostop标志，这个标志会使得调度器在调度完所有任务后自动退出。在后续的IOManager中，上面的问题会得到一定的改善，并且tickle和idle可以实现得更加巧妙一些，以应对IO事件。\n\n**只有main函数线程参与调度时的调度执行时机**\n\n前面说过，当只有main函数线程参与调度时，可以认为是主线程先攒下一波协程，然后切到调度协程开始调度这些协程，等所有的协程都调度完了，调度协程进idle状态，这个状态下调度器只能执行忙等待，啥也做不了。这也就是说，主线程main函数一旦开启了协程调度，就无法回头了，位于开始调度点之后的代码都执行不到。对于这个问题，sylar把调度器的开始点放在了stop方法中，也就是，调度开始即结束，干完活就下班。IOManager也是类似，除了可以调用stop方法外，IOManager类的析构函数也有一个stop方法，可以保证所有的任务都会被调度到。\n\n**额外创建了调度线程时的调度执行时机**\n\n如果不额外创建线程，也就是线程数为1并且use caller，那所有的调度任务都在stop()时才会进行调度。但如果额外创建了线程，那么，在添加完调度任务之后任务马上就可以在另一个线程中调度执行。归纳起来，如果只使用caller线程进行调度，那所有的任务协程都在stop之后排队调度，如果有额外线程，那任务协程在刚添加到任务队列时就可以得到调度。\n\n**关于协程调度器的优雅停止**\n\nsylar停止调度器的策略如下：\n\n1. 设置m_stopping标志，该标志表示正在停止\n2. 检测是否使用了caller线程进行调度，如果使用了caller线程进行调度，那要保证stop方法是由caller线程发起的\n3. 通知其他调度线程的调度协程退出调度\n4. 通知当前线程的调度协程退出调度\n5. 如果使用了caller线程进行调度，那执行一次caller线程的调度协程（只使用caller线程时的协程调度全仰仗这个操作）\n6. 等caller线程的调度协程返回\n7. 等所有调度线程结束\n\n## Sylar协程调度模块实现\n\n### Fiber的修改\n\n``` cpp\nFiber::Fiber(std::function<void()> cb, size_t stacksize, bool use_caller)\n    : m_id(++s_fiber_id), m_cb(cb) {\n  ++s_fiber_count;\n  m_stacksize = stacksize ? stacksize : g_fiber_stack_size->getValue();\n\n  m_stack = StackAllocator::Alloc(m_stacksize);\n  if (getcontext(&m_ctx)) {\n    SYLAR_ASSERT2(false, \"getcontext\");\n  }\n  m_ctx.uc_link = nullptr;\n  m_ctx.uc_stack.ss_sp = m_stack;\n  m_ctx.uc_stack.ss_size = m_stacksize;\n\n  if (!use_caller) {\n    makecontext(&m_ctx, &Fiber::MainFunc, 0);\n  } else {\n    makecontext(&m_ctx, &Fiber::CallerMainFunc, 0);\n  }\n\n  SYLAR_LOG_DEBUG(g_logger) << \"Fiber::Fiber id=\" << m_id;\n}\n\n// 将执行run的线程换出，换为main函数中的主协程执行\nvoid Fiber::call() {\n  // bug\n  SetThis(this);\n  m_state = EXEC;\n  // 和swapIn 的区别---> main函数中的主协程-->t_threadFiber\n  if (swapcontext(&t_threadFiber->m_ctx, &m_ctx)) {\n    SYLAR_ASSERT2(false, \"swapcontext\");\n  }\n}\n\nvoid Fiber::back() {\n  SetThis(t_threadFiber.get());\n\n  if (swapcontext(&m_ctx, &t_threadFiber->m_ctx)) {\n    SYLAR_ASSERT2(false, \"swapcontext\");\n  }\n}\n\n// 切换到当前协程执行\nvoid Fiber::swapIn() {\n  SetThis(this);\n  SYLAR_ASSERT(m_state != EXEC);\n  m_state = EXEC;\n  // 取当前协程的主协程，自己swap自己，会死锁，所以建立了call\n  // 这里的GetMainFiber--->是指向run函数的那个fiber\n  if (swapcontext(&Scheduler::GetMainFiber()->m_ctx, &m_ctx)) {\n    SYLAR_ASSERT2(false, \"swapcontext\");\n  }\n}\n\n// 把当前协程切换到后台,调度协程换出来\nvoid Fiber::swapOut() {\n  SetThis(Scheduler::GetMainFiber());\n  if (swapcontext(&m_ctx, &Scheduler::GetMainFiber()->m_ctx)) {\n    SYLAR_ASSERT2(false, \"swapcontext\");\n  }\n}\n```\n\n### 对调度任务的定义\n\n如下，这里任务类型可以是协程/函数二选一，并且可指定调度线程。\n\n``` cpp\n/**\n * @brief 调度任务，协程/函数二选一，可指定在哪个线程上调度\n */\nstruct FiberAndThread {\n    /// 协程\n    Fiber::ptr fiber;\n    /// 协程执行函数\n    std::function<void()> cb;\n    /// 线程id，---需要指定协程在哪一个线程上执行\n    int thread;\n\n    /**\n     * @brief 构造函数\n     * @param[in] f 协程\n     * @param[in] thr 线程id\n     */\n    FiberAndThread(Fiber::ptr f, int thr) : fiber(f), thread(thr) {}\n\n    /**\n     * @brief 构造函数\n     * @param[in] f 协程指针\n     * @param[in] thr 线程id\n     * @post *f = nullptr---swap  todo\n     */\n    FiberAndThread(Fiber::ptr *f, int thr) : thread(thr) { fiber.swap(*f); }\n\n    /**\n     * @brief 构造函数\n     * @param[in] f 协程执行函数\n     * @param[in] thr 线程id\n     */\n    FiberAndThread(std::function<void()> f, int thr) : cb(f), thread(thr) {}\n\n    /**\n     * @brief 构造函数\n     * @param[in] f 协程执行函数指针\n     * @param[in] thr 线程id\n     * @post *f = nullptr\n     */\n    FiberAndThread(std::function<void()> *f, int thr) : thread(thr) { cb.swap(*f); }\n\n    /**\n     * @brief 无参构造函数\n     * stl 中一定需要默认构造函数\n     */\n    FiberAndThread() : thread(-1) {}\n\n    /**\n     * @brief 重置数据\n     */\n    void reset() {\n      fiber = nullptr;\n      cb = nullptr;\n      thread = -1;\n    }\n  };\n```\n\n### 调度器的成员变量\n\n``` cpp\n private:\n  /// Mutex\n  MutexType m_mutex;\n  /// 线程池\n  std::vector<Thread::ptr> m_threads;\n  /// 待执行的协程队列\n  std::list<FiberAndThread> m_fibers;\n  /// use_caller为true时有效, 调度协程\n  Fiber::ptr m_rootFiber;\n  /// 协程调度器名称\n  std::string m_name;\n\n protected:\n  /// 协程下的线程id数组\n  std::vector<int> m_threadIds;\n  /// 线程数量\n  size_t m_threadCount = 0;\n  /// 工作线程数量\n  std::atomic<size_t> m_activeThreadCount = {0};\n  /// 空闲线程数量\n  std::atomic<size_t> m_idleThreadCount = {0};\n  /// 用来表示Scheduler::start()是否启动，默认表示未启动\n  bool m_stopping = true;\n  /// 是否自动停止\n  // 这个标志会使得调度器在调度完所有任务后自动退出。\n  bool m_autoStop = false;\n  /// 主线程id(use_caller)\n  int m_rootThread = 0;\n```\n\n### 协程调度模块的全局变量和线程局部变量\n\n``` cpp\n/// 当前线程的调度器，同一个调度器下的所有线程，指向同一个调度器实例\nstatic thread_local Scheduler *t_scheduler = nullptr;\n/// 当前线程的调度协程，每个线程都独有一份，包括caller线程\nstatic thread_local Fiber *t_scheduler_fiber = nullptr;\n```\n\n> t_scheduler_fiber保存当前线程的调度协程，加上Fiber模块的t_fiber和t_thread_fiber，每个线程总共可以记录三个协程的上下文信息。\n\n### 调度器的构造方法\n\n``` cpp\n\n/**\n * @brief 创建调度器\n * @param[in] threads 线程数\n * @param[in] use_caller 是否将当前线程也作为调度线程\n * @param[in] name 名称\n */\n// 调度器\nScheduler::Scheduler(size_t threads, bool use_caller, const std::string &name) : m_name(name) {\n  // 首先输入的线程要大于0\n  SYLAR_ASSERT(threads > 0);\n\n  if (use_caller) {\n    // 如果此线程没有协程，会给他初始化一个主协程\n    sylar::Fiber::GetThis();\n    // 因为use_caller,表示当前线程也是调度线程之一。\n    --threads;\n\n    // 防止此线程创建多个协程调度器。这里的GetThis() 为\n    // Scheduler *Scheduler::GetThis() { return t_scheduler; }\n    SYLAR_ASSERT(Scheduler::GetThis() == nullptr);\n    t_scheduler = this;\n\n    // ??\n    m_rootFiber.reset(new Fiber(std::bind(&Scheduler::run, this), 0, true));\n    sylar::Thread::SetName(m_name);  // 修改线程名称\n\n    // 在一个线程内声明一个调度器，在将当前线程放入调度器内，他的主协程就不是线程的主协程\n    // ，而是执行run方法的主协程 主协程。 ？？？ todo\n    t_fiber = m_rootFiber.get();\n    m_rootThread = sylar::GetThreadId();\n    m_threadIds.push_back(m_rootThread);\n  } else {\n    m_rootThread = -1;\n  }\n  m_threadCount = threads;\n}\n\nScheduler::~Scheduler() {\n    // m_stopping变为true，则表示调度结束\n  SYLAR_ASSERT(m_stopping);\n  if (GetThis() == this) {\n    t_scheduler = nullptr;\n  }\n}\n\nclass Scheduler {\npublic:\n\n  /**\n   * @brief 构造函数\n   * @param[in] threads 线程数量\n   * @param[in] use_caller 是否使用当前调用线程\n   * @param[in] name 协程调度器名称，线程池名称。\n   */\n  Scheduler(size_t threads = 1, bool use_caller = true, const std::string &name = \"\");\n\n  /**\n   * @brief 调度协程\n   * @param[in] fc 协程或函数\n   * @param[in] thread 协程执行的线程id,-1标识任意线程\n   */\n  template <class FiberOrCb>\n  void schedule(FiberOrCb fc, int thread = -1) {\n    bool need_tickle = false;\n    {\n      MutexType::Lock lock(m_mutex);\n      need_tickle = scheduleNoLock(fc, thread);\n    }\n\n    // 待执行队列为空时，然后添加了一个带执行的任务， 则执行下面语句，具体细节查看scheduleNoLock\n    if (need_tickle) {\n      tickle();\n    }\n  }\n\n  /**\n   * @brief 批量调度协程\n   * @param[in] begin 协程数组的开始\n   * @param[in] end 协程数组的结束\n   */\n  template <class InputIterator>\n  void schedule(InputIterator begin, InputIterator end) {\n    bool need_tickle = false;\n    {\n      MutexType::Lock lock(m_mutex);\n      while (begin != end) {\n        // 参数为指针，取得是地址，会将里面的东西 swap掉。---这里怎么确认是callback还是fiber？？\n        need_tickle = scheduleNoLock(&*begin, -1) || need_tickle;\n        ++begin;\n      }\n    }\n    if (need_tickle) {\n      tickle();\n    }\n  }\n\n private:\n  /**\n   * @brief 协程调度启动(无锁)\n   */\n  template <class FiberOrCb>\n  bool scheduleNoLock(FiberOrCb fc, int thread) {\n    bool need_tickle = m_fibers.empty();  // true = 空的待执行队列\n    FiberAndThread ft(fc, thread);\n    // 是协程或者function\n    if (ft.fiber || ft.cb) {\n      m_fibers.push_back(ft);\n    }\n    // 以前是空的，加上一个后不为空了，我就需要唤醒线程，有任务来了\n    return need_tickle;\n  }\n\n};\n```\n\n### 两个get方法\n\n用于获取当前线程的调度器的调度协程，这两个都是静态方法\n\n``` cpp\n// static thread_local Scheduler *t_scheduler = nullptr;\nScheduler *Scheduler::GetThis() { return t_scheduler; }\n\n// 主协程 static thread_local Fiber *t_fiber = nullptr;\nFiber *Scheduler::GetMainFiber() { return t_fiber; }\n\n```\n\n### start方法\n\n这里主要初始化调度线程池，如果只使用caller线程进行调度，那这个方法啥也不做：\n\n``` cpp\n// 启动线程池\nvoid Scheduler::start() {\n  MutexType::Lock lock(m_mutex);\n  // m_stopping 默认为true --->表示未启动， false 则为启动\n  if (!m_stopping) {\n    return;\n  }\n  m_stopping = false;\n  // 此时线程池应该是空的，未分配线程。\n  SYLAR_ASSERT(m_threads.empty());\n\n  // 此时配置线程池，线程都跑run方法，\n  m_threads.resize(m_threadCount);\n  for (size_t i = 0; i < m_threadCount; ++i) {\n    m_threads[i].reset(\n        new Thread(std::bind(&Scheduler::run, this), m_name + \"_\" + std::to_string(i)));\n    // 线程构造函数放置信号量，确保线程跑起来，才能真正拿到线程id。\n    m_threadIds.push_back(m_threads[i]->getId());\n  }\n  lock.unlock();\n}\n```\n\n### 判断调度器是否已经停止的方法\n\n只有当所有的任务都被执行完了，调度器才可以停止：\n\n``` cpp\nbool Scheduler::stopping() {\n    MutexType::Lock lock(m_mutex);\n    return m_stopping && m_tasks.empty() && m_activeThreadCount == 0;\n}\n```\n\n### 调度器的tickle和idle实现\n\n可以看到这两个方法并没有什么用：\n\n``` cpp\nvoid Scheduler::tickle() {\n    SYLAR_LOG_DEBUG(g_logger) << \"ticlke\";\n}\n// 没有任务时，执行idle\nvoid Scheduler::idle() {\n  SYLAR_LOG_INFO(g_logger) << \"idle\";\n  while (!stopping()) {\n    sylar::Fiber::YieldToHold();\n  }\n}\n```\n\n### run\n\n由于Fiber类改造过，每个被调度器执行的协程在结束时都会回到调度协程，所以这里不用担心跑飞问题，当任务队列为空时，代码会进idle协程，但idle协程啥也不做直接就yield了，状态还是READY状态，所以这里其实就是个忙等待，CPU占用率爆炸，只有当调度器检测到停止标志时，idle协程才会真正结束，调度协程也会检测到idle协程状态为TERM，并且随之退出整个调度协程。这里还可以看出一点，对于一个任务协程，只要其从resume中返回了，那不管它的状态是TERM还是READY，调度器都不会自动将其再次加入调度，因为前面说过，一个成熟的协程是要学会自我管理的。\n\n``` cpp\n// 核心--->协程和线程的关系\n// 首先设置当前线程的schedule\n// 设置当前线程的 run  fiber\n// 写成调度循环while(true)\n//   消息队列里是否有任务\n//   无任务执行，执行idle\n\n// 这个run 一个线程只会有一个协程来执行\n// 一个是use_caller的线程在run执行,线程池里面自己创建的线程也在run中执行\nvoid Scheduler::run() {\n  // 设置当前的协程调度器\n  setThis();\n  // 如果当前线程id != 主协程id\n  if (sylar::GetThreadId() != m_rootThread) {\n    // 就将主fiber 设置为当前线程id\n    t_fiber = Fiber::GetThis().get();\n  }\n\n  Fiber::ptr idle_fiber(new Fiber(std::bind(&Scheduler::idle, this)));\n  Fiber::ptr cb_fiber;\n\n  // 协程和线程\n  FiberAndThread ft;\n  while (true) {\n    ft.reset();\n    bool tickle_me = false;\n    // 防止协程调度结束\n    bool is_active = false;\n    // 协程的消息队列中，取出一个协程任务\n    {\n      MutexType::Lock lock(m_mutex);\n      auto it = m_fibers.begin();\n      while (it != m_fibers.end()) {\n        // 如果一个任务(协程)已经指定好在哪个线程执行，我当前执行run的线程id != 他期望的线程id\n        if (it->thread != -1 && it->thread != sylar::GetThreadId()) {\n          ++it;\n          // 通知别人来处理，后面可以优化，通知这里。\n          tickle_me = true;\n          continue;\n        }\n        // fiber cb 至少要有一个，确定任务非空\n        SYLAR_ASSERT(it->fiber || it->cb);\n        // exec--正在执行状态，此时也不处理。\n        if (it->fiber && it->fiber->getState() == Fiber::EXEC) {\n          ++it;\n          continue;\n        }\n\n        // 开始处理\n        ft = *it;\n        tickle_me = true;\n        m_fibers.erase(it++);  // 从待处理队列中删除，这里注意迭代器删除的细节，当心bug\n        ++m_activeThreadCount;\n        is_active = true;\n        break;  // while 只循环一次，目的是依次处理每个待处理的任务。\n      }\n      // tickle_me |= it != m_fibers.end(); todo\n    }\n\n    //取出了一个需要执行任务，唤醒其他线程\n    if (tickle_me) {\n      tickle();  //\n    }\n\n    // 执行这个协程，fiber的方式\n    if (ft.fiber &&\n        (ft.fiber->getState() != Fiber::TERM && ft.fiber->getState() != Fiber::EXCEPT)) {\n      // 执行 ft，唤醒，去执行\n      ft.fiber->swapIn();\n      // 执行完之后，数量--\n      --m_activeThreadCount;\n      // 判断是否需要再次执行\n      if (ft.fiber->getState() == Fiber::READY) {\n        schedule(ft.fiber);\n      } else if (ft.fiber->getState() != Fiber::TERM && ft.fiber->getState() != Fiber::EXCEPT) {\n        // 设置暂停状态，除了上面的判断的语句外，除了ready， 就是hold状态\n        ft.fiber->m_state = Fiber::HOLD;\n      }\n      // FiberAndThread::reset\n      ft.reset();\n    }\n    // 执行这个协程，cb 的方式\n    else if (ft.cb) {\n      if (cb_fiber) {\n        // 重置协程状态，\n        cb_fiber->reset(ft.cb);\n      } else {\n        // 智能指针的 reset\n        cb_fiber.reset(new Fiber(ft.cb));\n      }\n      // 释放掉\n      ft.reset();\n      // 唤醒cb_fiber\n      cb_fiber->swapIn();\n      // 运行结束后\n      --m_activeThreadCount;\n      // 判断是否需要再次执行\n      if (cb_fiber->getState() == Fiber::READY) {\n        schedule(cb_fiber);\n        cb_fiber.reset();  // 智能指针reset\n      } else if (cb_fiber->getState() == Fiber::EXCEPT || cb_fiber->getState() == Fiber::TERM) {\n        cb_fiber->reset(\n            nullptr);  // 出现异常或者执行完成，智能指针的reset，释放掉，并没有引起他的析构\n      } else  // if (cb_fiber->getState() != Fiber::TERM)\n      {\n        // 没有结束，设置暂停状态\n        cb_fiber->m_state = Fiber::HOLD;\n        cb_fiber.reset();\n      }\n    }\n    // 调度协程，后面这里表示没有任务执行，事情做完之后\n    else {\n      if (is_active) {\n        --m_activeThreadCount;\n        continue;\n      }\n      // fiber已经结束，直接break\n      if (idle_fiber->getState() == Fiber::TERM) {\n        SYLAR_LOG_INFO(g_logger) << \"idle fiber term\";\n        break;\n      }\n\n      // 空闲线程数 ++\n      ++m_idleThreadCount;\n      // idle_fiber 去执行，---***每个线程，同一时刻只有一个协程在执行。\n      // ？？在执行idle_fiber时，来了任务要怎么唤醒\n      idle_fiber->swapIn();\n      --m_idleThreadCount;\n      // if (idle_fiber->getState() != Fiber::TERM || idle_fiber->getState() != Fiber::EXCEPT) //\n      // ---> bug\n      // idle_fiber执行完之后，判断状态来进行处理，\n      if (idle_fiber->getState() != Fiber::TERM && idle_fiber->getState() != Fiber::EXCEPT) {\n        idle_fiber->m_state = Fiber::HOLD;\n      }\n    }\n  }\n}\n```\n\n### stop\n\n``` cpp\n// 优雅退出，等待所有任务完成退出\n// 线程没事做时，需要循环等待，stop就是做一个等的动作\nvoid Scheduler::stop() {\n  // 两种情况\n  // 一种是用了 use_caller。 -- 必须要去创建schedule的哪个线程去执行stop。\n  // 一种是未使用， 对应额外创建一个线程进行协程调度、main函数线程不参与调度的情况。\n  m_autoStop = true;\n  // m_rootFiber是指创建schedule方法的线程中的协程的里面的执行run的那个协程-->调度协程;\n  // TERM --->结束状态, INIT---> 初始化状态\n  if (m_rootFiber && m_threadCount == 0 &&\n      (m_rootFiber->getState() == Fiber::TERM || m_rootFiber->getState() == Fiber::INIT)) {\n    SYLAR_LOG_INFO(g_logger) << this << \"stopped\";\n    // 此时已结束，或者未跑起来，那么我们就要设置结束\n    m_stopping = true;\n    // 自己写的bug\n    // if (m_stopping) {\n    //   return;\n    // }\n\n    // use_caller 并且只有一个线程的时候，从这里返回\n    if (stopping()) {\n      return;\n    }\n  }\n\n  // m_rootThread != -1，说明是 use_caller 线程\n  if (m_rootThread != -1) {\n    // 目的是，把创建它的哪个线程也使用上时，stop一定要在创建他的那个线程执行\n    SYLAR_ASSERT(Scheduler::GetThis() == this);\n  } else {\n    SYLAR_ASSERT(GetThis() != this);\n  }\n\n  // 设置为true 表示可以结束\n  m_stopping = true;\n  for (size_t i = 0; i < m_threadCount; ++i) {\n    // 使线程唤醒\n    tickle();\n  }\n\n  if (m_rootFiber) {\n    tickle();\n  }\n\n  /// 在use caller情况下，调度器协程结束时，应该返回caller协程\n  if (m_rootFiber) {\n    if (!stopping()) {\n      m_rootFiber->call();\n      SYLAR_LOG_DEBUG(g_logger) << \"m_rootFiber end\";\n    }\n  }\n\n  std::vector<Thread::ptr> thrs;\n  {\n    MutexType::Lock lock(m_mutex);\n    thrs.swap(m_threads);\n  }\n\n  // 所有线程 join\n  for (auto &i : thrs) {\n    i->join();\n  }\n}\n```\n\n**注意事项**\nsylar的协程调度模块因为存任务队列空闲时调度线程忙等待的问题，所以实际上并不实用，真正实用的是后面基于Scheduler实现的IOManager。由于任务队列的任务是按顺序执行的，如果有一个任务占用了比较长时间，那其他任务的执行会受到影响，如果任务执行的是像while(1)这样的循环，那线程数不够时，后面的任务都不会得到执行。另外，当前还没有实现hook功能，像sleep和等待IO就绪这样的操作也会阻塞协程调度。\n\n参考：\n<https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060963>\n","tags":["sylar"],"categories":["sylar"]},{"title":"协程模块","url":"/2023/10/16/sylar/模块/协程模块/","content":"# 协程\n\n**协程和线程的区别**\n协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。\n\n其实这点也好理解，毕竟协程只是以一种花里胡哨的方式去运行一个函数，不管实现得如何巧妙，也不可能在单线程里做到同时运行两个函数，否则还要多线程有何用？\n\n因为单线程下协程并不是并发执行，而是顺序执行的，所以不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。\n\n同样是单线程环境下，协程的yield和resume一定是同步进行的，一个协程的yield，必然对应另一个协程的resume，因为线程不可能没有执行主体。\n\n并且，协程的yield和resume是完全由应用程序来控制的。与线程不同，线程创建之后，线程的运行和调度也是由操作系统自动完成的，但协程创建后，协程的运行和调度都要由应用程序来完成，就和调用函数一样，所以协程也被称为用户态线程。\n\n* 所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；\n* 所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；\n* 所谓定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。\n\n``` cpp\n// 上下文结构体定义\n// 这个结构体是平台相关的，因为不同平台的寄存器不一样\n// 下面列出的是所有平台都至少会包含的4个成员\ntypedef struct ucontext_t {\n    // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效\n    struct ucontext_t *uc_link;\n    // 当前上下文的信号屏蔽掩码\n    sigset_t          uc_sigmask;\n    // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效\n    stack_t           uc_stack;\n    // 平台相关的上下文具体内容，包含寄存器的值\n    mcontext_t        uc_mcontext;\n    ...\n} ucontext_t;\n \n// 获取当前的上下文\nint getcontext(ucontext_t *ucp);\n \n// 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数\nint setcontext(const ucontext_t *ucp);\n \n// 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，\n// 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间，\n// 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文，\n// 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了\n// makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行\nvoid makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);\n \n// 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，\n// 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数\n// swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换\nint swapcontext(ucontext_t *oucp, const ucontext_t *ucp);\n```\n\nsylar使用非对称协程模型，也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。\n\n![Alt text](../../images/image.png)\nsylar借助了线程局部变量的功能来实现协程模块。线程局部变量与全局变量类似，不同之处在于声明的线程局部变量在每个线程都独有一份，而全局变量是全部线程共享一份。\n\nsylar使用线程局部变量（C++11 thread_local变量）来保存协程上下文对象，这点很好理解，因为协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。\n\n对于每个线程的协程上下文，sylar设计了两个线程局部变量来存储上下文信息（对应源码的t_fiber和t_thread_fiber），也就是说，一个线程在任何时候最多只能知道两个协程的上下文。又由于sylar只使用swapcontext来做协程切换，那就意味着，这两个线程局部变量必须至少有一个是用来保存线程主协程的上下文的，如果这两个线程局部变量存储的都是子协程的上下文，那么不管怎么调用swapcontext，都没法恢复主协程的上下文，也就意味着程序最终无法回到主协程去执行，程序也就跑飞了。\n\n## sylar协程模块实现\n\n### 协程状态\n\n``` cpp\n  enum State {\n    /// 初始化状态\n    INIT,\n    /// 暂停状态\n    HOLD,\n    /// 执行中状态\n    EXEC,\n    /// 结束状态\n    TERM,\n    /// 可执行状态\n    READY,\n    /// 异常状态\n    EXCEPT\n  };\n```\n\n### 协程原语\n\n对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume(swapIn)，表示恢复协程运行，一种是yield(swapOut)，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。\n\n### 协程类实现\n\nsylar的协程通过Fiber类来表示，这个类包含以下成员变量：\n\n``` cpp\n/// 协程id\nuint64_t m_id        = 0;\n/// 协程栈大小\nuint32_t m_stacksize = 0;\n/// 协程状态\nState m_state        = READY;\n/// 协程上下文\nucontext_t m_ctx;\n/// 协程栈地址\nvoid *m_stack = nullptr;\n/// 协程入口函数\nstd::function<void()> m_cb;\n```\n\nFiber的源码定义了两个全局静态变量，用于生成协程id和统计当前的协程数，如下：\n\n``` cpp\n/// 全局静态变量，用于生成协程id\nstatic std::atomic<uint64_t> s_fiber_id{0};\n/// 全局静态变量，用于统计当前的协程数\nstatic std::atomic<uint64_t> s_fiber_count{0};\n```\n\n然后是线程局部变量，对于每个线程，sylar设计了以下两个线程局部变量用于保存协程上下文信息：\n\n``` cpp\n/// 线程局部变量，每个线程独有一份，当前线程正在运行的协程\nstatic thread_local Fiber *t_fiber = nullptr;\n\n/// 线程局部变量，每个线程独有一份，当前线程的主协程，切换到这个协程，就相当于切换到了主协程中运行，智能指针形式\nstatic thread_local Fiber::ptr t_threadFiber = nullptr;\n```\n\n这两个线程局部变量保存的协程上下文对协程的实现至关重要，它们的用途如下：\n\nt_fiber：保存当前正在运行的协程指针，必须时刻指向当前正在运行的协程对象。协程模块初始化时，t_fiber指向线程主协程对象。\n\nt_thread_fiber：保存线程主协程指针，智能指针形式。协程模块初始化时，t_thread_fiber指向线程主协程对象。当子协程resume时，通过swapcontext将主协程的上下文保存到t_thread_fiber的ucontext_t成员中，同时激活子协程的ucontext_t上下文。当子协程yield时，从t_thread_fiber中取得主协程的上下文并恢复运行。\n\n**协程类Fiber的成员方法**\n首先是协程的构建函数。Fiber类提供了两个构造函数，带参数的构造函数用于构造子协程，初始化子协程的ucontext_t上下文协和栈空间，要求必须传入协程的入口函数，以及可选的协程栈大小。不带参的构造函数用于初始化当前线程的协程功能，构造线程主协程对象，以及对t_fiber和t_thread_fiber进行赋值。\n\n这个构造函数被定义成私有方法，不允许在类外部调用，只能通过GetThis()方法，在返回当前正在运行的协程时，如果发现当前线程的主程未被初始化，那就用不带参的构造函数初始化线程主协程。\n因为GetThis()兼具初始化主协程的功能，在使用协程之前必须显式调用一次GetThis()。\n\n``` cpp\n/**\n * @brief 构造函数\n * @attention 无参构造函数只用于创建线程的第一个协程，也就是线程主函数对应的协程，\n * 这个协程只能由GetThis()方法调用，所以定义成私有方法\n */\nFiber::Fiber() {\n  m_state = EXEC;\n  // 设置当前正在运行的协程\n  SetThis(this);\n\n  if (getcontext(&m_ctx)) {\n    SYLAR_ASSERT2(false, \"getcontext\");\n  }\n\n  ++s_fiber_count;\n\n  SYLAR_LOG_DEBUG(g_logger) << \"Fiber::Fiber main\";\n}\n\n/**\n * @brief 构造函数，用于创建用户协程\n * @param[] cb 协程入口函数\n * @param[] stacksize 栈大小，默认为128k\n */\nFiber::Fiber(std::function<void()> cb, size_t stacksize)\n    : m_id(s_fiber_id++)\n    , m_cb(cb) {\n    ++s_fiber_count;\n    m_stacksize = stacksize ? stacksize : g_fiber_stack_size->getValue();\n    m_stack     = StackAllocator::Alloc(m_stacksize);\n \n    if (getcontext(&m_ctx)) {\n        SYLAR_ASSERT2(false, \"getcontext\");\n    }\n \n    m_ctx.uc_link          = nullptr;\n    m_ctx.uc_stack.ss_sp   = m_stack;\n    m_ctx.uc_stack.ss_size = m_stacksize;\n \n    makecontext(&m_ctx, &Fiber::MainFunc, 0);\n \n    SYLAR_LOG_DEBUG(g_logger) << \"Fiber::Fiber() id = \" << m_id;\n}\n\n/**\n * @brief 返回当前线程正在执行的协程\n * @details 如果当前线程还未创建协程，则创建线程的第一个协程，\n * 且该协程为当前线程的主协程，其他协程都通过这个协程来调度，也就是说，其他协程\n * 结束时,都要切回到主协程，由主协程重新选择新的协程进行resume\n * @attention 线程如果要创建协程，那么应该首先执行一下Fiber::GetThis()操作，以初始化主函数协程\n */\nFiber::ptr GetThis(){\n    if (t_fiber) {\n        return t_fiber->shared_from_this();\n    }\n \n    Fiber::ptr main_fiber(new Fiber);\n    SYLAR_ASSERT(t_fiber == main_fiber.get());\n    t_thread_fiber = main_fiber;\n    return t_fiber->shared_from_this();\n}\n```\n\n**接下来是协程原语的实现，也就是resume和yield**\n\n``` cpp\n// 切换到当前协程执行\nvoid Fiber::swapIn() {\n  SetThis(this);\n  SYLAR_ASSERT(m_state != EXEC);\n  m_state = EXEC;\n  // 取当前协程的主协程，自己swap自己，会死锁，所以建立了call\n  // 这里的GetMainFiber--->是指向run函数的那个fiber\n  if (swapcontext(&Scheduler::GetMainFiber()->m_ctx, &m_ctx)) {\n    SYLAR_ASSERT2(false, \"swapcontext\");\n  }\n}\n\n/**\n* @brief 将当前线程切换到执行状态\n* @pre 执行的为当前线程的主协程\n*/\nvoid Fiber::call() {\n  SetThis(this);\n  m_state = EXEC;\n  // 和swapIn 的区别-->线程中的主协程-->t_threadFiber\n  if (swapcontext(&t_threadFiber->m_ctx, &m_ctx)) {\n    SYLAR_ASSERT2(false, \"swapcontext\");\n  }\n}\n\n// 把当前协程切换到后台,调度协程换出来执行\nvoid Fiber::swapOut() {\n  SetThis(Scheduler::GetMainFiber());\n  if (swapcontext(&m_ctx, &Scheduler::GetMainFiber()->m_ctx)) {\n    SYLAR_ASSERT2(false, \"swapcontext\");\n  }\n}   \n\n/**\n* @brief 将当前线程切换到后台\n* @pre 执行的为该协程\n* @post 返回到线程的主协程\n*/\nvoid Fiber::back() {\n    SetThis(t_threadFiber.get());\n\n    if (swapcontext(&m_ctx, &t_threadFiber->m_ctx)) {\n    SYLAR_ASSERT2(false, \"swapcontext\");\n    }\n}\n```\n\n在非对称协程里，执行swapIn时的当前执行环境一定是位于线程主协程里，所以这里的swapcontext操作的结果把主协程的上下文保存到t_thread_fiber->m_ctx中，并且激活子协程的上下文；而执行swapOut时，当前执行环境一定是位于子协程里，所以这里的swapcontext操作的结果是把子协程的上下文保存到协程自己的m_ctx中，同时从t_thread_fiber获得主协程的上下文并激活。\n\n**协程入口函数**\n\n``` cpp\n// 线程的主协程(调度协程)不会进入到MainFunc中,\nvoid Fiber::MainFunc() {\n    Fiber::ptr cur = GetThis();  // GetThis()的shared_from_this()方法让引用计数加1\n    SYLAR_ASSERT(cur);\n    try {\n        cur->m_cb();  // 这里真正执行协程的入口函数\n        cur->m_cb = nullptr;\n        cur->m_state = TERM;\n    } catch (std::exception& ex) {\n        cur->m_state = EXCEPT;\n        SYLAR_LOG_ERROR(g_logger) << \"Fiber Except: \" << ex.what()\n            << \" fiber_id=\" << cur->getId()\n            << std::endl\n            << sylar::BacktraceToString();\n    } catch (...) {\n        cur->m_state = EXCEPT;\n        SYLAR_LOG_ERROR(g_logger) << \"Fiber Except\"\n            << \" fiber_id=\" << cur->getId()\n            << std::endl\n            << sylar::BacktraceToString();\n    }\n\n    auto raw_ptr = cur.get(); // 手动让t_fiber的引用计数减1\n    cur.reset();\n    raw_ptr->swapOut(); // 协程结束时自动swapOut，以回到主协程(调度协程)\n\n    SYLAR_ASSERT2(false, \"never reach fiber_id=\" + std::to_string(raw_ptr->getId()));\n}\n\n\nvoid Fiber::CallerMainFunc() {\n  Fiber::ptr cur = GetThis();  // GetThis()的shared_from_this()方法让引用计数加1\n  SYLAR_ASSERT(cur);\n  try {\n    cur->m_cb();\n    cur->m_cb = nullptr;\n    cur->m_state = TERM;\n  } catch (std::exception &ex) {\n    cur->m_state = EXCEPT;\n    SYLAR_LOG_ERROR(g_logger) << \"Fiber Except: \" << ex.what() << \" fiber_id=\" << cur->getId()\n                              << std::endl\n                              << sylar::BacktraceToString();\n  } catch (...) {\n    cur->m_state = EXCEPT;\n    SYLAR_LOG_ERROR(g_logger) << \"Fiber Except\"\n                              << \" fiber_id=\" << cur->getId() << std::endl\n                              << sylar::BacktraceToString();\n  }\n\n  auto raw_ptr = cur.get();  // 手动让t_fiber的引用计数减1\n  cur.reset();\n  // 和MianFunc的区别\n  raw_ptr->back();  // 协程结束时自动swapOut，这里回到主线程(main)的主协程\n\n  SYLAR_ASSERT2(false, \"never reach fiber_id=\" + std::to_string(raw_ptr->getId()));\n}\n```\n\n**协程的重置，重置协程就是重复利用已结束的协程，复用其栈空间，创建新协程，实现如下：**\n\n``` cpp\n//重置协程函数，并重置状态\n// INIT，TERM, EXCEPT,都可以进行重置\nvoid Fiber::reset(std::function<void()> cb) {\n  SYLAR_ASSERT(m_stack);\n  SYLAR_ASSERT(m_state == TERM || m_state == EXCEPT || m_state == INIT);\n  m_cb = cb;\n  if (getcontext(&m_ctx)) {\n    SYLAR_ASSERT2(false, \"getcontext\");\n  }\n  m_ctx.uc_link = nullptr;\n  m_ctx.uc_stack.ss_sp = m_stack;\n  m_ctx.uc_stack.ss_size = m_stacksize;\n\n  makecontext(&m_ctx, &Fiber::MainFunc, 0);\n  m_state = INIT;\n}\n```\n\n**其他实现细节**\n\n关于协程id。sylar通过全局静态变量s_fiber_id的自增来生成协程id，每创建一个新协程，s_fiber_id自增1，并作为新协程的id（实际是先取值，再自增1）。\n\n关于线程主协程的构建。线程主协程代表线程入口函数或是main函数所在的协程，这两种函数都不是以协程的手段创建的，所以它们只有ucontext_t上下文，但没有入口函数，也没有分配栈空间。\n\n关于协程切换。子协程的resume操作一定是在主协程里执行的，主协程的resume操作一定是在子协程里执行的，这点完美和swapcontext匹配，参考上面协程原语的实现。\n\n关于智能指针的引用计数，由于t_fiber和t_thread_fiber一个是原始指针一个是智能指针，混用时要注意智能指针的引用计数问题，不恰当的混用可能导致协程对象已经运行结束，但未析构问题。关于协程对象的智能指针引用计数跟踪可参考test_fiber.cc。\n\n参考：\n<https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060957>\n","tags":["sylar"],"categories":["sylar"]},{"title":"backtrace","url":"/2023/10/14/sylar/c++/backtrace/","content":"# backtrace\n\n**头 文 件**\n\n```c++\n#include <execinfo.h>\n```\n\n```c++\n#include <execinfo.h>\n       int backtrace(void *buffer[.size], int size);\n       char **backtrace_symbols(void *const buffer[.size], int size);\n       void backtrace_symbols_fd(void *const buffer[.size], int size, int fd);\n```\n\n**函数描述**\n\nbacktrace()函数，获取函数调用堆栈帧数据，即回溯函数调用列表。数据将放在buffer中。参数size用来指定buffer中可以保存多少个void*元素（表示相应栈帧的地址，一个返回地址）。如果回溯的函数调用大于size，则size个函数调用地址被返回。为了取得全部的函数调用列表，应保证buffer和size足够大。\n\n`backtrace_symbols()`函数，参数buffer是从backtrace()函数获取的数组指针，size是该数组中的元素个数（backtrace()函数的返回值）。该函数主要功能：将从backtrace()函数获取的地址转为描述这些地址的字符串数组。每个地址的字符串信息包含对应函数的名字、在函数内的十六进制偏移地址、以及实际的返回地址（十六进制）。需注意的是，当前，只有使用elf二进制格式的程序才能获取函数名称和偏移地址，此外，为支持函数名功能，可能需要添加相应的编译链接选项如-rdynamic；否则，只有十六进制的返回地址能被获取。\n\n`backtrace_symbols()`函数返回值是一个字符串指针，是通过malloc函数申请的空间，使用完后，调用者必需把它释放掉。注：如果不能为字符串获取足够的空间，该函数的返回值为NULL。\n\n**返 回 值**\n\nbacktrace()函数返回通过buffer返回的地址个数，这个数目不会超过size。如果这个返回值小于size，那么所有的函数调用列表都被保存；如果等于size，那么函数调用列表可能被截断，此时，一些最开始的函数调用没有被返回。\n\n`backtrace_symbols()`函数成功时，返回一个由malloc分配的数组；失败时，返回NULL。\n\n**注意事项**\n\n这些函数对函数返回地址如何保存在栈内有一些假设，注意如下：\n\n- 忽略帧指针（由gcc任何非零优化级别处理了）可能引起这些假设的混乱。\n- 内联函数没有栈帧。\n- Tail-call（尾调用）优化会导致栈帧被其它调用覆盖。\n- 为支持函数名功能，可能需要添加相应的编译链接选项如-rdynamic；否则，只有十六进制的返回地址能被获取。\n- “static”函数名是不会导出的，也不会出现在函数调用列表里，即使指定了-rdynamic链接选项。\n\n**sylar**\n\n``` cpp\nnamespace sylar {\n\nvoid Backtrace(std::vector<std::string> &bt, int size = 64, int skip = 1);\nstd::string BacktraceToString(int size = 64, int skip = 2, const std::string &prefix = \"\");\n\n}  // namespace sylar\n```\n\n``` cpp\nvoid Backtrace(std::vector<std::string> &bt, int size, int skip) {\n  void **array = (void **)malloc((sizeof(void *) * size));\n  size_t s = ::backtrace(array, size);\n\n  char **strings = backtrace_symbols(array, s);\n  if (strings == NULL) {\n    SYLAR_LOG_ERROR(g_logger) << \"backtrace_symbols error\";\n    return;\n  }\n\n  for (size_t i = skip; i < s; ++i) {\n    bt.push_back(strings[i]);\n  }\n  free(strings);\n  free(array);\n}\nstd::string BacktraceToString(int size, int skip, const std::string &prefix) {\n  std::vector<std::string> bt;\n  Backtrace(bt, size, skip);\n  std::stringstream ss;\n  for (size_t i = 0; i < bt.size(); ++i) {\n    ss << prefix << bt[i] << std::endl;\n  }\n  return ss.str();\n}\n```\n\n``` cpp\n// test_util\n\n#include <cassert>\n#include \"sylar/log.h\"\n#include \"sylar/macro.h\"\n#include \"sylar/util.h\"\n\nsylar::Logger::ptr g_logger = SYLAR_LOG_ROOT();\n\n// todo\nvoid test_assert() {\n  SYLAR_LOG_INFO(g_logger) << sylar::BacktraceToString(10);\n  // SYLAR_ASSERT(false);\n  SYLAR_ASSERT2(0 == 1, \"abcdef xx\");\n}\n\nint main() {\n  test_assert();\n  return 0;\n}\n```\n\n> 记录学习sylar过程中，学到的知识。\n","tags":["sylar"],"categories":["c++"]},{"title":"static","url":"/2023/10/08/sylar/c++/static/","content":"\n\n## 声明静态成员\n\n静态成员的类型可以是常量、引用、指针、类类型等等。\n\n  ``` cpp\n  class Account {\n  public:\n    void Calculate() {amount += interes_trate_}\n    static double rate() { return interes_trate_; }\n    static void rate(double);\n\n  private:\n    std::string owner_;\n    double amount_;\n    static double interes_trate_;\n    static double initRate();\n  };\n  ```\n\n静态对象存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此每个Account对象将包含两个数据成员：owner和amount。\n只存在一个interestRate对象而且它被所有Account对象共享。\n\n静态成员函数也不与任何对象绑定在一起，他们不包含this指针，作为结果，**静态成员函数不能声明为const的**，而且我们也不能在static函数体内使用this指针。这一限制既适用于this显示调用，也对非静态成员的隐式使用有效。\n\n## 使用类的静态成员\n\n1. 使用作用域运算符直接访问静态成员\n\n    ``` cpp\n    double r;\n    r = Account::rate();\n    ```\n\n2. 使用类的对象、引用或者指针来访问静态成员\n\n    ``` cpp\n    Account ac1;\n    Account *ac2 = &ac1;\n\n    r = ac1.rate();\n    r = ac2->rate();\n    ```\n\n3. 成员函数不用通过作用域运算符就能直接访问静态成员：\n\n    ``` cpp\n    class Account {\n    public:\n      void Calculate() {amount += interes_trate_}\n      static double rate() { return interes_trate_; }\n      ...\n    };\n    ```\n\n## 定义静态成员\n\n和其他成员函数一样，我们既可以在类内部定义也可以在类外部定义静态成员函数。当在类的外部定义定义静态成员函数时，**不能重复static关键字，该关键字只能出现在类内部的声明语句。**\n\n一般来说不能在类的内部初始化静态函数成员。相反的必须在类的外部定义和初始化每个静态成员。和其他对象一样，每个静态成员只能定义一次。\n\n## 静态成员的类内初始化\n\n通常情况下类的静态成员不应该在类的内部初始化，然而我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。\n\n``` cpp\nclass Account {\n public:\n  void Calculate() {amount += interes_trate_}\n  static double rate() { return interes_trate_; }\n  static void rate(double);\n\n private:\n  static constexpr int period = 30; // period 是常量表达式\n  double daily_tbl[period];\n};\n// 一个不带初始值的静态成员定义\nconstexpr int Account::period; // 初始值在类的定义内提供\n```\n\n* 即使一个常量静态成员在类的内部被初始化了，通常情况下，也应该在类的外部定义一下该成员。\n\n## 静态成员能用于某些场景，而普通成员不能\n\n* 静态成员可以作为默认实参，非静态数据成员不能作为默认实参。\n\n* 静态数据成员可以是不完全类型，特别的静态数据成员的类型可以就是他所属的类类型，而非静态成员数据成员则受到限制，只能声明他所属类的指针或引用。\n\n```cpp\nclass Bar{\npublic:\n  //...\nprivate:\n  static Bar mem1;  // 正确，静态成员可以是不完全类型\n  Bar *mem2;        // 正确，指针成员可以是不完全类型\n  Bar mem3;         // 错误，数据成员必须是完全类型\n};\n```\n\n## 静态成员变量\n\n在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。\n\n**静态成员变量有以下特点：**\n\n1. **静态成员变量是该类的所有对象所共有的。**  对于普通成员变量，每个类对象都有自己的一份拷贝。而**静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问**。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；\n\n2. 因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；\n3. 静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。\n4. static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。\n5. sizeof 运算符不会计算 静态成员变量。\n\n**何时采用静态数据成员？**\n\n设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：\n\n1. 不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。\n2. 一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。\n\n你也许会问，用全局变量不是也可以达到这个效果吗？\n\n**同全局变量相比，使用静态数据成员有两个优势:**\n\n1. 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。\n2. 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。\n\n> 静态变量的一句话总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。\n\n## 静态成员函数\n\n与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。\n\n静态成员函数的特点：\n\n1. **出现在类体外的函数定义不能指定关键字static；**\n`error --->'static' can only be specified inside the class definition (fix available)clang(static_out_of_line)`\n2. 静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数；\n3. 静态成员函数不能访问非静态成员函数和非静态成员变量；\n4. 非静态成员函数可以任意地访问静态成员函数和静态数据成员；\n5. 由于没有this指针的额外开销，静态成员函数与类的成员函数相比速度上会稍快；\n6. 调用静态成员函数，两种方式：\n\n    * 通过成员访问操作符(.)和(->)，也即通过类对象或指向类对象的指针调用静态成员函数。\n    * 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。\n\n``` cpp\nclass Config {\n public:\n  using ConfigVarMap = std::unordered_map<std::string, ConfigVarBase::ptr>;\n  typedef RWMutex RWMutexType;\n  template <class T>\n  static typename ConfigVar<T>::ptr Lookup(const std::string &name, const T &default_value,\n                                           const std::string &description) {\n    RWMutexType::WriteLock lock(GetMutex());\n    auto it = GetDatas().find(name);\n    if (it != GetDatas().end()) {\n                                            // ...\n    }\n  }\n}\n```\n\n``` cpp\nsylar::ConfigVar<Person>::ptr g_person =\n    sylar::Config::Lookup(\"class.person\", Person(), \"system person\");\n```\n\n## 静态全局变量\n\n在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。\n\n**静态全局变量有以下特点：**\n\n1. 该变量在全局数据区分配内存；\n2. 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；\n3. 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 　\n静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间\n\n**定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：**\n\n1. 静态全局变量不能被其它文件所用；\n2. 其它文件中可以定义相同名字的变量，不会发生冲突；\n\n## 静态局部变量\n\n在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。\n\n通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。\n\n但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。\n\n静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。\n\n**静态局部变量有以下特点：**\n\n1. 静态局部变量在全局数据区分配内存；\n2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；\n3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；\n4. 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；\n\n## 静态函数\n\n在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，**它只能在声明它的文件当中可见，不能被其它文件使用。**\n\n**定义静态函数的好处：**\n\n1. 静态函数不能被其它文件所用；\n2. 其它文件中可以定义相同名字的函数，不会发生冲突；\n\n参考:\n\n<https://zhuanlan.zhihu.com/p/37439983>\n","tags":["sylar"],"categories":["c++"]},{"title":"semaphore","url":"/2023/10/07/sylar/pthread/semaphore/","content":"\n# semaphore\n\n## sem_init\n\n信号量的数据类型为结构`sem_t`，它本质上是一个长整型的数。函数`sem_init（）`用来初始化一个信号量。它的原型为：　　\n`extern int sem_init __P ((sem_t *__sem, int __pshared, unsigned int __value));`　　\n\n* sem为指向信号量结构的一个指针；\n* pshared不为０时此信号量在进程间共享，否则只能为当前进程的所有线程共享；\n* value给出了信号量的初始值。\n\n## sem_post\n\n函数`sem_post( sem_t *sem )`用来增加信号量的值。当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不在阻塞，选择机制同样是由线程的调度策略决定的。\n\n## sem_wait\n\n函数`sem_wait( sem_t *sem )`递减（锁定）sem 指向的信号量。如果信号量的值大于零，则继续递减，并且函数立即返回。如果信号量当前的值为零，则调用将阻塞，直到可以执行递减（即信号量值上升到零以上），或者信号处理程序中断调用。\n\n## sem_trywait\n\n`sem_trywait ( sem_t*sem )`与 sem_wait() 相同，只不过如果不能立即执行递减，则调用返回错误（errno 设置为 EAGAIN）而不是阻塞。\n\n## sem_timedwait\n\n`\nint sem_timedwait(sem_t *restrict sem,\n                         const struct timespec*restrict abs_timeout);`\n\n与sem_wait() 相同，不同之处在于，abs_timeout 指定了如果不能立即执行递减，则调用应阻塞的时间量限制。 abs_timeout 参数指向 timespec(3) 结构，该结构指定自纪元 1970-01-01 00:00:00 +0000 (UTC) 以来的绝对超时（以秒和纳秒为单位）。\n如果调用时超时已经过期，并且信号量无法立即锁定，则 sem_timedwait() 将失败并出现超时错误（errno 设置为 ETIMEDOUT）。\n如果操作可以立即执行，则无论abs_timeout 的值如何，sem_timedwait() 都不会因超时错误而失败。此外，在这种情况下，不检查abs_timeout的有效性。\n\n## sem_destroy\n\n`int sem_destroy(sem_t *sem);`\n\n销毁 sem 指向的地址处的未命名信号量。\n\n仅应使用 sem_destroy() 销毁已由 sem_init(3) 初始化的信号量。\n\n销毁其他进程或线程当前被阻塞的信号量（在 sem_wait(3) 中）会产生未定义的行为。\n\n使用已被破坏的信号量会产生未定义的结果，直到使用 sem_init(3) 重新初始化该信号量。\n\n-------\n\n``` cpp\n// thread.h\nclass Semaphore {\n public:\n  Semaphore(uint32_t count = 0);\n  ~Semaphore();\n\n  void wait();\n  void notify();\n\n private:\n  Semaphore(const Semaphore &) = delete;\n  Semaphore(const Semaphore &&) = delete;\n  Semaphore &operator=(const Semaphore &) = delete;\n\n private:\n  sem_t m_semaphore;\n};\n```\n\n``` cpp\n// thread.cc\nSemaphore::Semaphore(uint32_t count) {\n  if (sem_init(&m_semaphore, 0, count)) {\n    throw std::logic_error(\"sem_init error\");\n  }\n}\n\nSemaphore::~Semaphore() { sem_destroy(&m_semaphore); }\nvoid Semaphore::wait() {\n  if (sem_wait(&m_semaphore)) {\n    throw std::logic_error(\"sem_wait error\");\n  }\n}\n\nvoid Semaphore::notify() {\n  if (sem_post(&m_semaphore)) {\n    throw std::logic_error(\"sem_post error\");\n  }\n}\n```\n\n> 记录学习sylar过程中，学到的知识。\n","tags":["sylar"],"categories":["c++"]},{"title":"error: no match for ‘operator==’ (operand types are ‘const Person’ and ‘const Person’)","url":"/2023/10/02/error/error-no-match-for-‘operator-’-operand-types-are-‘const-Person’-and-‘const-Person’/","content":"\n\n## 错误报告\n\n``` cpp\n/usr/include/c++/11/bits/stl_pair.h:467:51: error: no match for ‘operator==’ (operand types are ‘const Person’ and ‘const Person’)\n  467 |     { return __x.first == __y.first && __x.second == __y.second; }\n      |                                        ~~~~~~~~~~~^~~~~~~~~~~~~\n/home/lyt/my_sylar/tests/test_config.cc:129:8: note: candidate: ‘bool Person::operator==(const Person&)’ (near match)\n  129 |   bool operator==(const Person &oth) {\n      |        ^~~~~~~~\n/home/lyt/my_sylar/tests/test_config.cc:129:8: note:   passing ‘const Person*’ as ‘this’ argument discards qualifiers\n```\n\n这个错误表明在某个地方尝试比较两个 const Person 对象，但是编译器找不到适当的 operator== 实现。错误信息还提到了一个备选项，它是你自己为 Person 类实现的 operator== 函数，但它可能没有被正确地声明为 const 函数。\n\n为了解决这个问题，你需要确保你的 Person 类中的 operator== 函数被声明为 const 成员函数，因为你正在比较两个 const Person 对象。\n\n## 错误代码\n\n``` cpp\nclass Person {\n public:\n  Person(){};\n  std::string m_name;\n  int m_age = 0;\n  bool m_sex = 0;\n\n  std::string toString() const {\n    std::stringstream ss;\n    ss << \"[person name= \" << m_name << \" age= \" << m_age << \" sex= \" << m_sex << \"]\";\n    return ss.str();\n  }\n  bool operator==(const Person &oth) {\n    return m_name == oth.m_name && m_sex == oth.m_sex && m_age == oth.m_age;\n  }\n};\n\n```\n\n## 修改后的代码\n\n``` cpp\nclass Person {\n public:\n  Person(){};\n  std::string m_name;\n  int m_age = 0;\n  bool m_sex = 0;\n\n  std::string toString() const {\n    std::stringstream ss;\n    ss << \"[person name= \" << m_name << \" age= \" << m_age << \" sex= \" << m_sex << \"]\";\n    return ss.str();\n  }\n  bool operator==(const Person &oth) const {\n    return m_name == oth.m_name && m_sex == oth.m_sex && m_age == oth.m_age;\n  }\n};\n\n```\n","tags":["error"]},{"title":"error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’","url":"/2023/09/29/error/error-cannot-bind-non-const-lvalue-reference-of-type-‘std-vector-int-’-to-an-rvalue-of-type-‘std-vector-int-’/","content":"\n意思是无法将一个非 const 左值引用类型的 int& 绑定到一个右值类型的 int 上。\n\n* 在 C++ 中，左值是指可以取地址的、有标识符的表达式，如变量、数组、函数等；而右值是指不能取地址的、没有标识符的表达式，如字面量（如 1、\"hello\"）和表达式（如 a + b）。在一个函数中，如果参数是左值引用类型，那么这个函数可以修改传入的参数，因为它可以通过引用访问参数的地址。如果参数是右值引用类型，那么这个函数不能修改传入的参数，因为它只能访问到参数的值，而不能访问到它的地址。\n\n* 现在回到这个错误信息。它的意思是，在某个地方有一个函数或者语句试图将一个右值类型的 int 绑定到一个非 const 左值引用类型的 int& 上，这是不允许的。这是因为右值是临时的、不可修改的，不能被引用进行修改操作。\n\n> 要解决这个问题，一种方法是将左值引用类型改为 const 左值引用类型，这样就可以接受右值参数了。另一种方法是将参数改为值传递方式，也就是将参数拷贝一份传递给函数，这样就不存在左值引用和右值引用的问题了。\n\n``` cpp\nvoid setValue( T &val) { m_val = val; }\n// 改为\nvoid setValue(const T &val) { m_val = val; }\n// 或者\nvoid setValue( T val) { m_val = val; }\n```\n","tags":["error"]},{"title":"sstream","url":"/2023/09/27/sylar/c++/sstream/","content":"# stringstream\n\n**stringstream**是一个C++底下的类别，专门拿来读取字串并且处理，很多时候拿来做字串的切割，或者是int跟string类别之间的转换。把**int**型态的数字转成**string**此时的**stringstream**就像个桥梁，可以负责当中间转换的部分。\n\n**stringstream** 提供了 >> 与 << 运算子来读取或写入:\n << 代表写入 **stringstream** 中，>> 代表从 **stringstream** 拿出。\n\n``` cpp\n\n// swapping ostringstream objects\n#include <iostream>  // std::cout\n#include <ostream>\n#include <sstream>  // std::stringstream\n#include <string>   // std::string\n\nint main() {\n  std::stringstream ss;\n  // 将 100 和200 输入到ss中\n  ss << 100 << ' ' << 200;\n  ss << \"example string\";\n  int foo, bar;\n  std::string s;\n  ss >> foo >> bar >> s;\n\n  std::cout << \"foo: \" << foo << '\\n';\n  std::cout << \"bar: \" << bar << '\\n';\n  std::cout << \"s: \" << s << '\\n';\n\n  // ss.str(\"example string\");\n\n  std::string s1 = ss.str();\n  std::cout << \"s1: \" << s1 << '\\n';\n  return 0;\n}\n```\n\nfoo: 100\n\nbar: 200\n\ns: example\n\ns1: 100 200example string\n\n> 记录学习sylar过程中，学到的知识。\n","tags":["sylar"],"categories":["c++"]},{"title":"schedule","url":"/2023/09/24/schedule/schedule/","content":"\n# 总体计划\n\n\n* todo\n\n 1. redis\n 2. mysql\n 3. leveldb\n 4. 程序员的自我修养\n 5. sylar\n","tags":["plan"]},{"title":"智能指针","url":"/2023/08/20/cpp/智能指针/","content":"\n\n**shared_ptr和unique_ptr都支持的操作**\n\n```c++\nshared_ptr<T> sp; //空智能指针，可以指向类型为T的对象\nunique_ptr<T> tp;\n\nif(sp);    //将p用作一个条件判断，若p指向一个对象，则为true\n*sp;    //解引用sp，获得他所指向的对象。\np->mem;    //等价于 (*p).mem\np.get();   //返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失\n\nswap(p,q);   //交换p和q的指针\np.swap(q)\n```\n\n# shared_ptr\n\n1. 初始化\n\n``` cpp\n// 智能指针初始化\nstd::shared_ptr<int> p(new int(1));\nstd::shared_ptr<int> ptr = p;\n// 优先使用 make_shared 来构造智能指针\nstd::shared_ptr <int> p = std::make_shared<int>(2);\n\n//不允许将一个原始指针直接赋予一个智能指针，例如\nstd::shared_ptr<int> p = new int(2); //错误\n```\n\n``` cpp\n// shared_ptr独有操作\nmake_shared<t>(args); //返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化对象。\n\nshared_ptr<T>p(q);  //p是shared_ptr q 的拷贝； 此操作会递增q中的计数器。 q中的指针必须能转换为T*\n\np=q;     //p和q都是shared_ptr， 所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放\n\np.unique();    //若p.use_count() 为1， 返回true； 否则返回false;\n\np.use_count();   //返回与p共享对象的智能指针数量；可能很慢，主要用于测试\n```\n\n2. 获取原始指针\n\n``` cpp\n// 用get方法获取原始指针\nstd::shared_ptr<int> ptr = std::make_shared<int>(1);\nint *p = ptr.get();\n```\n\n3. 指定删除器\n\n``` cpp\nvoid DeleteIntPtr(int *p){\ndelete p;\n}\nstd::shared_ptr<int> p(new int, DeleteIntPtr);\nstd::shared_ptr<int> p(new int, [](int *p){delete p;});\n```\n\n当我们用shared_ptr管理数组时，需要指定删除器，因为shared_ptr默认删除器不支持数组对象。\n`std::shared_ptr<int> p(new int[10], [](int* p){delete[] p;})`\n\n也可以将std::default_delete作为删除器，default_delete的内部是通过调用delete来实现功能的。\n`std::shared_ptr<int> p(new int[10], std::default_delete<int[]>)`\n还可以通过封装一个make_shared_array方法来让shared_ptr支持数组。\n\n``` cpp\ntemplate<typename T>\nshared_ptr<T> make_shared_array(size_t size){\n return shared_ptr<T>(new T[size],default_delete<T[]>)\n}\n```\n\n## 使用shared_ptr需要注意的问题\n\n1. 不要用一个原始指针初始化多个shared_ptr，例如下面的就是错误的：这里p1和p2是没有关联的，他们并不知道对方的存在，因此p1和p2会争相去释放ptr指针，导致重复释放。\n\n``` cpp\n int *ptr = new int;\n shared_ptr<int> p1(ptr);\n shared_ptr<int> p2(ptr); // logic error\n```\n\n2. 不要再函数实参中创建shared_ptr，对于下面的用法：\n `function(shared_ptr<int>(new int), g()); // 有缺陷`\n 因为c++的函数参数的计算顺序在不同的编译器不同的调用约定下有可能不一样，一般从左到右，但也有可能从右到左，所以可能先new int 然后调用 g()，如果g()恰好发生异常，而shared_ptr没有创建，则int内存泄漏。正确写法应该是先创建智能指针。\n `shared_ptr<int> p(new int());f(p,g())\n `\n3. 通过shared_from_this返回this指针，不要将this作为shared_ptr返回出来，因为this指针本质上是裸指针，因此这样可能会导致重复析构。c++11 中的 shared_from_this() 来源于 boost 中的 enable_shared_form_this 类和 shared_from_this() 函数，功能为返回一个当前类的 std::share_ptr。\n\n``` cpp\nstruct A {\n  std::shared_ptr<A> Getself() {\n    // free(): double free detected in tcache 2\n    return std::shared_ptr<A>(this); //  do't do this\n  }\n};\n\nint main() {\n  std::shared_ptr<A> sp1(new A);\n  std::cout<< sp1.use_count() <<std::endl; // 1\n  std::shared_ptr<A> sp2 = sp1->Getself();\n  std::cout<< sp2.use_count() <<std::endl; // 1 \n  return 0;\n}\n```\n\n这个例子中，由于用同一个指针构造了两个智能指针sp1和sp2，而它们之间没有任何关系，在离开作用域后this将被构造的两个智能指针各自析构，导致重复析构。\n正确做法，具体解释为什么，见下文weakptr\n\n``` cpp\nstruct A {\n  std::shared_ptr<A> Getself() {\n    // free(): double free detected in tcache 2\n    return std::shared_ptr<A>(this); //  do't do this\n  }\n};\n\nclass B : public std::enable_shared_from_this<B> {\npublic:\n  std::shared_ptr<B> Getself() {\n    //\n    return shared_from_this();\n  }\n};\n\nint main() {\n  //   std::shared_ptr<A> sp1(new A);\n  //   std::shared_ptr<A> sp2 = sp1->Getself();\n  std::shared_ptr<B> sp3(new B());\n  std::cout<< sp3.use_count() <<std::endl; // 1\n  std::shared_ptr<B> p = sp3->Getself();\n  std::cout<< p.use_count() <<std::endl; // 2\n  return 0;\n}\n```\n\n4. 要避免循环引用\n\n``` cpp\n\nstruct A;\nstruct B;\n\nstruct A {\n  std::shared_ptr<B> b_ptr;\n  ~A() { std::cout << \"A is delete\" << std::endl; }\n};\nstruct B {\n  std::shared_ptr<A> a_ptr;\n  ~B() { std::cout << \"B is delete\" << std::endl; }\n};\nint main() {\n  std::shared_ptr<A> ap(new A);\n  std::shared_ptr<B> bp(new B);\n  ap->b_ptr = bp;\n  bp->a_ptr = ap;\n  return 0;\n}\n```\n\n测试结果是两个指针 A B都不会删除，存在内存泄漏。循环引用导致ap和bp的引用计数为2,在离开作用域后，ap和bp的引用计数减为1,并不会为0,导致两个指针都不会被析构，产生内存泄漏。解决方法，将任意一个成员变量改为weak_ptr。\n\n---\n\n# unique_ptr 独占的智能指针\n\nunique_ptr 是一个独占型的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将unique_ptr赋值给另外一个unique_ptr。下面这样是错误的:\n\n``` cpp\nunique_ptr<T> my_ptr(new T);\nunique_ptr<T> my_other_ptr = my_ptr; // 错误，不能复制\n```\n\nunique_ptr不允许复制，但可以通过函数返回给其他的unique_ptr，还可以通过std::move来转移到其他的unique_ptr，这样它本身就不再拥有原来指针的所有权了。例如:\n\n``` cpp\nunique_ptr<T> my_ptr(new T);\nunique_ptr<T> my_other_ptr = std::move(my_ptr);\nunique_ptr<T> ptr = my_ptr; // 错误，只能移动，不可复制。\n```\n\n## 创建智能指针\n\n通过make_unique(c++14)方法创建unique_ptr\n\n```c++\n//释放u指的对象\nu.reset();\n//u放弃对指针的控制权，返回指针，并将u置为空。\nu.release();\n```\n\nmake_unique方法实现\n\n``` cpp\nnamespace detail {\ntemplate<class>\nconstexpr bool is_unbounded_array_v = false;\ntemplate<class T>\nconstexpr bool is_unbounded_array_v<T[]> = true;\n \ntemplate<class>\nconstexpr bool is_bounded_array_v = false;\ntemplate<class T, std::size_t N>\nconstexpr bool is_bounded_array_v<T[N]> = true;\n} // namespace detail\n \ntemplate<class T, class... Args>\nstd::enable_if_t<!std::is_array<T>::value, std::unique_ptr<T>>\nmake_unique(Args&&... args)\n{\n    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n}\n \ntemplate<class T>\nstd::enable_if_t<detail::is_unbounded_array_v<T>, std::unique_ptr<T>>\nmake_unique(std::size_t n)\n{\n    return std::unique_ptr<T>(new std::remove_extent_t<T>[n]());\n}\n \ntemplate<class T, class... Args>\nstd::enable_if_t<detail::is_bounded_array_v<T>> make_unique(Args&&...) = delete;\n```\n\n如何不是数组则直接创建unique_ptr，如果是数组，先判断是否是为定长数组，若为定长数组则编译不通过(因为不能这样调用make_unique<T[10]>(10), 而应该这样make_unique<T[]>(10));若为非定长数组，则获取元素类型再根据传入参数size_t创建动态数组的unique_ptr。\n\n``` cpp\n\n#include <iostream>\n#include <memory>\n \nstruct Vec3\n{\n    int x, y, z;\n    // C++20 起不再需要以下构造函数\n    Vec3(int x = 0, int y = 0, int z = 0) noexcept : x(x), y(y), z(z) { }\n    friend std::ostream& operator<<(std::ostream& os, const Vec3& v)\n    {\n        return os << '{' << \"x:\" << v.x << \" y:\" << v.y << \" z:\" << v.z  << '}';\n    }\n};\n \nint main()\n{\n    // 使用默认构造函数。\n    std::unique_ptr<Vec3> v1 = std::make_unique<Vec3>();\n    // 使用匹配这些参数的构造函数\n    std::unique_ptr<Vec3> v2 = std::make_unique<Vec3>(0, 1, 2);\n    // 创建指向 5 个元素数组的 unique_ptr \n    std::unique_ptr<Vec3[]> v3 = std::make_unique<Vec3[]>(5);\n \n    std::cout << \"make_unique<Vec3>():      \" << *v1 << '\\n'\n              << \"make_unique<Vec3>(0,1,2): \" << *v2 << '\\n'\n              << \"make_unique<Vec3[]>(5):   \" << '\\n';\n    for (int i = 0; i < 5; i++) {\n        std::cout << \"     \" << v3[i] << '\\n';\n    }\n}\n```\n\n输出：\n  make_unique<Vec3>():      {x:0 y:0 z:0}\n  make_unique<Vec3>(0,1,2): {x:0 y:1 z:2}\n  make_unique<Vec3[]>(5):\n      {x:0 y:0 z:0}\n      {x:0 y:0 z:0}\n      {x:0 y:0 z:0}\n      {x:0 y:0 z:0}\n      {x:0 y:0 z:0}\n\nunique_ptr和shared_ptr相比，unique_ptr除了独占性，还可以指向一个数组，\n`std::unique_ptr<Vec3[]> v3 = std::make_unique<Vec3[]>(5);`\n\nunique_ptr指定删除器和std::shared_ptr是有差别的,比如下面写法:\n\n``` cpp\nstd::shared_ptr<int> ptr(new int(1), [](int *p){delete p;}); // 正确\nstd::unique_ptr<int> ptr(new int(1), [](int *p){delete p;}); // 错误\n// unique_ptr指定删除器的时候，需要确定删除器的类型\nstd::unqiue_ptr<int,  void(*)(int *)> ptr(new int(1), [](int *p){delete p;}); \n```\n\n上面这种写法在lambda没有捕获变量的情况下是正确的，如果捕获了变量，则会编译报错，如下:\n`std::unique_ptr<int， void(*)(int *)> ptr(new int(1), [&](int *p){delete p;});`\n\n希望unique支持lambda可以这样写:\n`std::unqiue_ptr<int， std::function<void(int *)>> ptr(new int(1), [&](int *p){delete p;});`\n\n## 自定义unique_ptr删除器\n\n``` cpp\n#include<iostream>\n#include<memory>\n\n\nclass MyDeleter{\npublic:\n    void operator()(int *p){\n        std::cout<< \"delete\"<<std::endl;\n        delete p;\n    }\n};\n\nint main(){\n    std::unique_ptr<int, MyDeleter> p(new int(1));\n    return 0;\n}\n```\n\n# weak_ptr 弱引用的智能指针\n\n弱引用指针weak_ptr是用来监视shared_ptr的，不会使引用计数加1，他不管理shared_ptr内部的指针，主要是为了监视shared_ptr的生命周期。没有重载操作符*和->，因为他不共享指针。构造和析构都不会增加或减少引用计数。weak_ptr可以用来返回this指针和解决循环引用问题。\n\n## weak_ptr基本用法\n\n1. 通过use_count()方法获得当前观测资源的引用计数，代码如下\n\n``` cpp\n    std::shared_ptr<int> sp(new int(10));\n    std::weak_ptr<int> wp(sp);\n    std::cout<<wp.use_count()<<std::endl;   // 结果输出1\n```\n\n2. 通过expired()方法来判断所观测的资源是否已经释放，代码如下:\n\n``` cpp\n    std::shared_ptr<int> sp(new int(10));\n    std::weak_ptr<int> wp(sp);\n    if(wp.expired()){\n        std::cout<< \"wark_ptr无效，所监视的指针已经释放\"<<std::endl;\n    }\n    else{\n        std::cout<< \"wark_ptr有效\"<<std::endl; \n    }\n\n    // 输出:  wark_ptr无效\n```\n\n3. 通过lock方法来获取所监视的shared_ptr，会增加一个引用计数代码如下:\n\n``` cpp\n\nstd::weak_ptr<int> gw;\nvoid f(){\n    if(gw.expired()){\n        std::cout<<\"gw is expired\"<<std::endl;\n    }\n    else{\n        auto spt = gw.lock();\n        std::cout<<*spt<<std::endl;\n         std::cout<<gw.use_count()<<std::endl; // 此时为 2\n    }\n}\n\n   {\n        auto  sp=std::make_shared<int>(42);\n        gw = sp;\n        f();\n    }\n    f();\n```\n\n输出:\n\n42\ngw is expired\n\n## weak_ptr返回this指针\n\n前面提到的不能直接将this指针返回为shared_ptr，需要通过派生std::enable_shared_from_this类，并通过方法shared_from_this来返回智能指针，\n原因是std::enable_shared_from_this类中有一个weak_ptr，这个weak_ptr用来观测智能指针，调用shared_from_this()方法时，**会调用这个weak_ptr的lock方法**，将所观测的shared_ptr返回。\n是安全的是因为shared_from_this()是内部调用weak_ptr的lock方法之后返回的智能指针，引用计数会加1。这样就不会重复析构。\n\n## weak_ptr 解决循环引用问题\n\n``` cpp\nstruct A;\nstruct B;\n\nstruct A {\n  std::shared_ptr<B> b_ptr;\n  ~A() { std::cout << \"A is delete\" << std::endl; }\n};\nstruct B {\n  std::weak_ptr<A> a_ptr;\n  ~B() { std::cout << \"B is delete\" << std::endl; }\n};\nint main() {\n  std::shared_ptr<A> ap(new A);\n  std::shared_ptr<B> bp(new B);\n  ap->b_ptr = bp;\n  bp->a_ptr = ap;\n  return 0;\n}\n```\n\n这样在对B的成员赋值时，即执行bp->aptr = ap;时，由于aptr是weak_ptr，他并不会增加引用计数，所以ap的引用计数仍然是1。在离开作用域后，ap的引用计数会减为0, A的指针会被析构，析构后其内部的bptr的引用计数会减为1，然后在离开作用域后bp引用计数又从1减为0，B对象也将析构，不会发生内存泄漏。\n\n# 通过智能指针管理第三方库分配的内存\n\n# 总结\n\n* shared_ptr和unique_ptr使用时如何选择:如果希望只有一个智能指针管理资源或者管理数组，可以用unique_ptr;如果希望多个智能指针管理同一资源，可以用shared_ptr。\n* weak_ptr是shared_ptr的助手，只是监视shared_ptr管理的资源是否被释放，本身并不操作或者管理资源。用于解决shared_ptr循环引用和返回this指针的问题。\n","tags":["c++11"],"categories":["c++"]},{"title":"muduo","url":"/2023/08/19/muduo/muduo/","content":"\n1. 整个建立连接的流程\n2. 如何保证一个线程只有一个EventLoop对象\n\n   ![image-20230811105311147](../../images/image-20230811105311147.png)\n3. __thread变量是每个线程有一份独立实体，各个线程的变量值互不干扰。除了这个主要的用途，他还可以修饰那些\"值可能会变，带有全局性，但是又不值得用全局锁保护\"的变量。\n      - muduo/net/EventLoop.cc 用于判断当前线程是否只有一个EventLoop对象\n      - muduo/base/Thread.cc 缓存每个线程的id\n\n4. 主EventLoop如何将新建立连接的fd交给子EventLoop\n\n5. runInLoop时如何将function交给对应的子EventLoop\n\n6. 连接断开的处理\n\nepoll + threadPool\n\n![image-20230811110816183](../../images/image-20230811110816183.png)\n\nmain Reactor + sub Reactor\n\n![image-20230811111003090](../../images/image-20230811111003090.png)\n\nmain Reactor + sub Reactor + theadPool\n![image-20230811110513867](../../images/image-20230811110513867.png)\n\n## 连接建立的流程\n\n1. 网络库是怎样bind、listen和accept的\n2. epoll模型被封装成啥样了，是怎样调度读写事件的\n3. accept描述符是怎样被注册到epoll模型中的\n\n``` cpp\nclass EchoServer\n{\npublic:\n    EchoServer(EventLoop *loop, const InetAddress &addr, const std::string &name)\n        : server_(loop, addr, name)\n        , loop_(loop)\n    {\n        // 注册回调函数\n        server_.setConnectionCallback(\n            std::bind(&EchoServer::onConnection, this, std::placeholders::_1));\n        \n        server_.setMessageCallback(\n            std::bind(&EchoServer::onMessage, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n        server_.setWriteCompleteCallback(std::bind())\n        // 设置合适的subloop线程数量\n        server_.setThreadNum(3);\n    }\n    void start()\n    {\n        server_.start();\n    }\n\nprivate:\n    // 连接建立或断开的回调函数\n    void onConnection(const TcpConnectionPtr &conn)   \n    {\n        if (conn->connected())\n        {\n            LOG_INFO(\"Connection UP : %s\", conn->peerAddress().toIpPort().c_str());\n        }\n        else\n        {\n            LOG_INFO(\"Connection DOWN : %s\", conn->peerAddress().toIpPort().c_str());\n        }\n    }\n\n    // 可读写事件回调\n    void onMessage(const TcpConnectionPtr &conn, Buffer *buf, Timestamp time)\n    {\n        std::string msg = buf->retrieveAllAsString();\n        conn->send(msg);\n        // conn->shutdown();   // 关闭写端 底层响应EPOLLHUP => 执行closeCallback_\n    }\n\n    EventLoop *loop_;\n    TcpServer server_;\n};\n\nint main() {\n    EventLoop loop;\n    InetAddress addr(8002);\n    EchoServer server(&loop, addr, \"EchoServer\");\n    server.start();\n    loop.loop();\n    return 0;\n}\n```\n\n## mainLoop\n\n``` cpp\nEventLoop::EventLoop()\n  : looping_(false),\n    quit_(false),\n    eventHandling_(false),\n    callingPendingFunctors_(false),\n    iteration_(0),\n    // 记录当前EventLoop是被哪个线程id创建的 即标识了当前EventLoop的所属线程id\n    threadId_(CurrentThread::tid()),\n    poller_(Poller::newDefaultPoller(this)),\n    timerQueue_(new TimerQueue(this)),\n    // 唤醒subLoop的关键点\n    wakeupFd_(createEventfd()),\n    wakeupChannel_(new Channel(this, wakeupFd_)),\n    currentActiveChannel_(NULL)\n{\n  LOG_DEBUG << \"EventLoop created \" << this << \" in thread \" << threadId_;\n  if (t_loopInThisThread)\n  {\n    LOG_FATAL << \"Another EventLoop \" << t_loopInThisThread\n              << \" exists in this thread \" << threadId_;\n  }\n  else\n  {\n    t_loopInThisThread = this;\n  }\n  wakeupChannel_->setReadCallback(\n      std::bind(&EventLoop::handleRead, this));\n  // we are always reading the wakeupfd\n  wakeupChannel_->enableReading();\n}\n```\n\n- threadId_ : 记录当前EventLoop是被哪个线程id创建的 即标识了当前EventLoop的所属线程id ，用来确保conn在对应的subLoop上执行\n\n- wakeupFd_ : 作用：当mainLoop获取一个新用户的Channel 需通过轮询算法选择一个subLoop 通过该成员唤醒subLoop处理Channel\n- activeChannels_ : 返回Poller检测到当前有事件发生的所有Channel列表\n- t_loopInThisThread : 构建EventLoop时，确保一个线程一个EventLoop。\n\n## bind listen accept\n\n``` cpp\nTcpServer::TcpServer(EventLoop *loop, const InetAddress &listenAddr,\n                     const string &nameArg, Option option)\n    : loop_(CHECK_NOTNULL(loop)), ipPort_(listenAddr.toIpPort()),\n      name_(nameArg),\n      acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),\n      threadPool_(new EventLoopThreadPool(loop, name_)),\n      connectionCallback_(defaultConnectionCallback),\n      messageCallback_(defaultMessageCallback), nextConnId_(1) {\n  acceptor_->setNewConnectionCallback(\n      std::bind(&TcpServer::newConnection, this, _1, _2));\n}\n\n// bind\nAcceptor::Acceptor(EventLoop* loop, const InetAddress& listenAddr, bool reuseport)\n  : loop_(loop),\n    acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),\n    acceptChannel_(loop, acceptSocket_.fd()),\n    listening_(false),\n    idleFd_(::open(\"/dev/null\", O_RDONLY | O_CLOEXEC))\n{\n  assert(idleFd_ >= 0);\n  acceptSocket_.setReuseAddr(true);\n  acceptSocket_.setReusePort(reuseport);\n  acceptSocket_.bindAddress(listenAddr);\n  acceptChannel_.setReadCallback(\n      std::bind(&Acceptor::handleRead, this));\n}\n\n// listen\nvoid Acceptor::listen()\n{\n  loop_->assertInLoopThread();\n  listening_ = true;\n  acceptSocket_.listen();\n  // read\n  acceptChannel_.enableReading();\n}\n\nvoid Acceptor::handleRead()\n{\n  loop_->assertInLoopThread();\n  InetAddress peerAddr;\n  //FIXME loop until no more\n  // 真正的accept\n  int connfd = acceptSocket_.accept(&peerAddr);\n  if (connfd >= 0)\n  {\n    // string hostport = peerAddr.toIpPort();\n    // LOG_TRACE << \"Accepts of \" << hostport;\n    if (newConnectionCallback_)\n    {\n      newConnectionCallback_(connfd, peerAddr);\n    }\n    else\n    {\n      sockets::close(connfd);\n    }\n  }\n}\n\n```\n\n1. 这里在new Acceptor时 进行的bind,linsten还未开始,listen是在TcpServer::start()的时候开始的.\n2. 还会创建EventLoopThreadPool, subLoop的个数是 server_.setThreadNum(3)设置的。创建subLoop是在TcpServer::start()的时候开始的。\n3. setConnectionCallback,setMessageCallback 由用户设置,用户定义 --- 对应onConnection , onMessage\n4. acceptor_的NewConnectionCallback 绑定到 TcpServer::newConnection。\n   当新来连接时,会先执行Acceptor::handleRead()，进行accept, 调用TcpServer::newConnection(也可能是close)\n\n## 开启事件循环\n\n``` cpp\n\nvoid EventLoop::loop()\n{\n  assert(!looping_);\n  assertInLoopThread();\n  looping_ = true;\n  quit_ = false;  // FIXME: what if someone calls quit() before loop() ?\n  LOG_TRACE << \"EventLoop \" << this << \" start looping\";\n\n  while (!quit_)\n  {\n    activeChannels_.clear();\n    // Poller监听哪些channel发生了事件 然后上报给EventLoop 通知channel处理相应的事件\n    pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_);\n    ++iteration_;\n    if (Logger::logLevel() <= Logger::TRACE)\n    {\n      printActiveChannels();\n    }\n    // TODO sort channel by priority\n    eventHandling_ = true;\n    for (Channel* channel : activeChannels_)\n    {\n      currentActiveChannel_ = channel;\n      currentActiveChannel_->handleEvent(pollReturnTime_);\n    }\n    currentActiveChannel_ = NULL;\n    eventHandling_ = false;\n    // 注意这里 \n    doPendingFunctors();\n  }\n\n  LOG_TRACE << \"EventLoop \" << this << \" stop looping\";\n  looping_ = false;\n}\n```\n\n## epoll_wait\n\n``` cpp\nTimestamp EPollPoller::poll(int timeoutMs, ChannelList* activeChannels)\n{\n  LOG_TRACE << \"fd total count \" << channels_.size();\n  int numEvents = ::epoll_wait(epollfd_,\n                               &*events_.begin(),\n                               static_cast<int>(events_.size()),\n                               timeoutMs);\n  int savedErrno = errno;\n  Timestamp now(Timestamp::now());\n  if (numEvents > 0)\n  {\n    LOG_TRACE << numEvents << \" events happened\";\n\n    // 将活跃的连接放进activeChannels ---std::vector<Channel*>\n    fillActiveChannels(numEvents, activeChannels);\n    if (implicit_cast<size_t>(numEvents) == events_.size())\n    {\n      events_.resize(events_.size()*2);\n    }\n  }\n  else if (numEvents == 0)\n  {\n    LOG_TRACE << \"nothing happened\";\n  }\n  else\n  {\n    // error happens, log uncommon ones\n    if (savedErrno != EINTR)\n    {\n      errno = savedErrno;\n      LOG_SYSERR << \"EPollPoller::poll()\";\n    }\n  }\n  return now;\n}\n```\n\n前面 bind listen accept epoll_wait 都已经进行。\n\n## 将TcpConnection分发到subLoop上\n\n- TcpServer::start() => Acceptor.listen() 如果有新用户连接 要执行一个回调(accept => connfd =>TcpServer::newConnection ==> 创建TcpConnection对象conn，把他加入ConnectionMap,打包Channel => 唤醒subloop)\n\n- 每一个TcpConnection 对应一个 connfd 和 channel，并把TcpConnection中的read、write、close、error绑定到channel中，当此fd需要read、write、close、error时，会直接调用TcpConnection中的handleRead、handleWrite、handleClose、handleError。\n\n- TcpServer会将对应的connectionCallback_、messageCallback_、writeCompleteCallback_注册到TcpConnection上。TcpConnection在执行handleRead... 这些函数时，回调用这些Callback 。\n\n``` cpp\nvoid TcpServer::newConnection(int sockfd, const InetAddress &peerAddr) {\n  loop_->assertInLoopThread();\n  EventLoop *ioLoop = threadPool_->getNextLoop();\n  char buf[64];\n  snprintf(buf, sizeof buf, \"-%s#%d\", ipPort_.c_str(), nextConnId_);\n  ++nextConnId_;\n  string connName = name_ + buf; // 以上代码是为了生成每个连接的唯一健值\n\n  LOG_INFO << \"TcpServer::newConner::start() => Acceptor.listen() 如果有新用户连接 要执行一个回调(accept => connfd =>TcpServer::newConnection ==> 创建TcpConnection对象conn，把他加入ConnectionMap,打包Channel => 唤醒subloop)\" << peerAddr.toIpPort();\n  InetAddress localAddr(sockets::getLocalAddr(sockfd));\n  // FIXME poll with zero timeout to double confirm the new connection\n  // FIXME use make_shared if necessary\n  TcpConnectionPtr conn(\n      new TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr));\n  //   typedef std::map<string, TcpConnectionPtr> ConnectionMap;\n  connections_[connName] = conn;\n  conn->setConnectionCallback(connectionCallback_);\n  conn->setMessageCallback(messageCallback_);\n  conn->setWriteCompleteCallback(writeCompleteCallback_);\n  conn->setCloseCallback(\n      std::bind(&TcpServer::removeConnection, this, _1)); // FIXME: unsafe\n  //******* 实现了TcpConnection::connectEstablished()函数必须要在对应的Sub EventLoop线程中运行\n  ioLoop->runInLoop(std::bind(&TcpConnection::connectEstablished, conn));\n}\n\nTcpConnection::TcpConnection(EventLoop* loop,\n                             const string& nameArg,\n                             int sockfd,\n                             const InetAddress& localAddr,\n                             const InetAddress& peerAddr)\n  : loop_(CHECK_NOTNULL(loop)),\n    name_(nameArg),\n    state_(kConnecting),\n    reading_(true),\n    socket_(new Socket(sockfd)),\n    channel_(new Channel(loop, sockfd)),\n    localAddr_(localAddr),\n    peerAddr_(peerAddr),\n    highWaterMark_(64*1024*1024)\n{\n  channel_->setReadCallback(\n      std::bind(&TcpConnection::handleRead, this, _1));\n  channel_->setWriteCallback(\n      std::bind(&TcpConnection::handleWrite, this));\n  channel_->setCloseCallback(\n      std::bind(&TcpConnection::handleClose, this));\n  channel_->setErrorCallback(\n      std::bind(&TcpConnection::handleError, this));\n  LOG_DEBUG << \"TcpConnection::ctor[\" <<  name_ << \"] at \" << this\n            << \" fd=\" << sockfd;\n  socket_->setKeepAlive(true);\n}\n```\n\n依赖都是单向的，TcpServer会用到Acceptor，但Acceptor不知道TcpServer的存在。TcpServer会用到TcpConnection，但TcpConnection不知道TcpServer的存在。\n![Alt text](../../images/muduo初始化序列.png)\n\n``` cpp\nvoid EventLoop::runInLoop(Functor cb)\n{\n  if (isInLoopThread())\n  {\n    cb();\n  }\n  else\n  {\n    queueInLoop(std::move(cb));\n  }\n}\n```\n\n 在queueInLoop()函数中主要就是把cb这个可调用对象保存在EventLoop对象的pendingFunctors_这个数组中，\n **我们希望这个cb能在某个EventLoop对象所绑定的线程上运行，但是由于当前CPU执行的线程不是我们期待的这个EventLoop线程，我们只能把这个可调用对象先存在这个EventLoop对象的数组成员pendingFunctors_中。**\n\n``` cpp\nvoid EventLoop::queueInLoop(Functor cb)\n{\n  {\n  MutexLockGuard lock(mutex_);\n  //   std::vector<Functor> pendingFunctors_ GUARDED_BY(mutex_);\n  pendingFunctors_.push_back(std::move(cb));\n  }\n    /**\n     * || callingPendingFunctors的意思是 当前loop正在执行回调中 但是loop的pendingFunctors_中又加入了新的回调 需要通过wakeup写事件\n     * 唤醒相应的需要执行上面回调操作的loop的线程 让loop()下一次poller_->poll()不再阻塞（阻塞的话会延迟前一次新加入的回调的执行），然后\n     * 继续执行pendingFunctors_中的回调函数\n     **/\n  if (!isInLoopThread() || callingPendingFunctors_)\n  {\n    wakeup();\n  }\n}\n\n// EventLoop.h\n// threadId_ --- 记录当前EventLoop是被哪个线程id创建的 即标识了当前EventLoop的所属线程id\nbool isInLoopThread() const { return threadId_ == CurrentThread::tid(); }\n\nvoid EventLoop::wakeup()\n// 用来唤醒loop所在线程 向wakeupFd_写一个数据 wakeupChannel就发生读事件 当前loop线程就会被唤醒\n{\n    uint64_t one = 1;\n    ssize_t n = write(wakeupFd_, &one, sizeof(one));\n    if (n != sizeof(one))\n    {\n        LOG_ERROR(\"EventLoop::wakeup() writes %lu bytes instead of 8\\n\", n);\n    }\n}\n```\n\n1. 从EventLoop::loop()函数中，我们知道EventLoop::loop()肯定运行在其所绑定的EventLoop线程内，在该函数内会调用doPendingFunctors()函数，这个函数就是把自己这个EventLoop对象中的pendingFunctors_数组中保存的可调用对象拿出来执行。pendingFunctors_中保存的是其他线程希望你这个EventLoop线程执行的函数。\n2. 假如EventLoop A线程阻塞在EventLoop::loop()中的epoll_wait()调用上（EventLoop A上监听的文件描述符没有任何事件发生），这时候EventLoop线程要求EventLoop A赶紧执行某个函数，那其他线程要怎么唤醒这个阻塞住的EventLoop A线程呢？\n\n3 。这时候我们来看下wakeup()函数。wakeup()函数就是向我们想唤醒的线程所绑定的EventLoop对象持有的wakeupFd_随便写入一个8字节数据，因为wakeupFd_已经注册到了这个EventLoop中的事件监听器上，这时候事件监听器监听到有文件描述符的事件发生，epoll_wait()阻塞结束而返回。这就相当于起到了唤醒线程的作用！你这个EventLoop对象既然阻塞在事件监听上，那我就通过wakeup()函数给你这个EventLoop对象一个事件，让你结束监听阻塞。然后去执行doPendingFunctors()\n\n``` cpp\n// 连接建立\nvoid TcpConnection::connectEstablished()\n{\n    setState(kConnected);\n    channel_->tie(shared_from_this());\n    channel_->enableReading(); // 向poller注册channel的EPOLLIN读事件\n    // channel update remove => EventLoop updateChannel removeChannel => Poller updateChannel removeChannel\n\n    // 新连接建立 执行回调 ,这里时TcpServer 的 connectionCallback_ 由用户定义\n    connectionCallback_(shared_from_this());\n}\n```\n\n## 分发到subLoop上后，当有数据到来时\n\n``` cpp\n// 读是相对服务器而言的 当对端客户端有数据到达 服务器端检测到EPOLLIN 就会触发该fd上的回调 handleRead取读走对端发来的数据\n// #include\"Channel.h\"\nvoid Channel::handleEventWithGuard(Timestamp receiveTime)\n{\n  eventHandling_ = true;\n  LOG_TRACE << reventsToString();\n  if ((revents_ & POLLHUP) && !(revents_ & POLLIN))\n  {\n    if (logHup_)\n    {\n      LOG_WARN << \"fd = \" << fd_ << \" Channel::handle_event() POLLHUP\";\n    }\n    if (closeCallback_) closeCallback_();\n  }\n\n  if (revents_ & POLLNVAL)\n  {\n    LOG_WARN << \"fd = \" << fd_ << \" Channel::handle_event() POLLNVAL\";\n  }\n\n  if (revents_ & (POLLERR | POLLNVAL))\n  {\n    if (errorCallback_) errorCallback_();\n  }\n  if (revents_ & (POLLIN | POLLPRI | POLLRDHUP))\n  {\n    if (readCallback_) readCallback_(receiveTime);\n  }\n  if (revents_ & POLLOUT)\n  {\n    if (writeCallback_) writeCallback_();\n  }\n  eventHandling_ = false;\n}\n\nvoid TcpConnection::handleRead(Timestamp receiveTime)\n{\n    int savedErrno = 0;\n    ssize_t n = inputBuffer_.readFd(channel_->fd(), &savedErrno);\n    if (n > 0) // 有数据到达\n    {\n        // 已建立连接的用户有可读事件发生了 调用用户传入的回调操作onMessage shared_from_this就是获取了TcpConnection的智能指针\n        messageCallback_(shared_from_this(), &inputBuffer_, receiveTime);\n    }\n    else if (n == 0) // 客户端断开\n    {\n        handleClose();\n    }\n    else // 出错了\n    {\n        errno = savedErrno;\n        LOG_ERROR(\"TcpConnection::handleRead\");\n        handleError();\n    }\n}\n```\n\n## EventLoop::doPendingFunctors()函数\n\n``` cpp\nvoid EventLoop::doPendingFunctors()\n{\n    std::vector<Functor> functors;\n    callingPendingFunctors_ = true;\n\n    {\n        std::unique_lock<std::mutex> lock(mutex_);\n        functors.swap(pendingFunctors_); // 交换的方式减少了锁的临界区范围 提升效率 同时避免了死锁 如果执行functor()在临界区内 且functor()中调用queueInLoop()就会产生死锁\n    }\n\n    for (const Functor &functor : functors)\n    {\n        functor(); // 执行当前loop需要执行的回调操作\n    }\n\n    callingPendingFunctors_ = false;\n}\n```\n\n1. 如果当前线程要去执行消费该线程EventLoop对应的任务队列里的回调函数，此时又有新的回调函数想加入到该队列中，那我们肯定没办法一边去遍历队列来执行消费任务队列中的回调函数，一边向任务队列加入新的任务，我们需要首先对队列加锁，执行完队列中的任务后再去解锁，然后再让其他回调函数能够加入到任务队列。但是这样肯定是不可行的，其效率是非常低的。\n2. 避免死锁,Functor可能再次调用queueInLoop。\n\n## 消息发送\n\n``` cpp\n\n// #include \"muduo/net/TcpConnection.h\"\n// FIXME efficiency!!!\nvoid TcpConnection::send(Buffer* buf)\n{\n  if (state_ == kConnected)\n  {\n    if (loop_->isInLoopThread())\n    {\n      sendInLoop(buf->peek(), buf->readableBytes());\n      buf->retrieveAll();\n    }\n    else\n    {\n      void (TcpConnection::*fp)(const StringPiece& message) = &TcpConnection::sendInLoop;\n      loop_->runInLoop(\n          std::bind(fp,\n                    this,     // FIXME\n                    buf->retrieveAllAsString()));\n                    //std::forward<string>(message)));\n    }\n  }\n}\n\n/**\n * 发送数据 应用写的快 而内核发送数据慢 需要把待发送数据写入缓冲区，而且设置了水位回调--这里这两个回调实际均未初始化。\n **/\nvoid TcpConnection::sendInLoop(const void *data, size_t len)\n{\n    ssize_t nwrote = 0;\n    size_t remaining = len;\n    bool faultError = false;\n\n    if (state_ == kDisconnected) // 之前调用过该connection的shutdown 不能再进行发送了\n    {\n        LOG_ERROR(\"disconnected, give up writing\");\n    }\n\n    // 表示channel_第一次开始写数据或者缓冲区没有待发送数据\n    if (!channel_->isWriting() && outputBuffer_.readableBytes() == 0)\n    {\n        nwrote = ::write(channel_->fd(), data, len);\n        if (nwrote >= 0)\n        {\n            remaining = len - nwrote;\n            if (remaining == 0 && writeCompleteCallback_)\n            {\n                // 既然在这里数据全部发送完成，就不用再给channel设置epollout事件了\n                loop_->queueInLoop(\n                    std::bind(writeCompleteCallback_, shared_from_this()));\n            }\n        }\n        else // nwrote < 0\n        {\n            nwrote = 0;\n            if (errno != EWOULDBLOCK) // EWOULDBLOCK表示非阻塞情况下没有数据后的正常返回 等同于EAGAIN\n            {\n                LOG_ERROR(\"TcpConnection::sendInLoop\");\n                if (errno == EPIPE || errno == ECONNRESET) // SIGPIPE RESET\n                {\n                    faultError = true;\n                }\n            }\n        }\n    }\n    /**\n     * 说明当前这一次write并没有把数据全部发送出去 剩余的数据需要保存到缓冲区当中\n     * 然后给channel注册EPOLLOUT事件，Poller发现tcp的发送缓冲区有空间后会通知\n     * 相应的sock->channel，调用channel对应注册的writeCallback_回调方法，\n     * channel的writeCallback_实际上就是TcpConnection设置的handleWrite回调，\n     * 把发送缓冲区outputBuffer_的内容全部发送完成\n     **/\n    if (!faultError && remaining > 0)\n    {\n        // 目前发送缓冲区剩余的待发送的数据的长度\n        // highWaterMarkCallback_ --- 实际上未初始化\n        size_t oldLen = outputBuffer_.readableBytes();\n        if (oldLen + remaining >= highWaterMark_ && oldLen < highWaterMark_ && highWaterMarkCallback_)\n        {\n            loop_->queueInLoop(\n                std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));\n        }\n        outputBuffer_.append((char *)data + nwrote, remaining);\n        if (!channel_->isWriting())\n        {\n            channel_->enableWriting(); // 这里一定要注册channel的写事件 否则poller不会给channel通知epollout\n        }\n    }\n}\n\n// 没有发送完时，handleWrite\nvoid TcpConnection::handleWrite()\n{\n    if (channel_->isWriting())\n    {\n        int savedErrno = 0;\n        ssize_t n = outputBuffer_.writeFd(channel_->fd(), &savedErrno);\n        if (n > 0)\n        {\n            outputBuffer_.retrieve(n);\n            if (outputBuffer_.readableBytes() == 0)\n            {   // 移除可写事件，为了提高效率，\n                channel_->disableWriting();\n                if (writeCompleteCallback_)\n                {\n                    // TcpConnection对象在其所在的subloop中 向pendingFunctors_中加入回调\n                    loop_->queueInLoop(\n                        std::bind(writeCompleteCallback_, shared_from_this()));\n                }\n                if (state_ == kDisconnecting)\n                {\n                    shutdownInLoop(); // 在当前所属的loop中把TcpConnection删除掉\n                }\n            }\n        }\n        else\n        {\n            LOG_ERROR(\"TcpConnection::handleWrite\");\n        }\n    }\n    else\n    {\n        LOG_ERROR(\"TcpConnection fd=%d is down, no more writing\", channel_->fd());\n    }\n}\n```\n\n- 由于muduo底层是epoll驱动的，可读可写状态是由文件描述符对应的内核缓冲区决定的\n- 若要发生可读或者可写事件，首先，前提是要向epoll注册（调用epoll_ctl）需要关注的事件类型。当关注了可读事件时，若文件描述符对应的缓冲区从空变为非空，则触发读事件；\n- 当关注了可写事件时，若文件描述符对应的缓冲区由满变为不满，则触发写事件。当然epoll的LT模式会多次触发，而ET模式仅触发一次，这里不过多介绍。\n- 回到上面的项目来说，一般我们的文件描述符对应的缓冲区都不是满的，所以一开始不会关注写事件，否则如果说缓冲区不满就触发写事件，那就会一直轮询触发，对系统资源是一种浪费，所以一般情况下只关注读事件。\n- 只有当系统要向文件描述符对应的缓冲区写数据时，再关注写事件，这样一来，当缓冲区有“空位”，我就立刻往里面丢数据，反而在这种关键时刻关注写事件，写效率会更高一些，写完数据记得再通过epoll_ctl取消对写事件的关注。\n\n## 连接断开\n\n被动断开,TcpConnection::handleRead()函数内部调用了Linux的函数readv()，当readv()返回0的时候，服务端就知道客户端断开连接了。然后就接着调用TcpConnection::handleClose()。\n\n``` cpp\n\n//  #include \"Poller.h\"\n  Poller{\n   // map的key:sockfd value:sockfd所属的channel通道类型\n    protected:\n    using ChannelMap = std::unordered_map<int, Channel *>;\n    ChannelMap channels_;\n    private:\n    EventLoop *ownerLoop_; // 定义Poller所属的事件循环EventLoop\n  };\n```\n\n  TcpConnection::handleRead()(readv 返回0)==>TcpConnection::handleClose ==> TcpServer::removeConnection ==>TcpServer::removeConnectionInLoop (清除ConnectionMap对应的TcpConnectionPtr) ==> TcpConnection::connectDestroyed;\n\n``` cpp\nvoid TcpServer::removeConnection(const TcpConnectionPtr &conn)\n{\n    loop_->runInLoop(\n        std::bind(&TcpServer::removeConnectionInLoop, this, conn));\n}\n\nvoid TcpServer::removeConnectionInLoop(const TcpConnectionPtr &conn)\n{\n    LOG_INFO(\"TcpServer::removeConnectionInLoop [%s] - connection %s\\n\",\n             name_.c_str(), conn->name().c_str());\n\n    connections_.erase(conn->name());\n    EventLoop *ioLoop = conn->getLoop();\n    ioLoop->queueInLoop(\n        std::bind(&TcpConnection::connectDestroyed, conn));\n}\nvoid TcpConnection::connectDestroyed()\n{\n  loop_->assertInLoopThread();\n  if (state_ == kConnected)\n  {\n    setState(kDisconnected);\n    channel_->disableAll();\n\n    connectionCallback_(shared_from_this());\n  }\n  channel_->remove();\n}\n```\n\n1. 要想彻底删除一个TcpConnection对象，就必须要调用这个对象的connecDestroyed()方法，这个方法执行完后才能释放这个对象的堆内存。每个TcpConnection对象的connectDestroyed()方法都必须在这个TcpConnection对象所属的Sub EventLoop绑定的线程中执行。\n\n2. Tcpserver::removeConnection()把conn从ConnectionMap(connections_)\n此时，如果用户不持有TcpConnectionPtr的话，conn引用计数已降到1。这里一定要用，EventLoop::queueInLoop();另外注意，这里用std::bind让TcpConnection的生命期长到connectDestroyed时刻。(如果不用bind，removeConnectionInLoop函数结束，conn引用计数减为0,就会析构。channel一定要比conn先析构)\n\n**智能指针当赋值给别的智能指针或者函数传参拷贝到另一个shared_ptr，计数器就会加1，当函数执行完毕，智能指针对象就被析构了，此时计数器就会减1**\n\n3. 在TcpServer里会有一个ConnectionMap -- std::map<string, TcpConnectionPtr> ;,里面记录着已经建立的连接，目的是防止用户删除conn，用智能指针的原因，用户删除TcpConnectionPtr只会减少引用计数，不会删除conn。\n\n## 参考\n\n<https://www.cnblogs.com/S1mpleBug/p/16712003.html#1-multi-reactor%E6%A6%82%E8%BF%B0>\n<https://cloud.tencent.com/developer/article/1400731>\n","tags":["muduo"],"categories":["c++"]},{"title":"std::dynamic_cast和dynamic_pointer_cast","url":"/2023/08/12/cpp/std-static_cast和dynamic_cast/","content":"\n\n# static_cast\n\n`static_cast<type>(expression)`\n该运算符把 expression 转换为 type 类型，主要用于基本数据类型之间的转换，比如把 uint 转换为 int，把 int 转换为 double 等。\n\n``` cpp\nuint x = 1;\nint y = static_cast<int>(x); // 转换正确\n\nint x = 1;\ndouble y = static_cast<double>(x); // 转换正确\n```\n\nstatic_cast 没有运行时类型检查来保证转换的安全性，需要程序员来判断转换是否安全。\nstatic_cast 进行下行转换由于没有动态类型检查，所以是不安全的。\n\n* 上行转换（把子类的指针或引用转换成基类表示）是安全的；\n* 下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。建议使用dynamic_cast\n\n# dynamic_cast\n\ndynamic_cast 主要用于类层次间的上行转换或下行转换。\n在进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的。\n但在下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void Say() {\n        cout << \"I am Base.\" << endl;\n    }\n};\n\nclass Derive : public Base {\npublic:\n    virtual void Say() {\n        cout << \"I am Derive.\" << endl;\n    }\n};\n\nint main()\n{\n    // 上行转换，派生类→基类\n    Derive* drive1 = new Derive();\n    cout << \"drive1: \" << drive1 << endl;\n\n    Base* base1 = dynamic_cast<Base*>(drive1);\n    cout << \"base1: \" << base1 << endl;\n\n    \n    // 下行转换，基类→派生类\n    Base* base2 = new Base();\n    cout << \"base2: \" << base2 << endl;\n\n    Derive* drive2 = dynamic_cast<Derive*>(base2);\n    cout << \"drive2: \" << drive2 << endl;\n\n    return 0;\n}\n// 这是因为派生类包含基类信息，所以上行转换（只能调用基类的方法和成员变量），一般是安全的；\n// 而基类没有派生类的任何信息，而下行转换后会用到派生类的方法和成员变量，这些基类都没有，很容易“指鹿为马”，或指向不存在的空间。\n```\n\n# 基类和派生类的智能指针转换\n\n基类和派生类的智能指针转换要使用std::dynamic_pointer_cast和std::static_pointer_cast。\n具体示例如下：\n\n``` cpp\n#include <iostream>\n#include <memory>\n \nclass Base\n{\npublic:\n    int a;\n    virtual void f() const { std::cout << \"I am base!\\n\"; }\n    virtual ~Base() {}\n};\n \nclass Derived : public Base\n{\npublic:\n    void f() const override { std::cout << \"I am derived!\\n\"; }\n    ~Derived() {}\n};\n \nint main()\n{\n    auto basePtr = std::make_shared<Base>();\n    std::cout << \"Base pointer says: \";\n    basePtr->f();\n \n    auto derivedPtr = std::make_shared<Derived>();\n    std::cout << \"Derived pointer says: \";\n    derivedPtr->f();\n \n    // static_pointer_cast to go up class hierarchy\n    basePtr = std::static_pointer_cast<Base>(derivedPtr);\n    std::cout << \"Base pointer to derived says: \";\n    basePtr->f();\n \n    // dynamic_pointer_cast to go down/across class hierarchy\n    auto downcastedPtr = std::dynamic_pointer_cast<Derived>(basePtr);\n    if (downcastedPtr)\n    {\n        std::cout << \"Downcasted pointer says: \";\n        downcastedPtr->f();\n    }\n \n    // All pointers to derived share ownership\n    std::cout << \"Pointers to underlying derived: \"\n              << derivedPtr.use_count()\n              << '\\n';\n              \n    auto basePtr2 = std::make_shared<Base>();\n    std::cout << basePtr2<<std::endl;\n    \n    auto  downcastedPtr2 = std::dynamic_pointer_cast<Derived>(basePtr2);\n     std::cout << downcastedPtr2<<std::endl;\n    \n    if (downcastedPtr2)\n    {\n        std::cout << \"Downcasted pointer says: \";\n        downcastedPtr->f();\n    }\n}\n```\n\n> output:\n    Base pointer says: I am base!\n    Derived pointer says: I am derived!\n    Base pointer to derived says: I am derived!\n    Downcasted pointer says: I am derived!\n    Pointers to underlying derived: 3\n    0x204f030\n    0\n","tags":["c++11"],"categories":["c++"]},{"title":"std::ref和std::cref","url":"/2023/08/08/cpp/std-ref和std-cref/","content":"\n# std::ref和std::cref\n\n# 解释\n\nstd::ref 用于包装按引用传递的值。\nstd::cref 用于包装按const引用传递的值。\n\n为什么需要std::ref和std::cref,\nbind()是一个函数模板，它的原理是根据已有的模板，生成一个函数，但是由于bind()不知道生成的函数执行的时候，传递进来的参数是否还有效。所以它选择参数值传递而不是引用传递。如果想引用传递，std::ref和std::cref就派上用场了。\n\n``` cpp\n#include <functional>\n#include <iostream>\n \nvoid f(int& n1, int& n2, const int& n3)\n{\n    std::cout << \"In function: \" << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n    ++n1; // 增加存储于函数对象的 n1 副本\n    ++n2; // 增加 main() 的 n2\n    // ++n3; // 编译错误\n}\n \nint main()\n{\n    int n1 = 1, n2 = 2, n3 = 3;\n    std::function<void()> bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3));\n    n1 = 10;\n    n2 = 11;\n    n3 = 12;\n    std::cout << \"Before function: \" << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n    bound_f();\n    std::cout << \"After function: \" << n1 << ' ' << n2 << ' ' << n3 << '\\n';\n}\n```\n\n``` cpp\n//输出\nBefore function: 10 11 12\nIn function: 1 11 12\nAfter function: 10 12 12\n```\n","tags":["c++11"],"categories":["c++"]},{"title":"std::move","url":"/2023/08/08/cpp/std-move/","content":"\n> move实际上不能移动任何东西，它唯一的功能是将一个左值强制转化为一个右指引用。强制转换为右值的目的是为了方便实现移动构造。\n\n> 这里要注意对move语义的**误解**,move只是转移了资源的控制权，本质上是将左值强制转换为右值引用，以用于move语义，避免含有资源的对象发生无所谓的拷贝。**move对于拥有形如对内存、文件句柄等资源的成员的对象有效。如果是一些基本类型，比如int和char[10]数组等，如果使用move仍然会发生拷贝(因为没有对应的移动构造函数)，所以说对含有资源的对象来说更有意义**\n","tags":["c++11"],"categories":["c++"]},{"title":"test","url":"/2023/08/07/test/","content":"\n\n\n> 测试\n","tags":["测试"]}]