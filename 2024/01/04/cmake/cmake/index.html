<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>cmake - 木偶人</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="木偶人">
    <meta property="og:title" content="cmake"/>
    
    <style>body:before{ content: ''; background-image: url(https://api.paugram.com/wallpaper?source=gh) }</style>
    
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <header>
    <div class="head-title">
        <h4>木偶人</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        <div class="has-child">
            <a>分类</a>
            <div class="sub-menu">
                <a class="category-link" href="/categories/FFmpeg/">FFmpeg</a><a class="category-link" href="/categories/c/">c++</a><a class="category-link" href="/categories/cmake/">cmake</a><a class="category-link" href="/categories/sylar/">sylar</a>
            </div>
        </div>
        
            <a href="/about">关于我</a>
        
            <a href="/friends">朋友们</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>cmake</h2>
            <div class="post-meta">
                <time class="date">2024.01.04</time>
            
                <span class="category"><a class="category-link" href="/categories/cmake/">cmake</a></span>
            
            </div>
        </section>
        <article class="post-content">
        
            <!-- # CMakeLists.txt -->

<p>根项目的 CMakeLists.txt 负责处理全局有效的设定。</p>
<p>而子项目的 CMakeLists.txt 则仅考虑该子项目自身的设定，比如他的头文件目录，要链接的库等等。</p>
<h2 id="科普：亲-Unix-软件从源码安装的通用套路"><a href="#科普：亲-Unix-软件从源码安装的通用套路" class="headerlink" title="科普：亲 Unix 软件从源码安装的通用套路"></a>科普：亲 Unix 软件从源码安装的通用套路</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Makefile 构建系统：
./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr --with-some-options    <span class="token comment"># 生成 Makefile（这个 configure 脚本由 Autoconf 生成）</span>
<span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token number">8</span>                <span class="token comment"># 8 核心编译，生成 libtest.so</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>   <span class="token comment"># 安装，拷贝到 /usr/lib/libtest.so</span>

CMake 构建系统：
cmake <span class="token parameter variable">-B</span> build <span class="token parameter variable">-DCMAKE_INSTALL_PREFIX</span><span class="token operator">=</span>/usr <span class="token parameter variable">-DWITH_SOME_OPTIONS</span><span class="token operator">=</span>ON  <span class="token comment"># 生成 Makefile</span>
cmake <span class="token parameter variable">--build</span> build <span class="token parameter variable">--parallel</span> <span class="token number">8</span>                  <span class="token comment"># 8 核心编译，生成 libtest.so</span>
<span class="token function">sudo</span> cmake <span class="token parameter variable">--build</span> build <span class="token parameter variable">--target</span> <span class="token function">install</span>    <span class="token comment"># 安装，拷贝到 /usr/lib/libtest.so</span>

注：如果 <span class="token parameter variable">-DCMAKE_INSTALL_PREFIX</span><span class="token operator">=</span>/usr/local 则会拷贝到 /usr/local/lib/libtest.so
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="如果第三方库发懒，没有提供-Config-文件怎么办？"><a href="#如果第三方库发懒，没有提供-Config-文件怎么办？" class="headerlink" title="如果第三方库发懒，没有提供 Config 文件怎么办？"></a>如果第三方库发懒，没有提供 Config 文件怎么办？</h2><p>但是，也有少数不听话的库，官方不提供 CMake 支持，即安装时不自带 Config 文件。<br>恼人的是，这些不听话的库有些竟然是非常热门的库！例如 Python，CUDA，Jemalloc。<br>为了不影响 CMake 用户体验，CMake 发明了 Find 文件（FindXXX.cmake），你不支持我是吧？我支持你！Find 文件会在 CMake 安装时负责安装到<code>/usr/share/cmake/Modules</code>。<br>包搜索文件可以在不知道包具体位置信息的情况下搜索他们（在 <code>/usr/lib</code> 等默认路径搜索）。<br>这些都是 CMake 自带的包搜索文件：<br><code>/usr/share/cmake/Modules/FindCUDAToolkit.cmake</code><br><code>/usr/share/cmake/Modules/FindPython.cmake</code><br>那么如果有个不太热门的第三方库没提供包配置文件，CMake 也没提供包搜索文件，我们该如何找到他？这就需要自己提供包搜索文件了！别担心，你不用自己写，<code>GitHub</code> 上有很多志士仁人已经写过了对应的包搜索文件，你搜一下 FindXXX.cmake 就能找到了。</p>
<p><strong>举例：FindJemalloc.cmake</strong></p>
<p><strong>注意不论是项目自己的头文件还是外部的系统的头文件，请全部统一采用 &lt;项目名&#x2F;模块名.h&gt; 的格式。不要用 “模块名.h” 这种相对路径的格式，避免模块名和系统已有头文件名冲突。</strong></p>
<p><img src="/../../images/cmake/assets/image-20230712103514686.png" alt="image-20230712103514686"></p>
<h2 id="一个标准的-CMakeLists-txt-模板"><a href="#一个标准的-CMakeLists-txt-模板" class="headerlink" title="一个标准的 CMakeLists.txt 模板"></a>一个标准的 CMakeLists.txt 模板</h2><p><img src="/../../images/cmake/assets/image-20230714162906960.png" alt="image-20230714162906960"></p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ol>
<li><p>CMake 的 ${} 表达式可以嵌套</p>
</li>
<li><p>设定一个变量的默认值</p>
</li>
</ol>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">NOT</span> <span class="token operator">DEFINED</span> <span class="token variable">BUILD_SHARED_LIBS</span><span class="token punctuation">)</span>
 <span class="token function">SET</span><span class="token punctuation">(</span><span class="token variable">BUILD_SHARED_LIBS</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="常见坑点"><a href="#常见坑点" class="headerlink" title="常见坑点"></a>常见坑点</h3><p><strong>动态库无法链接静态库</strong></p>
<h3 id="一些参数的含义"><a href="#一些参数的含义" class="headerlink" title="一些参数的含义"></a>一些参数的含义</h3><ol>
<li><p><code>CMAKE_CURRENT_SOURCE_DIR</code> – 当前CMakeList.txt所在的路径。</p>
</li>
<li><p><code>CMAKE_CURRENT_BINARY_DIR</code> –  表示当前输出目录的位置，例如 ~&#x2F;hellocmake&#x2F;build。</p>
</li>
<li><p><code>CMAKE_SOURCE_DIR</code> – 表示整个项目最外面的CMakeList.txt</p>
</li>
<li><p><code>PROJECT_SOURCE_DIR</code> 表示最近一次调用 project 的 CMakeLists.txt 所在的源码目录。</p>
<ol>
<li><p>利用 <code>PROJECT_SOURCE_DIR</code> 可以实现从子模块里直接获得项目最外层目录的路径。</p>
</li>
<li><p><img src="/../../images/cmake/assets/image-20230714160654000.png" alt="image-20230714160654000"></p>
</li>
<li><blockquote>
<p><strong>子模块里也可以用 project 命令，将当前目录作为一个独立的子项目</strong></p>
<p>— 这样一来 <code>PROJECT_SOURCE_DIR</code> 就会是子模块的源码目录而不是外层了。这时候 <code>CMake</code> 会认为这个子模块是个独立的项目，会额外做一些初始化。他的构建目录 <code>PROJECT_BINARY_DIR</code> 也会变成 build&#x2F;&lt;源码相对路径&gt;。这样在 MSVC 上也会看见 <code>build/mylib/mylib.vcxproj</code> 的生成。</p>
<p><img src="/../../images/cmake/assets/image-20230714161111648.png" alt="image-20230714161111648"></p>
</blockquote>
</li>
<li><p>project(项目名 LANGUAGES 使用的语言列表…)  指定了该项目使用了哪些编程语言。— 如果不指定 LANGUAGES，默认为 C 和 CXX。</p>
</li>
<li><p><code>CMAKE_CXX_STANDARD</code> 是一个整数，表示要用的 C++ 标准。比如需要 C++17 那就设为 17，需要 C++23 就设为 23。</p>
</li>
<li><p><code>CMAKE_CXX_STANDARD_REQUIRED</code> 是 BOOL 类型，可以为 ON 或 OFF，默认 OFF。他表示是否一定要支持你指定的 C++ 标准：如果为 OFF 则 CMake 检测到编译器不支持 C++17 时不报错，而是默默调低到 C++14 给你用；为 ON 则发现不支持报错，更安全。</p>
</li>
<li><p><code>CMAKE_CXX_EXTENSIONS</code> 也是 BOOL 类型，默认为 ON。设为 ON 表示启用 GCC 特有的一些扩展功能；OFF 则关闭 GCC 的扩展功能，只使用标准的 C++。</p>
</li>
<li><p>要兼容其他编译器（如 MSVC）的项目，都会设为 OFF 防止不小心用了 GCC 才有的特性。此外，<strong>最好是在 project 指令前设置 CMAKE_CXX_STANDARD 这一系列变量，</strong>这样 CMake 可以在 project 函数里对编译器进行一些检测，看看他能不能支持 C++17 的特性。</p>
</li>
<li></li>
</ol>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.15</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span>  <span class="token number">17</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_EXTENSIONS</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>hellocmake LANUAGES CXX<span class="token punctuation">)</span>

<span class="token comment"># 请勿直接修改 CMAKE_CXX_FLAGS 来添加 -std=c++17（你在百度 CSDN 学到的用法）。</span>
<span class="token comment"># 请使用 CMake 帮你封装好的 CMAKE_CXX_STANDARD（从业人员告诉你的正确用法）。</span>
<span class="token comment"># 为什么百度不对：你 GCC 用户手动指定了 -std=c++17，让 MSVC 的用户怎么办？</span>
<span class="token comment"># 此外 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加 -std=c++11 选项了，你再添加个 -std=c++17 选项不就冲突了吗？所以请用 CMAKE_CXX_STANDARD。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>project(项目名 VERSION x.y.z) 可以把当前项目的版本号设定为 x.y.z。</p>
<ul>
<li>之后可以通过 PROJECT_VERSION 来获取当前项目的版本号。</li>
<li>PROJECT_VERSION_MAJOR 获取 x（主版本号）。</li>
<li>PROJECT_VERSION_MINOR 获取 y（次版本号）。</li>
<li>PROJECT_VERSION_PATCH 获取 z（补丁版本号）。</li>
<li><strong>项目名的另一大作用：会设置另外 &lt;项目名&gt;_SOURCE_DIR 等变量</strong></li>
</ul>
</li>
<li><p><code>PROJECT_IS_TOP_LEVEL</code> ：BOOL类型，表示当前项目是否是（最顶层的）根项目</p>
</li>
<li><p><code>PROJECT_NAME</code> ：当前项目名</p>
</li>
<li><p><code>CMAKE_PROJECT_NAME</code> ：根项目的项目名</p>
</li>
<li><p><code>CMAKE_PREFIX_PATH</code> – 指定查找外部软件包或库时的前缀路径。 – Unix 平台默认为 &#x2F;usr。</p>
 <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_PREFIX_PATH</span> <span class="token string">"/path/to/library;/another/path/to/library"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>安装库时， –prefix 选项，指定安装的根路径。</p>
</li>
<li><p><code>CMAKE_BUILD_TYPE</code>  – 构建的类型，调试模式还是发布模式</p>
<ul>
<li><p>CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量，用于控制构建类型，他的值可以是</p>
</li>
<li><p>Debug 调试模式，完全不优化，生成调试信息，方便调试程序Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢</p>
</li>
<li><p>MinSizeRel 最小体积发布，生成的文件比 Release 更小，不完全优化，减少二进制体积</p>
</li>
<li><p>RelWithDebInfo 带调试信息发布，生成的文件比 Release 更大，因为带有调试的符号信息默认情况下 CMAKE_BUILD_TYPE 为空字符串，这时相当于 Debug。</p>
<ul>
<li><strong>如何让 CMAKE_BUILD_TYPE 在用户没有指定的时候为 Release，指定的时候保持用户指定的值不变呢。</strong> 就是说 CMake 默认情况下 CMAKE_BUILD_TYPE 是一个空字符串。因此这里通过 if (NOT CMAKE_BUILD_TYPE) 判断是否为空，如果空则自动设为 Release 模式。大多数 CMakeLists.txt 的开头都会有这样三行，为的是让默认的构建类型为发布模式（高度优化）而不是默认的调试模式（不会优化）。我们稍后会详细捋一遍类似于 CMAKE_BUILD_TYPE 这样的东西。绝大多数 CMakeLists.txt 开头都会有的部分，可以说是“标准模板”了。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">NOT</span> <span class="token variable">CMAKE_BUILD_TYPE</span><span class="token punctuation">)</span>
<span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token variable">CMAKE_BUILD_TYPE</span> Release<span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li><p>设置变量</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>main<span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span>source main.cpp other.cpp other.h<span class="token punctuation">)</span>
<span class="token keyword">target_sources</span><span class="token punctuation">(</span>main <span class="token namespace">PUBLIC</span> <span class="token punctuation">$&#123;</span>sources<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="构建和链接静态库和动态库-—-add-library"><a href="#构建和链接静态库和动态库-—-add-library" class="headerlink" title="构建和链接静态库和动态库 — add_library"></a>构建和链接静态库和动态库 — add_library</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_library</span><span class="token punctuation">(</span>biology <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>srcs<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>创建目标——静态库。库的名称和源码文件名相同，具体代码如下：</p>
 <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_library</span><span class="token punctuation">(</span>message
  <span class="token namespace">STATIC</span>
    Message.hpp
    Message.cpp
  <span class="token punctuation">)</span>
  <span class="token comment">#创建hello-world可执行文件的目标部分不需要修改：</span>
  <span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello-world hello-world.cpp<span class="token punctuation">)</span>
  <span class="token comment">#最后，将目标库链接到可执行目标：</span>
  <span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>hello-world message<span class="token punctuation">)</span>
 
 <span class="token comment">#编译成功后，构建目录包含libmessage.a一个静态库(在GNU/Linux上)和hello-world可执行文件。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>add_library(message STATIC Message.hpp Message.cpp)</code>：生成必要的构建指令，将指定的源码编译到库中。</p>
<ul>
<li><code>add_library</code>的第一个参数是目标名。</li>
<li>整个<code>CMakeLists.txt</code>中，可使用相同的名称来引用库。生成的库的实际名称将由CMake通过在前面添加前缀<code>lib</code>和适当的扩展名作为后缀来形成。</li>
<li>生成库是根据第二个参数(<code>STATIC</code>或<code>SHARED</code>)和操作系统确定的。</li>
</ul>
</li>
<li><p><code>target_link_libraries(hello-world message)</code>: 将库链接到可执行文件。</p>
<ul>
<li>此命令还确保<code>hello-world</code>可执行文件可以正确地依赖于消息库。</li>
<li>因此，在消息库链接到<code>hello-world</code>可执行文件之前，需要完成消息库的构建。</li>
</ul>
<p><strong>CMake接受其他值作为<code>add_library</code>的第二个参数的有效值</strong></p>
<ul>
<li><strong>STATIC</strong>：用于创建静态库，即编译文件的打包存档，以便在链接其他目标时使用，例如：可执行文件。</li>
<li><strong>SHARED</strong>：用于创建动态库，即可以动态链接，并在运行时加载的库。可以在<code>CMakeLists.txt</code>中使用<code>add_library(message SHARED Message.hpp Message.cpp)</code>从静态库切换到动态共享对象(DSO)。</li>
<li><strong>OBJECT</strong>：可将给定<code>add_library</code>的列表中的源码编译到目标文件，不将它们归档到静态库中，也不能将它们链接到共享对象中。如果需要一次性创建静态库和动态库，那么使用对象库尤其有用。我们将在本示例中演示。</li>
<li><strong>MODULE</strong>：又为DSO组。与<code>SHARED</code>库不同，它们不链接到项目中的任何目标，不过可以进行动态加载。该参数可以用于构建运行时插件。</li>
</ul>
</li>
<li><p><strong>add_library 无参数时，是静态库还是动态库?</strong></p>
<ul>
<li><p>会根据 BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库。ON 则相当于 SHARED，OFF 则相当于 STATIC。</p>
</li>
<li><p>如果未指定 BUILD_SHARED_LIBS 变量，则默认为 STATIC。</p>
</li>
<li><p>因此，如果发现一个项目里的 add_library 都是无参数的，意味着你可以用：cmake -B build -DBUILD_SHARED_LIBS:BOOL&#x3D;ON来让他全部生成为动态库。稍后会详解命令行传递变量的规则。</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">BUILD_SHARED_LIBS</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>mylib mylic.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="flie"><a href="#flie" class="headerlink" title="flie"></a>flie</h2><p>通过 <strong>GLOB_RECRUSE</strong> 为它批量添加了所有位于 <code>src</code> 和 <code>include</code> 下源码和头文件。</p>
<p><img src="/../../images/cmake/assets/image-20230712103409952.png" alt="image-20230712103409952"></p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp include/*.h<span class="token punctuation">)</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>biology <span class="token namespace">STATIC</span> <span class="token punctuation">$&#123;</span>srcs<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>biology <span class="token namespace">PUBLIC</span> include<span class="token punctuation">)</span>
<span class="token comment">#因为子项目的 CMakeLists.txt 里指定的路径都是相对路径，所以这里指定 src 实际上是：根/biology/src。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里我们给 biology 批量添加了 src&#x2F;*.cpp 下的全部源码文件。</p>
<p>*<em>明明只有 <em>.cpp 需要编译，为什么还添加了 include&#x2F;</em>.h?</em>*</p>
<p>为了头文件也能被纳入 VS 的项目资源浏览器，方便编辑。</p>
<h3 id="GLOB-和-GLOB-RECRUSE-的区别"><a href="#GLOB-和-GLOB-RECRUSE-的区别" class="headerlink" title="GLOB 和 GLOB_RECRUSE 的区别"></a>GLOB 和 GLOB_RECRUSE 的区别</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span> <span class="token punctuation">(</span>GLOB myvar CONFIGURE_DEPENDS src/*.cpp<span class="token punctuation">)</span>
<span class="token keyword">file</span> <span class="token punctuation">(</span>GLOB_RECURSE myvar CONFIGURE_DEPENDS src/*.cpp<span class="token punctuation">)</span>

疑问<span class="token number">1</span>：都是按照通配符批量匹配文件，有什么区别？
GLOB：  src/main.cpp（√） src/test/main.cpp（×）
GLOB_RECURSE： src/main.cpp（√） src/test/main.cpp（√）
区别在于 GLOB_RECURSE 允许 * 匹配嵌套的目录。

疑问<span class="token number">2</span>：加了 CONFIGURE_DEPENDS 这个选项有什么区别？
如果不加，在你创建新文件时，myvar 不会自动更新，还是旧的那几个文件，可能出现 undefined symbol，需要重新运行 cmake -B build 才能更新。
加了，则每次 cmake --build 时自动检测目录是否更新，如果目录有新文件了，CMake 会自动帮你重新运行 cmake -B build 更新 myvar 变量。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><ul>
<li>include 和 add_subdirectory 的区别<ul>
<li>include 相当于直接把代码粘贴过去，直接访问调用者的作用域。  – 比如  include 中含有CMAKE_CURRENT_SOURCE_DIR时，此路径为调用include的文件的路径，而不是include内部的文件路径。</li>
<li>include命令是在当前CMake脚本中执行，直接将指定文件的内容插入到该位置，并继续执行后续命令；而add_subdirectory命令则进入指定目录，并执行该目录下的CMakeLists.txt文件中定义的内容。</li>
<li>include用于导入其他脚本的内容，而add_subdirectory用于处理其他目录中的项目的构建过程。</li>
</ul>
</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h2 id="add-subdirectory"><a href="#add-subdirectory" class="headerlink" title="add_subdirectory"></a>add_subdirectory</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>pybmain<span class="token punctuation">)</span>
<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>biology<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过 <code>add_subdirectory</code> 把两个子项目 <code>pybmain</code> 和 <code>biology</code> 添加进来（顺序无关紧要），这会调用 <code>pybmain/CMakeLists.txt</code> 和 <code>biology/CMakeLists.txt</code>。</p>
<h2 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable"></a>add_executable</h2><p>用于创建一个可执行文件目标。</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>target_name [<span class="token variable">WIN32</span>] [<span class="token property">MACOSX_BUNDLE</span>]
    source1 source2 ...
<span class="token punctuation">)</span>
<span class="token comment"># target_name是要创建的可执行文件目标的名称，可以根据需要自定义。</span>
<span class="token comment"># WIN32和MACOSX_BUNDLE是可选的参数，用于指定目标的属性。</span>
<span class="token comment"># source1、source2等是构成可执行文件的源文件（源代码文件）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>my_executable main.cpp helper.cpp<span class="token punctuation">)</span>
<span class="token comment"># add_executable命令创建了一个名为my_executable的可执行文件目标，</span>
<span class="token comment"># 该目标由main.cpp和helper.cpp这两个源文件构成。CMake会自动根据这些源文件生成对应的编译规则，并生成可执行文件。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>可以根据需要在<code>add_executable</code>命令中指定不同的源文件，并可以在同一个CMakeLists.txt文件中多次使用<code>add_executable</code>命令创建多个可执行文件目标。</li>
<li>使用<code>add_executable</code>命令后，您可以使用其他命令（如<code>target_link_libraries、target_include_directories</code>等）为目标添加依赖库、指定包含目录等其他属性和操作。</li>
</ul>
<h2 id="add-dependencies"><a href="#add-dependencies" class="headerlink" title="add_dependencies"></a>add_dependencies</h2><p>假设我们需要生成一个可执行文件,该文件生成需要链接a.so b.so c.so d.so四个动态库<br>正常来讲,我们一把只需要以下两条指令即可:</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>main main.cpp<span class="token punctuation">)</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>main a.so b.so c.so d.so<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>但是编译的时候报错,一些符号的定义找不到,而这些符号恰恰就在这几个库中,假设在<code>a.so</code>和<code>b.so</code>中,在上述两条指令之间加上一条指令即可编译通过:</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>main a.so b.so<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>原因比较简单,生成main需要依赖<code>a.so</code>和<code>b.so</code>中的符号定义,然而<code>a.so</code>和<code>b.so</code>库的生成是在main编译生产之后的,添加这条语句就是提醒编译器需要先生成main的依赖(a.so,b.so),然后再去生成main.</p>
<h2 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h2><p><strong>用于在CMake项目中查找和加载外部软件包或模块。</strong></p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">find_package</span><span class="token punctuation">(</span>&lt;PackageName<span class="token punctuation">></span> [version] [EXACT] [QUIET] [CONFIG] [MODULE]
             [REQUIRED] [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
<span class="token punctuation">)</span>



<span class="token comment"># package_name是要查找的软件包或模块的名称，如Boost、OpenCV等。</span>
<span class="token comment"># version是可选的参数，用于指定软件包的版本号。</span>
<span class="token comment"># EXACT关键字可以用于精确匹配指定版本的软件包。</span>
<span class="token comment"># QUIET关键字可以用于禁止输出查找过程中的消息。</span>
<span class="token comment"># MODULE关键字可以用于查找CMake模块。</span>
<span class="token comment"># REQUIRED关键字可以用于指定软件包是必需的，如果找不到，将报错并停止构建。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例:</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV<span class="token punctuation">)</span>
<span class="token comment"># 查找名为 OpenCV 的包，找不到不报错，事后可以通过 $&#123;OpenCV_FOUND&#125; 查询是否找到。</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV QUIET<span class="token punctuation">)</span>
<span class="token comment"># 查找名为 OpenCV 的包，找不到不报错，也不打印任何信息。</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV REQUIRED<span class="token punctuation">)</span>    <span class="token comment"># 最常见用法</span>
<span class="token comment"># 查找名为 OpenCV 的包，找不到就报错（并终止 cmake 进程，不再继续往下执行）。</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV REQUIRED COMPONENTS core videoio<span class="token punctuation">)</span>
<span class="token comment"># 查找名为 OpenCV 的包，找不到就报错，且必须具有 OpenCV::core 和 OpenCV::videoio 这两个组件，如果没有这两个组件也会报错。</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV REQUIRED OPTIONAL_COMPONENTS core videoio<span class="token punctuation">)</span>
<span class="token comment"># 查找名为 OpenCV 的包，找不到就报错，可具有 OpenCV::core 和 OpenCV::videoio 这两个组件，没有这两组件不会报错，通过 $&#123;OpenCV_core_FOUND&#125; 查询是否找到 core 组件。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="find-package-说是找“包”，到底是在找什么？"><a href="#find-package-说是找“包”，到底是在找什么？" class="headerlink" title="find_package 说是找“包”，到底是在找什么？"></a>find_package 说是找“包”，到底是在找什么？</h3><p><code>find_package(OpenCV)</code>实际上是在找一个名为<code>OpenCVConfig.cmake</code> 的文件。</p>
<p>注：出于历史兼容性考虑，除了 <code>OpenCVConfig.cmake</code> 以外<code>OpenCV-config.cmake</code> 这个文件名也会被 CMake 识别到。</p>
<p>同理，<code>find_package(Qt5)</code> 则是会去找名为<code>Qt5Config.cmake</code> 的文件。<br>这些形如 包名 + Config.cmake 的文件，我称之为包配置文件。<br><code>Qt5Config.cmake</code>是你安装 <code>Qt5</code> 时，随 <code>libQt5Core.so</code> 等实际的库文件，一起装到你的系统中去的。以我的 <code>Arch Linux</code> 系统为例：<br>包配置文件位于 <code>/usr/lib/cmake/Qt5/Qt5Config.cmake</code><br>实际的动态库文件位于<code>/usr/lib/libQt5Core.so</code></p>
<ul>
<li>因此 <code>find_package</code> 并不是直接去找具体的动态库文件和头文件（例如  <code>libQt5Core.so</code>）。</li>
<li>而是去找包配置文件（例如Qt5Config.cmake），这个配置文件里包含了包的具体信息，包括动态库文件的位置，头文件的目录，链接时需要开启的编译选项等等。而且某些库都具有多个子动态库，例如 Qt 就有 <code>libQt5Core.so</code>、<code>libQt5Widgets.so</code>、<code>libQt5Network.so</code>。因此 CMake 要求所有第三方库作者统一包装成一个 <code>Qt5Config.cmake</code> 文件包含所有相关信息（类似于 nodejs 的 <code>package.json</code>），比你单独的一个个去找动态库文件要灵活的多。</li>
<li>包配置文件由第三方库的作者（Qt的开发团队）提供，在这个库安装时（Qt的安装程序或apt install等）会自动放到 &#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;XXX&#x2F;XXXConfig.cmake 这个路径（其中XXX是包名），供 CMake 用户找到并了解该包的具体信息。</li>
<li>&#x2F;usr&#x2F;lib&#x2F;cmake 这个位置是 CMake 和第三方库作者约定俗成的，由第三方库的安装程序负责把包配置文件放到这里。如果第三方库的作者比较懒，没提供 CMake 支持（由安装程序提供XXXConfig.cmake），那么得用另外的一套方法（FindXXX.cmake），稍后细谈。</li>
</ul>
<h3 id="Windows-系统下的搜索路径"><a href="#Windows-系统下的搜索路径" class="headerlink" title="Windows 系统下的搜索路径"></a>Windows 系统下的搜索路径</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">
&lt;prefix<span class="token punctuation">></span>/
&lt;prefix<span class="token punctuation">></span>/cmake/
&lt;prefix<span class="token punctuation">></span>/&lt;name<span class="token punctuation">></span>*/
&lt;prefix<span class="token punctuation">></span>/&lt;name<span class="token punctuation">></span>*/cmake/
&lt;prefix<span class="token punctuation">></span>/&lt;name<span class="token punctuation">></span>*/<span class="token punctuation">(</span>lib/&lt;arch<span class="token punctuation">></span>|lib*|share<span class="token punctuation">)</span>/cmake/&lt;name<span class="token punctuation">></span>*/
&lt;prefix<span class="token punctuation">></span>/&lt;name<span class="token punctuation">></span>*/<span class="token punctuation">(</span>lib/&lt;arch<span class="token punctuation">></span>|lib*|share<span class="token punctuation">)</span>/&lt;name<span class="token punctuation">></span>*/
&lt;prefix<span class="token punctuation">></span>/&lt;name<span class="token punctuation">></span>*/<span class="token punctuation">(</span>lib/&lt;arch<span class="token punctuation">></span>|lib*|share<span class="token punctuation">)</span>/&lt;name<span class="token punctuation">></span>*/cmake/

其中 &lt;prefix<span class="token punctuation">></span> 是变量 <span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_PREFIX_PATH</span><span class="token punctuation">&#125;</span>，Windows 平台默认为 C:/Program Files。
&lt;name<span class="token punctuation">></span> 是你在 <span class="token keyword">find_package</span><span class="token punctuation">(</span>&lt;name<span class="token punctuation">></span> REQUIRED<span class="token punctuation">)</span> 命令中指定的包名。
&lt;arch<span class="token punctuation">></span> 是系统的架构名。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Unix-类系统下的搜索路径"><a href="#Unix-类系统下的搜索路径" class="headerlink" title="Unix 类系统下的搜索路径"></a>Unix 类系统下的搜索路径</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&lt;</span>prefix<span class="token operator">></span><span class="token operator">/</span><span class="token punctuation">(</span>lib<span class="token operator">/</span><span class="token operator">&lt;</span>arch<span class="token operator">></span><span class="token operator">|</span>lib<span class="token operator">*</span><span class="token operator">|</span>share<span class="token punctuation">)</span><span class="token operator">/</span>cmake<span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span>
<span class="token operator">&lt;</span>prefix<span class="token operator">></span><span class="token operator">/</span><span class="token punctuation">(</span>lib<span class="token operator">/</span><span class="token operator">&lt;</span>arch<span class="token operator">></span><span class="token operator">|</span>lib<span class="token operator">*</span><span class="token operator">|</span>share<span class="token punctuation">)</span><span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span>
<span class="token operator">&lt;</span>prefix<span class="token operator">></span><span class="token operator">/</span><span class="token punctuation">(</span>lib<span class="token operator">/</span><span class="token operator">&lt;</span>arch<span class="token operator">></span><span class="token operator">|</span>lib<span class="token operator">*</span><span class="token operator">|</span>share<span class="token punctuation">)</span><span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span>cmake<span class="token operator">/</span>
<span class="token operator">&lt;</span>prefix<span class="token operator">></span><span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">(</span>lib<span class="token operator">/</span><span class="token operator">&lt;</span>arch<span class="token operator">></span><span class="token operator">|</span>lib<span class="token operator">*</span><span class="token operator">|</span>share<span class="token punctuation">)</span><span class="token operator">/</span>cmake<span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span>
<span class="token operator">&lt;</span>prefix<span class="token operator">></span><span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">(</span>lib<span class="token operator">/</span><span class="token operator">&lt;</span>arch<span class="token operator">></span><span class="token operator">|</span>lib<span class="token operator">*</span><span class="token operator">|</span>share<span class="token punctuation">)</span><span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span>
<span class="token operator">&lt;</span>prefix<span class="token operator">></span><span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">(</span>lib<span class="token operator">/</span><span class="token operator">&lt;</span>arch<span class="token operator">></span><span class="token operator">|</span>lib<span class="token operator">*</span><span class="token operator">|</span>share<span class="token punctuation">)</span><span class="token operator">/</span><span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token operator">*</span><span class="token operator">/</span>cmake<span class="token operator">/</span>

其中 <span class="token operator">&lt;</span>prefix<span class="token operator">></span> 是变量 $<span class="token punctuation">&#123;</span>CMAKE_PREFIX_PATH<span class="token punctuation">&#125;</span>，Unix 平台默认为 <span class="token operator">/</span>usr。
<span class="token operator">&lt;</span>name<span class="token operator">></span> 是你在 <span class="token function">find_package</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>name<span class="token operator">></span> REQUIRED<span class="token punctuation">)</span> 命令中指定的包名。
<span class="token operator">&lt;</span>arch<span class="token operator">></span> 是系统的架构，例如 x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu 或 i386<span class="token operator">-</span>linux<span class="token operator">-</span>gnu。
（用于伺候 Ubuntu 喜欢把库文件套娃在 <span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu 目录下）
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="举例说明-find-package-搜索路径"><a href="#举例说明-find-package-搜索路径" class="headerlink" title="举例说明 find_package 搜索路径"></a>举例说明 find_package 搜索路径</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 例如你是 64 位的 Linux 系统，find_package(Qt5 REQUIRED) 会依次搜索：</span>
<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>Qt5<span class="token operator">/</span>lib<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>Qt5<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>Qt5<span class="token operator">/</span>share<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>Qt5<span class="token operator">/</span>lib<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>Qt5<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>linux<span class="token operator">-</span>gnu<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>Qt5<span class="token operator">/</span>share<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 例如你是 64 位的 Windows 系统，find_package(Qt5 REQUIRED) 会依次搜索：</span>
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>lib<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>windows<span class="token operator">-</span>gnu<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>share<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>lib<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>lib<span class="token operator">/</span>x86_64<span class="token operator">-</span>windows<span class="token operator">-</span>gnu<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>share<span class="token operator">/</span>Qt5<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//还有一点，&lt;name> 可以有额外后缀，且不分大小写（无论 Linux 还是 Windows），例如：</span>
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>Qt5<span class="token punctuation">.</span><span class="token number">12.1</span><span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
C<span class="token operator">:</span><span class="token operator">/</span>Program Files<span class="token operator">/</span>qt5dnmd<span class="token operator">/</span>cmake<span class="token operator">/</span>Qt5Config<span class="token punctuation">.</span>cmake
同样都是可以被 <span class="token function">find_package</span><span class="token punctuation">(</span>Qt5 REQUIRED<span class="token punctuation">)</span> 搜索到的。
<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>cmake<span class="token operator">/</span>OpenCV<span class="token operator">/</span>OpenCVConfig<span class="token punctuation">.</span>cmake
<span class="token operator">/</span>usr<span class="token operator">/</span>lib<span class="token operator">/</span>cmake<span class="token operator">/</span>opencv4<span class="token operator">/</span>OpenCVConfig<span class="token punctuation">.</span>cmake
同样都是可以被 <span class="token function">find_package</span><span class="token punctuation">(</span>OpenCV REQUIRED<span class="token punctuation">)</span> 搜索到的。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="安装在非标准路径的库"><a href="#安装在非标准路径的库" class="headerlink" title="安装在非标准路径的库"></a>安装在非标准路径的库</h3><p>以 Qt5 为例，如果你安装在下列标准路径，<code>find_package</code> 能够自动找到</p>
<p>Windows：C:&#x2F;Program Files&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake。<br>Linux：&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake。</p>
<p>但是假如我的库不是装在这些标准路径，而是我<strong>自定义的路径，怎么办？</strong></p>
<p>而且即使你不自定义安装路径，Windows 版的 Qt 默认安装就会安装到：<br>C:&#x2F;Qt5.12.1&#x2F;msvc2017_64&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake。</p>
<p>何况我们同学有的还喜欢装到 D 盘去，Windows 是非标准路径的重灾区，他就没有一个统一的 &#x2F;usr&#x2F;lib 目录。然而你一旦把库安装到非标准路径，find_package 是找不到的。</p>
<p>这时你需要手动指定一个变量告诉他在哪儿，可以是普通变量 ${Qt5_DIR}，也可以是环境变量 $ENV{Qt5_DIR}，两个中只要设置了任何一个 find_package 都可以识别到。</p>
<p>变量一般通过命令行 -DQt5_DIR&#x3D;”C:&#x2F;Program Files&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5” 设置。</p>
<h3 id="举例，Windows-系统，Qt5"><a href="#举例，Windows-系统，Qt5" class="headerlink" title="举例，Windows 系统，Qt5"></a>举例，Windows 系统，Qt5</h3><p>例如我把 Qt5 安装到了 D:&#x2F;Qt5.12.1。<br>首先找到他里面的 Qt5Config.cmake 文件所在位置（可以用文件管理器的“搜索”功能）。<br>假如你找到该文件的位置是 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake，那么请你设置变量 Qt5_DIR 为 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5。有三种设置方法：</p>
<p>(1) 单次有效。在 configure 阶段，可以从命令行设置（注意要加引号）：<br>cmake -B build -DQt5_DIR&#x3D;”D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5”<br>(2) 全局启用。右键“我的电脑”-&gt;“管理”-&gt;“高级”添加一个环境变量 Qt5_DIR 值为 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5，然后重启 Visual Studio。这样以后你每次构建任何项目，find_package 都能自动找到这个路径的 Qt5 包了。<br>(3) 单项目有效。直接在你自己项目的 CMakeLists.txt 最开头写一行（注意要加引号）：<br>set(Qt5_DIR ”D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5”)    # 一定要加在最前面！</p>
<h3 id="举例，Linux-系统，Qt5"><a href="#举例，Linux-系统，Qt5" class="headerlink" title="举例，Linux 系统，Qt5"></a>举例，Linux 系统，Qt5</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">例如我把 Qt5 安装到了 /opt/Qt5.<span class="token number">12.1</span>。
首先找到他里面的 Qt5Config.cmake 文件所在位置（可以用文件管理器的“搜索”功能）。
假如你找到该文件的位置是 /opt/Qt5.<span class="token number">12.1</span>/lib/cmake/Qt5/Qt5Config.cmake，那么请你设置变量 Qt5_DIR 为 /opt/Qt5.<span class="token number">12.1</span>/lib/cmake/Qt5。有三种设置方法：
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 单次有效。在 configure 阶段，可以从命令行设置：
cmake -B build -DQt5_DIR=”/opt/Qt5.<span class="token number">12.1</span>/lib/cmake/Qt5”
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> 全局启用。修改你的 ~/.bashrc 文件添加环境变量：
export Qt5_DIR=”/opt/Qt5.<span class="token number">12.1</span>/lib/cmake/Qt5”，然后重启终端。这样以后你每次构建任何项目，find_package 都能自动找到这个路径的 Qt5 包了。
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> 单项目有效。直接在你自己项目的 CMakeLists.txt 最开头写一行：
<span class="token keyword">set</span><span class="token punctuation">(</span>Qt5_DIR ”/opt/Qt5.<span class="token number">12.1</span>/lib/cmake/Qt5”<span class="token punctuation">)</span>    <span class="token comment"># 一定要加在最前面！</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="三种方案利弊分析"><a href="#三种方案利弊分析" class="headerlink" title="三种方案利弊分析"></a>三种方案利弊分析</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">单次有效（通过命令行）最安全，小彭老师高度推荐。

全局有效（添加环境变量）可能影响以后其他项目。比如你 A 项目依赖 Qt5.<span class="token number">12.1</span>，你设置了环境变量 Qt5_DIR=/opt/Qt5.<span class="token number">12.1</span>，后来又搞了个 B 项目依赖 Qt5.<span class="token number">10.3</span>，但是你忘了你设置过全局的环境变量指向 <span class="token number">5.12.1</span> 了，导致版本冲突。

单项目有效（写死在 CMakeLists.txt）虽然方便了你，但是你的 CMakeLists.txt 拿到别人电脑上（例如你通过 GitHub 开源的），可能你 <span class="token keyword">set</span><span class="token punctuation">(</span>Qt5_DIR D:/Qt5<span class="token punctuation">)</span>，而人家却需要 <span class="token keyword">set</span><span class="token punctuation">(</span>Qt5_DIR E:/Qt5<span class="token punctuation">)</span> 呢？就冲突了。

所以“单次有效”虽然劳驾您的高抬贵手每次命令行打一下 -DQt5_DIR=”D:/Qt5”，但人家也打一下 -DQt5_DIR=”E:/Qt5”，就没有冲突，各美其美，美美与共，赋能多元化社会，下沉团队合作发力面。

实际上只要你不删 build，不需要每次都 -DQt5_DIR 一下，CMake 具有“记忆”功能。
cmake -B build -DQt5_DIR=D:/Qt5   <span class="token comment"># 只需要第一次指定好，</span>
cmake -B build                                  <span class="token comment"># 以后第二次运行可以省略！</span>
rm -rf build                                         <span class="token comment"># 只有清理了 build 以后，</span>
cmake -B build -DQt5_DIR=D:/Qt5   <span class="token comment"># 才需要重新指定。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="find-package-的两种模式-—指定使用哪种模式"><a href="#find-package-的两种模式-—指定使用哪种模式" class="headerlink" title="find_package 的两种模式 —指定使用哪种模式"></a>find_package 的两种模式 —指定使用哪种模式</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">find_package</span><span class="token punctuation">(</span>TBB MODULE REQUIRED<span class="token punctuation">)</span>
<span class="token comment"># 只会寻找 FindTBB.cmake，搜索路径：</span>
<span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_MODULE_PATH</span><span class="token punctuation">&#125;</span>（默认为 /usr/share/cmake/Modules）

<span class="token keyword">find_package</span><span class="token punctuation">(</span>TBB CONFIG REQUIRED<span class="token punctuation">)</span>
<span class="token comment"># 只会寻找 TBBConfig.cmake，搜索路径：</span>
<span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_PREFIX_PATH</span><span class="token punctuation">&#125;</span>/lib/cmake/TBB（默认为 /usr/lib/cmake/TBB）
<span class="token punctuation">$&#123;</span>TBB_DIR<span class="token punctuation">&#125;</span> 或 $<span class="token variable">ENV</span>&#123;TBB_DIR<span class="token punctuation">&#125;</span>

<span class="token keyword">find_package</span><span class="token punctuation">(</span>TBB REQUIRED<span class="token punctuation">)</span>
<span class="token comment"># 不指定则两者都会尝试，先尝试 FindTBB.cmake，再尝试 TBBConfig.cmake。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="find-package-命令指定版本"><a href="#find-package-命令指定版本" class="headerlink" title="find_package 命令指定版本"></a>find_package 命令指定版本</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV REQUIRED<span class="token punctuation">)</span>
<span class="token comment"># 查找名为 OpenCV 的包，不限版本，事后可以通过 $&#123;OpenCV_VERSION&#125; 查询找到的版本。</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV <span class="token number">2.0.1</span> REQUIRED<span class="token punctuation">)</span>
<span class="token comment"># 查找版本在 2.0.1 以上的 OpenCV 包（version >= 2.0.1）。</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV <span class="token number">2.0.1</span> EXACT REQUIRED<span class="token punctuation">)</span>
<span class="token comment"># 查找版本刚好为 2.0.1 的 OpenCV 包（version == 2.0.1）。</span>

<span class="token comment"># 如果没写全，则没写的部分默认为 0。例如下列三者等价：</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV <span class="token number">2</span> REQUIRED<span class="token punctuation">)</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV <span class="token number">2.0</span> REQUIRED<span class="token punctuation">)</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV <span class="token number">2.0.0</span> REQUIRED<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装 TBB：</span>
<span class="token builtin class-name">cd</span> tbb
./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/opt/tbbinstalldir
<span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token number">8</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># 在你的项目里使用 TBB：</span>
<span class="token builtin class-name">cd</span> yourapp
cmake <span class="token parameter variable">-B</span> build <span class="token parameter variable">-DTBB_DIR</span><span class="token operator">=</span>/opt/tbbinstalldir/lib/cmake/TBB
cmake <span class="token parameter variable">--build</span> build <span class="token parameter variable">--parallel</span> <span class="token number">8</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># CMakeLists.txt 这样写：</span>

<span class="token keyword">project</span><span class="token punctuation">(</span>yourapp<span class="token punctuation">)</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>yourapp yourmain.cpp<span class="token punctuation">)</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>TBB CONFIG REQUIRED COMPONENTS tbb<span class="token punctuation">)</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>yourapp <span class="token namespace">PUBLIC</span> <span class="token inserted class-name">TBB::tbb</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories"></a>include_directories</h2><ul>
<li><strong>target_include_directories  和 include_directories 区别</strong></li>
<li><code>target_include_directories</code> 命令：<ul>
<li><code>target_include_directories</code> 命令是为指定的目标（target）添加包含目录。</li>
<li>通过 <code>target_include_directories</code> 命令，可以为特定目标（如可执行文件、库或自定义目标）指定包含目录，以便在构建目标时能够找到所需的头文件。</li>
<li>该命令允许为不同的目标设置不同的包含目录，并且可以针对不同的可见性级别（INTERFACE、PUBLIC、PRIVATE）指定包含目录。</li>
<li><code>target_include_directories</code> 命令通常与target_link_libraries一起使用，以确保链接的库能够找到其所需的头文件。</li>
</ul>
</li>
<li><code>include_directories</code>命令：<ul>
<li><code>include_directories</code>命令用于向整个CMake项目添加全局的包含目录。</li>
<li>通过<code>include_directories</code>命令，可以为整个项目指定公共的包含目录，以便在构建过程中所有目标都能够找到所需的头文件。</li>
<li>该命令将包含目录应用于整个项目，对所有目标都具有相同的影响。</li>
<li><code>include_directories</code>命令通常位于CMakeLists.txt文件的顶层，并在添加目标之前调用。</li>
</ul>
</li>
<li>总结<ul>
<li><code>target_include_directories</code> 命令用于为特定目标添加包含目录，允许为不同目标设置不同的包含目录，并支持可见性级别。</li>
<li><code>include_directories</code> 命令用于为整个项目添加全局的包含目录，将包含目录应用于整个项目的所有目标。</li>
</ul>
</li>
</ul>
<h2 id="target-include-directories"><a href="#target-include-directories" class="headerlink" title="target_include_directories"></a>target_include_directories</h2><p>为指定的目标（target）添加包含目录。</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>target_name [SYSTEM] [BEFORE]
    &lt;<span class="token namespace">INTERFACE</span>|<span class="token namespace">PUBLIC</span>|<span class="token namespace">PRIVATE</span><span class="token punctuation">></span> [items1...]
    [&lt;<span class="token namespace">INTERFACE</span>|<span class="token namespace">PUBLIC</span>|<span class="token namespace">PRIVATE</span><span class="token punctuation">></span> [items2...] ...]<span class="token punctuation">)</span>
    

<span class="token function">SET</span> <span class="token punctuation">(</span>EXEC_PREFIX <span class="token string">"szy."</span><span class="token punctuation">)</span>
<span class="token keyword">target_include_directories</span><span class="token punctuation">(</span><span class="token punctuation">$&#123;</span>EXEC_PREFIX<span class="token punctuation">&#125;</span>log_service <span class="token namespace">PRIVATE</span> <span class="token punctuation">$&#123;</span>Protobuf_INCLUDE_DIR<span class="token punctuation">&#125;</span> <span class="token punctuation">$&#123;</span>Qt5Core_INCLUDE_DIRS<span class="token punctuation">&#125;</span> <span class="token punctuation">$&#123;</span>Qt5Sql_INCLUDE_DIRS<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">#$&#123;EXEC_PREFIX&#125; -- 作用就是字符拼接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>target_name是目标的名称，可以是可执行文件、库或自定义目标。</li>
<li>[SYSTEM]是可选参数，用于指定包含目录是否为系统目录。</li>
<li>[BEFORE]也是可选参数，用于指定是否将新的包含目录添加到已有的目录之前。</li>
</ul>
<p>例：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>my_executable main.cpp<span class="token punctuation">)</span>
<span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>my_executable
    <span class="token namespace">PRIVATE</span> include/
    <span class="token namespace">PUBLIC</span> <span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/common/
    <span class="token namespace">INTERFACE</span> <span class="token punctuation">$&#123;</span>Boost_INCLUDE_DIRS<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment"># target_include_directories命令将include/目录添加为my_executable目标的私有包含目录，</span>
<span class="token comment"># $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/common/添加为公共包含目录，</span>
<span class="token comment"># 以及$&#123;Boost_INCLUDE_DIRS&#125;（Boost库的包含目录）添加为接口包含目录。这样，在构建my_executable时，它将能够访问这些包含目录中的头文件。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="link-libraries"><a href="#link-libraries" class="headerlink" title="link_libraries"></a>link_libraries</h2><p>用于指定目标（target）链接的库。</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">link_libraries</span><span class="token punctuation">(</span>library1 library2 ...<span class="token punctuation">)</span>
<span class="token comment"># 其中，library1、library2等是要链接的库的名称或路径。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>link_libraries命令会将指定的库链接到所有后续的目标中，包括在该命令之后创建的目标。</strong></p>
<p><strong>这意味着，在调用link_libraries命令后，所有接下来的add_executable、add_library或自定义目标命令都会自动链接指定的库。</strong></p>
<p>例：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">link_libraries</span><span class="token punctuation">(</span>my_library<span class="token punctuation">)</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>my_executable main.cpp<span class="token punctuation">)</span>
<span class="token comment"># link_libraries命令将名为my_library的库链接到所有后续的目标中。然后，</span>
<span class="token comment"># add_executable命令创建了一个名为my_executable的可执行文件，并自动链接了my_library库。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>请注意，<code>link_libraries</code>命令对于多目标项目可能不够灵活，因为它将指定的库链接到所有目标中，而您可能希望只将特定的库链接到特定的目标。</strong></p>
<p><strong>在这种情况下，建议使用<code>target_link_libraries</code>命令，它允许更精确地指定要链接的库和目标。</strong></p>
<h2 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries"></a>target_link_libraries</h2><p>为指定的目标（target）添加链接的库。</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>target_name
    &lt;<span class="token namespace">PRIVATE</span>|<span class="token namespace">PUBLIC</span>|<span class="token namespace">INTERFACE</span><span class="token punctuation">></span> item1 item2 ...
<span class="token punctuation">)</span>
<span class="token comment"># target_name是目标的名称，可以是可执行文件、库或自定义目标。</span>
<span class="token comment"># PRIVATE、PUBLIC、INTERFACE关键字用于指定后续要链接的库的可见性和属性。</span>

<span class="token comment"># PRIVATE：链接的库只对目标本身可见。</span>
<span class="token comment"># PUBLIC：链接的库对目标本身和依赖于该目标的其他目标可见。</span>
<span class="token comment"># INTERFACE：链接的库不对目标本身可见，但会传递给依赖于该目标的其他目标。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>my_executable main.cpp<span class="token punctuation">)</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>my_executable
    <span class="token namespace">PRIVATE</span> library1
    <span class="token namespace">PUBLIC</span> library2
    <span class="token namespace">INTERFACE</span> library3
<span class="token punctuation">)</span>
<span class="token comment"># target_link_libraries命令将library1库链接为my_executable目标的私有库，</span>
<span class="token comment"># 将library2库链接为公共库，</span>
<span class="token comment"># 将 library3库链接为接口库。这样，在构建my_executable时，它将链接这些库，并与其他目标共享或传递相应的链接库。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="INTERFACE"><a href="#INTERFACE" class="headerlink" title="INTERFACE"></a>INTERFACE</h3><p>假设我们有目标A和目标B。目标A编译成可执行文件，是我们最终要运行的目标。而目标B则编译成目标A的一个依赖，比如说，静态库。</p>
<p>PUBLIC的意思就是 目标B的属性 不仅自己使用，还传递给依赖它的目标A。</p>
<p>PRIVATE的意思就是 目标B的属性 不会传递，只给目标B自己使用。</p>
<p>而INTERFACE则极为特殊：它的属性都 不会自己使用，只传递给目标A。</p>
<p>INTERFACE就是纯粹的利他主义，我自己不用，但我甘于奉献，让别人用。INTERFACE只做个纯粹的“接口”。这类似于电话接线员。接线员不能听到任何信息，他们只是把信息转发给别人。</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_library</span><span class="token punctuation">(</span>Eigen <span class="token namespace">INTERFACE</span><span class="token punctuation">)</span>

<span class="token keyword">target_sources</span><span class="token punctuation">(</span>Eigen <span class="token namespace">INTERFACE</span>
  FILE_SET HEADERS
    BASE_DIRS src
    FILES src/eigen.h src/vector.h src/matrix.h
<span class="token punctuation">)</span>

<span class="token keyword">add_executable</span><span class="token punctuation">(</span>exe1 exe1.cpp<span class="token punctuation">)</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>exe1 Eigen<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里 Eigen库是个header-only的库。</p>
<p>首先我们声明它的可见性为INTERFACE。这表示它自己不会使用自己的任何属性。它只是个接线员。（注意：源文件也可以看做是一种”属性”，因此，Eigen这个库的所有源文件和头文件都不会被它自己使用，所以它不会编译出任何东西）</p>
<p>使用target_souces来指定它的源文件。</p>
<p>最后两行，我们编译出exe1这个可执行目标，然后把Eigen链接到exe1上。</p>
<p>exe1由于引用了Eigen，所以Eigen的所有属性都传递到exe1身上。也就是说，Eigen的所有源码都作为了exe1的源码。</p>
<h2 id="target-sources"><a href="#target-sources" class="headerlink" title="target_sources"></a>target_sources</h2><p>将源文件（源代码文件）添加到指定的目标。</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_sources</span><span class="token punctuation">(</span>target_name
    <span class="token namespace">PRIVATE</span>|<span class="token namespace">PUBLIC</span>|<span class="token namespace">INTERFACE</span>
    [item1 [item2 ...]]
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>target_name是目标的名称，可以是可执行文件、库或自定义目标。</strong>PRIVATE、PUBLIC、INTERFACE关键字用于指定后续源文件的可见性和属性。</p>
<p>PRIVATE：源文件只对目标本身可见。<br>PUBLIC：源文件对目标本身和依赖于该目标的其他目标可见。<br>INTERFACE：源文件不对目标本身可见，但会传递给依赖于该目标的其他目标。</p>
<p>例：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>my_executable<span class="token punctuation">)</span>
<span class="token keyword">target_sources</span><span class="token punctuation">(</span>my_executable
    <span class="token namespace">PRIVATE</span> main.cpp
    <span class="token namespace">PUBLIC</span> utils.cpp
    <span class="token namespace">INTERFACE</span> common.h
<span class="token punctuation">)</span>
<span class="token comment"># target_sources命令将main.cpp源文件添加为my_executable目标的私有源文件，</span>
<span class="token comment"># utils.cpp添加为公共源文件，common.h添加为接口源文件。这样，在构建my_executable时，它将包含这些源文件，并与其他目标共享或传递相应的源文件。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory"></a>aux_source_directory</h2><p><strong>自动搜集需要的文件后缀名</strong></p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>./source DIR_SOURCE_ARMA<span class="token punctuation">)</span>
<span class="token comment"># 表示将./source目录中的所有源文件（.cpp、.c、.cxx等）的列表存储在名为DIR_SOURCE_ARMA的变量中。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB_RECURSE sources CONFIGURE_DEPENDS *.cpp *.h<span class="token punctuation">)</span>
<span class="token comment"># GLOB_RECURSE -- 能自动包含所有子文件夹下的文件</span>


<span class="token comment"># GLOB_RECURSE 的问题：会把 build 目录里生成的临时 .cpp 文件也加进来</span>
解决方案：要么把源码统一放到 src 目录下，要么要求使用者不要把 build 放到和源码同一个目录里，我个人的建议是把源码放到 src 目录下。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties"></a>set_target_properties</h2><p>设置目标属性</p>
<p>该命令的语法是列出想要更改的所有目标，然后提供接下来想要设置的值。您可以使用该命令任何所需的键值对，然后使用<code>get_property()</code>或<code>get_target_property()</code>命令提取它。</p>
<ul>
<li><pre><code class="cmake"># 生成disproto时，输出到指定路径 --  LIBRARY_OUTPUT_DIRECTORY
set_target_properties(disproto PROPERTIES LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)

# 希望 &quot;hello_static&quot; 在输出时，不是&quot;hello_static&quot;，而是以&quot;hello&quot;的名字显示，故设置如下：
SET_TARGET_PROPERTIES (hello_static PROPERTIES OUTPUT_NAME &quot;hello&quot;)

#动态库是应该包含一个版本号的， VERSION指代动态库版本，SOVERSION指代API版本。
 
SET_TARGET_PROPERTIES (hello PROPERTIES VERSION 1.2 SOVERSION 1)
<pre class="line-numbers language-none"><code class="language-none">
- 同样是指定输出目录，但是不同的动态库文件指定不同的输出目录。（静态库和二进制执行文件也是同理）。目标文件可以大致分为三种类型：二进制执行文件、动态库、静态库。保存不同目标文件所用到的属性不一样。具体分类如下。

  RUNTIME_OUTPUT_DIRECTORY：二进制执行文件
  LIBRARY_OUTPUT_DIRECTORY：动态库
  ARCHIVE_OUTPUT_DIRECTORY：静态库

  以保存动态库为例：

  &#96;&#96;&#96;cmake
  # 将动态库 libhello.so 保存到 lib 目录下
  # set_target_properties(hello PROPERTIES LIBRARY_OUTPUT_DIRECTORY &quot;lib&quot;)
   
  # 将目标文件保存到顶层CMakeLists.txt所处目录下的build&#x2F;lib 
  set_target_properties(mul 
      PROPERTIES LIBRARY_OUTPUT_DIRECTORY 
      $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;build&#x2F;lib
  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>指定Debug模式下目标文件名的后缀（DEBUG_POSTFIX）</p>
<p>为了区别不同模式下的不同文件，我们可以指定Debug模式下的目标文件名后缀为 _d，以用于区分 release 模式下生成的目标文件。</p>
<p>命令格式：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">SET_TARGET_PROPERTIES</span> <span class="token punctuation">(</span>&lt;target<span class="token punctuation">></span> <span class="token namespace">PROPERTIES</span> <span class="token property">DEBUG_POSTFIX</span> &lt;suffix_name<span class="token punctuation">></span><span class="token punctuation">)</span>

<span class="token comment"># 指定debug模式下的目标文件名后缀为 _d，即如果是动态库文件，那就是 libhello_d.so</span>
<span class="token function">SET_TARGET_PROPERTIES</span> <span class="token punctuation">(</span>hello <span class="token namespace">PROPERTIES</span> <span class="token property">DEBUG_POSTFIX</span> _d<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>获取属性<br><code>get_target_properties</code> 可以获取到某个目标已有的属性对应的值，并保存到指定变量中。这个属性可以是内置的，也可以是自己创建的。</p>
<p>命令格式：</p>
<p><code>get_target_property(&lt;variable&gt; &lt;target&gt; &lt;target_property&gt;)</code></p>
</li>
</ul>
<h2 id="变量的传播规则：父会传给子"><a href="#变量的传播规则：父会传给子" class="headerlink" title="变量的传播规则：父会传给子"></a>变量的传播规则：父会传给子</h2><ul>
<li>父模块里定义的变量，会传递给子模块。</li>
<li>但是子模块里定义的变量，不会传递给父模块。</li>
<li>如果父模块里本来就定义了同名变量，则离开子模块后仍保持父模块原来设置的值。</li>
<li>可以用 set 的 PARENT_SCOPE 选项，把一个变量传递到上一层作用域（也就是父模块）。</li>
</ul>
<h2 id="静态库循环依赖问题"><a href="#静态库循环依赖问题" class="headerlink" title="静态库循环依赖问题"></a>静态库循环依赖问题</h2><ul>
<li><code>&quot;$&lt;LINK_GROUP:RESCAN,$&#123;MODUO_LIBS&#125;&gt;&quot;</code></li>
</ul>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>
dlogdb
<span class="token namespace">PRIVATE</span> scdb
        <span class="token string">"$&lt;LINK_GROUP:RESCAN,<span class="token interpolation"><span class="token punctuation">$&#123;</span><span class="token variable">MODUO_LIBS</span><span class="token punctuation">&#125;</span></span>>"</span>
        <span class="token inserted class-name">Boost::system</span>
        <span class="token inserted class-name">Boost::filesystem</span>
        glog
        Qt5Core
        Qt5Sql
        pthread
        proto
        faiss
        <span class="token inserted class-name">CUDA::cuda_driver</span>
        <span class="token inserted class-name">CUDA::cudart</span>
        <span class="token punctuation">$&#123;</span>cityhash_LIRARIES<span class="token punctuation">&#125;</span>
        <span class="token punctuation">$&#123;</span>facerec_LIBRARIES<span class="token punctuation">&#125;</span>
        <span class="token punctuation">$&#123;</span>Protobuf_LIBRARIES<span class="token punctuation">&#125;</span>
        <span class="token punctuation">$&#123;</span>OpenCV_LIBRARIES<span class="token punctuation">&#125;</span>
       <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>这里muduo_lib有循环依赖的问题[cmake]<a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/variable/CMAKE_LINK_GROUP_USING_FEATURE.html">https://cmake.org/cmake/help/latest/variable/CMAKE_LINK_GROUP_USING_FEATURE.html</a></p>
</li>
<li><p><code>set_property(TARGET $&#123;COMPONENT_LIB&#125; APPEND PROPERTY LINK_INTERFACE_MULTIPLICITY 3)</code></p>
</li>
</ul>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/2024/01/05/%E9%9F%B3%E8%A7%86%E9%A2%91/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/YUV%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D/">YUV格式介绍</a></li>
                
                
                    <li>下一篇: <a href="/2024/01/02/cpp/practice/%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">对象生命周期</a></li>
                
            </ul>
        </section>
        
            <section class="post-tags">
            <a class="-none-link" href="/tags/cmake/" rel="tag">cmake</a>
            </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://sdn.geekzu.org/avatar/d22eb460ecab37fcd7205e6a3c55c228?s=200&r=X&d=" alt="木偶人" />
            </figure>
        
            <div class="author-info">
                <h4>木偶人</h4>
                <p>...</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/01/17/FFmpeg/ffmepg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">ffmepg常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/05/%E9%9F%B3%E8%A7%86%E9%A2%91/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/YUV%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D/">YUV格式介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/04/cmake/cmake/">cmake</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/02/cpp/practice/%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">对象生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/22/cpp/c++11/%E5%B0%8F%E5%B0%8F%E7%9A%84operator-%E7%AB%9F%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%BB%86%E8%8A%82/">小小的operator=竟有这么多细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/19/my_stl/vector/">自己实现STL之vector</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-date">时光机：</h3>
                    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-tags">标签云：</h3>
                    <a href="/tags/FFmpeg/" style="font-size: 16px;">FFmpeg</a> <a href="/tags/FFplay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 14px;">FFplay源码分析</a> <a href="/tags/c/" style="font-size: 12px;">c++</a> <a href="/tags/c-11/" style="font-size: 14px;">c++11</a> <a href="/tags/c-17/" style="font-size: 10px;">c++17</a> <a href="/tags/c-20/" style="font-size: 10px;">c++20</a> <a href="/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/tags/error/" style="font-size: 12px;">error</a> <a href="/tags/leetcode/" style="font-size: 18px;">leetcode</a> <a href="/tags/muduo/" style="font-size: 10px;">muduo</a> <a href="/tags/my-stl/" style="font-size: 10px;">my_stl</a> <a href="/tags/plan/" style="font-size: 10px;">plan</a> <a href="/tags/sylar/" style="font-size: 20px;">sylar</a> <a href="/tags/vscode/" style="font-size: 10px;">vscode</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">音视频基础知识</a>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2024 <a href="/">木偶人</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":true,"night":true});</script>

  </body>
</html>
