<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>协程模块 - 木偶人</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="木偶人">
    <meta property="og:title" content="协程模块"/>
    
    <style>body:before{ content: ''; background-image: url(https://api.paugram.com/wallpaper?source=gh) }</style>
    
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <header>
    <div class="head-title">
        <h4>木偶人</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        <div class="has-child">
            <a>分类</a>
            <div class="sub-menu">
                <a class="category-link" href="/categories/c/">c++</a><a class="category-link" href="/categories/sylar/">sylar</a>
            </div>
        </div>
        
            <a href="/about">关于我</a>
        
            <a href="/friends">朋友们</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>协程模块</h2>
            <div class="post-meta">
                <time class="date">2023.10.16</time>
            
                <span class="category"><a class="category-link" href="/categories/sylar/">sylar</a></span>
            
            </div>
        </section>
        <article class="post-content">
        
            <h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><strong>协程和线程的区别</strong><br>协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。</p>
<p>其实这点也好理解，毕竟协程只是以一种花里胡哨的方式去运行一个函数，不管实现得如何巧妙，也不可能在单线程里做到同时运行两个函数，否则还要多线程有何用？</p>
<p>因为单线程下协程并不是并发执行，而是顺序执行的，所以不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。</p>
<p>同样是单线程环境下，协程的yield和resume一定是同步进行的，一个协程的yield，必然对应另一个协程的resume，因为线程不可能没有执行主体。</p>
<p>并且，协程的yield和resume是完全由应用程序来控制的。与线程不同，线程创建之后，线程的运行和调度也是由操作系统自动完成的，但协程创建后，协程的运行和调度都要由应用程序来完成，就和调用函数一样，所以协程也被称为用户态线程。</p>
<ul>
<li>所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；</li>
<li>所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；</li>
<li>所谓定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 上下文结构体定义</span>
<span class="token comment">// 这个结构体是平台相关的，因为不同平台的寄存器不一样</span>
<span class="token comment">// 下面列出的是所有平台都至少会包含的4个成员</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ucontext_t</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效</span>
    <span class="token keyword">struct</span> <span class="token class-name">ucontext_t</span> <span class="token operator">*</span>uc_link<span class="token punctuation">;</span>
    <span class="token comment">// 当前上下文的信号屏蔽掩码</span>
    sigset_t          uc_sigmask<span class="token punctuation">;</span>
    <span class="token comment">// 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效</span>
    stack_t           uc_stack<span class="token punctuation">;</span>
    <span class="token comment">// 平台相关的上下文具体内容，包含寄存器的值</span>
    mcontext_t        uc_mcontext<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span> ucontext_t<span class="token punctuation">;</span>
 
<span class="token comment">// 获取当前的上下文</span>
<span class="token keyword">int</span> <span class="token function">getcontext</span><span class="token punctuation">(</span>ucontext_t <span class="token operator">*</span>ucp<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数</span>
<span class="token keyword">int</span> <span class="token function">setcontext</span><span class="token punctuation">(</span><span class="token keyword">const</span> ucontext_t <span class="token operator">*</span>ucp<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，</span>
<span class="token comment">// 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间，</span>
<span class="token comment">// 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文，</span>
<span class="token comment">// 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了</span>
<span class="token comment">// makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行</span>
<span class="token keyword">void</span> <span class="token function">makecontext</span><span class="token punctuation">(</span>ucontext_t <span class="token operator">*</span>ucp<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，</span>
<span class="token comment">// 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数</span>
<span class="token comment">// swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换</span>
<span class="token keyword">int</span> <span class="token function">swapcontext</span><span class="token punctuation">(</span>ucontext_t <span class="token operator">*</span>oucp<span class="token punctuation">,</span> <span class="token keyword">const</span> ucontext_t <span class="token operator">*</span>ucp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>sylar使用非对称协程模型，也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。</p>
<p><img src="image.png" alt="Alt text"><br>sylar借助了线程局部变量的功能来实现协程模块。线程局部变量与全局变量类似，不同之处在于声明的线程局部变量在每个线程都独有一份，而全局变量是全部线程共享一份。</p>
<p>sylar使用线程局部变量（C++11 thread_local变量）来保存协程上下文对象，这点很好理解，因为协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。</p>
<p>对于每个线程的协程上下文，sylar设计了两个线程局部变量来存储上下文信息（对应源码的t_fiber和t_thread_fiber），也就是说，一个线程在任何时候最多只能知道两个协程的上下文。又由于sylar只使用swapcontext来做协程切换，那就意味着，这两个线程局部变量必须至少有一个是用来保存线程主协程的上下文的，如果这两个线程局部变量存储的都是子协程的上下文，那么不管怎么调用swapcontext，都没法恢复主协程的上下文，也就意味着程序最终无法回到主协程去执行，程序也就跑飞了。</p>
<h2 id="sylar协程模块实现"><a href="#sylar协程模块实现" class="headerlink" title="sylar协程模块实现"></a>sylar协程模块实现</h2><h3 id="协程状态"><a href="#协程状态" class="headerlink" title="协程状态"></a>协程状态</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">/// 初始化状态</span>
  INIT<span class="token punctuation">,</span>
  <span class="token comment">/// 暂停状态</span>
  HOLD<span class="token punctuation">,</span>
  <span class="token comment">/// 执行中状态</span>
  EXEC<span class="token punctuation">,</span>
  <span class="token comment">/// 结束状态</span>
  TERM<span class="token punctuation">,</span>
  <span class="token comment">/// 可执行状态</span>
  READY<span class="token punctuation">,</span>
  <span class="token comment">/// 异常状态</span>
  EXCEPT
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="协程原语"><a href="#协程原语" class="headerlink" title="协程原语"></a>协程原语</h3><p>对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume(swapIn)，表示恢复协程运行，一种是yield(swapOut)，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。</p>
<h3 id="协程类实现"><a href="#协程类实现" class="headerlink" title="协程类实现"></a>协程类实现</h3><p>sylar的协程通过Fiber类来表示，这个类包含以下成员变量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// 协程id</span>
<span class="token keyword">uint64_t</span> m_id        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">/// 协程栈大小</span>
<span class="token keyword">uint32_t</span> m_stacksize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">/// 协程状态</span>
State m_state        <span class="token operator">=</span> READY<span class="token punctuation">;</span>
<span class="token comment">/// 协程上下文</span>
ucontext_t m_ctx<span class="token punctuation">;</span>
<span class="token comment">/// 协程栈地址</span>
<span class="token keyword">void</span> <span class="token operator">*</span>m_stack <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token comment">/// 协程入口函数</span>
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> m_cb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Fiber的源码定义了两个全局静态变量，用于生成协程id和统计当前的协程数，如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// 全局静态变量，用于生成协程id</span>
<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span> s_fiber_id<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">/// 全局静态变量，用于统计当前的协程数</span>
<span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">></span> s_fiber_count<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后是线程局部变量，对于每个线程，sylar设计了以下两个线程局部变量用于保存协程上下文信息：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// 线程局部变量，每个线程独有一份，当前线程正在运行的协程</span>
<span class="token keyword">static</span> <span class="token keyword">thread_local</span> Fiber <span class="token operator">*</span>t_fiber <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

<span class="token comment">/// 线程局部变量，每个线程独有一份，当前线程的主协程，切换到这个协程，就相当于切换到了主协程中运行，智能指针形式</span>
<span class="token keyword">static</span> <span class="token keyword">thread_local</span> Fiber<span class="token double-colon punctuation">::</span>ptr t_threadFiber <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这两个线程局部变量保存的协程上下文对协程的实现至关重要，它们的用途如下：</p>
<p>t_fiber：保存当前正在运行的协程指针，必须时刻指向当前正在运行的协程对象。协程模块初始化时，t_fiber指向线程主协程对象。</p>
<p>t_thread_fiber：保存线程主协程指针，智能指针形式。协程模块初始化时，t_thread_fiber指向线程主协程对象。当子协程resume时，通过swapcontext将主协程的上下文保存到t_thread_fiber的ucontext_t成员中，同时激活子协程的ucontext_t上下文。当子协程yield时，从t_thread_fiber中取得主协程的上下文并恢复运行。</p>
<p><strong>协程类Fiber的成员方法</strong><br>首先是协程的构建函数。Fiber类提供了两个构造函数，带参数的构造函数用于构造子协程，初始化子协程的ucontext_t上下文协和栈空间，要求必须传入协程的入口函数，以及可选的协程栈大小。不带参的构造函数用于初始化当前线程的协程功能，构造线程主协程对象，以及对t_fiber和t_thread_fiber进行赋值。</p>
<p>这个构造函数被定义成私有方法，不允许在类外部调用，只能通过GetThis()方法，在返回当前正在运行的协程时，如果发现当前线程的主程未被初始化，那就用不带参的构造函数初始化线程主协程。<br>因为GetThis()兼具初始化主协程的功能，在使用协程之前必须显式调用一次GetThis()。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/**
 * @brief 构造函数
 * @attention 无参构造函数只用于创建线程的第一个协程，也就是线程主函数对应的协程，
 * 这个协程只能由GetThis()方法调用，所以定义成私有方法
 */</span>
<span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">Fiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  m_state <span class="token operator">=</span> EXEC<span class="token punctuation">;</span>
  <span class="token comment">// 设置当前正在运行的协程</span>
  <span class="token function">SetThis</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"getcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token operator">++</span>s_fiber_count<span class="token punctuation">;</span>

  <span class="token function">SYLAR_LOG_DEBUG</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Fiber::Fiber main"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * @brief 构造函数，用于创建用户协程
 * @param[] cb 协程入口函数
 * @param[] stacksize 栈大小，默认为128k
 */</span>
<span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">Fiber</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> cb<span class="token punctuation">,</span> size_t stacksize<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">m_id</span><span class="token punctuation">(</span>s_fiber_id<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">m_cb</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">++</span>s_fiber_count<span class="token punctuation">;</span>
    m_stacksize <span class="token operator">=</span> stacksize <span class="token operator">?</span> stacksize <span class="token operator">:</span> g_fiber_stack_size<span class="token operator">-></span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m_stack     <span class="token operator">=</span> <span class="token class-name">StackAllocator</span><span class="token double-colon punctuation">::</span><span class="token function">Alloc</span><span class="token punctuation">(</span>m_stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"getcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    m_ctx<span class="token punctuation">.</span>uc_link          <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    m_ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_sp   <span class="token operator">=</span> m_stack<span class="token punctuation">;</span>
    m_ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_size <span class="token operator">=</span> m_stacksize<span class="token punctuation">;</span>
 
    <span class="token function">makecontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Fiber<span class="token double-colon punctuation">::</span>MainFunc<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">SYLAR_LOG_DEBUG</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Fiber::Fiber() id = "</span> <span class="token operator">&lt;&lt;</span> m_id<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * @brief 返回当前线程正在执行的协程
 * @details 如果当前线程还未创建协程，则创建线程的第一个协程，
 * 且该协程为当前线程的主协程，其他协程都通过这个协程来调度，也就是说，其他协程
 * 结束时,都要切回到主协程，由主协程重新选择新的协程进行resume
 * @attention 线程如果要创建协程，那么应该首先执行一下Fiber::GetThis()操作，以初始化主函数协程
 */</span>
Fiber<span class="token double-colon punctuation">::</span>ptr <span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t_fiber<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> t_fiber<span class="token operator">-></span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    Fiber<span class="token double-colon punctuation">::</span>ptr <span class="token function">main_fiber</span><span class="token punctuation">(</span><span class="token keyword">new</span> Fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>t_fiber <span class="token operator">==</span> main_fiber<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t_thread_fiber <span class="token operator">=</span> main_fiber<span class="token punctuation">;</span>
    <span class="token keyword">return</span> t_fiber<span class="token operator">-></span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>接下来是协程原语的实现，也就是resume和yield</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 切换到当前协程执行</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">swapIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">SetThis</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>m_state <span class="token operator">!=</span> EXEC<span class="token punctuation">)</span><span class="token punctuation">;</span>
  m_state <span class="token operator">=</span> EXEC<span class="token punctuation">;</span>
  <span class="token comment">// 取当前协程的主协程，自己swap自己，会死锁，所以建立了call</span>
  <span class="token comment">// 这里的GetMainFiber--->是指向run函数的那个fiber</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetMainFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"swapcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
* @brief 将当前线程切换到执行状态
* @pre 执行的为当前线程的主协程
*/</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">SetThis</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  m_state <span class="token operator">=</span> EXEC<span class="token punctuation">;</span>
  <span class="token comment">// 和swapIn 的区别-->线程中的主协程-->t_threadFiber</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t_threadFiber<span class="token operator">-></span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"swapcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 把当前协程切换到后台,调度协程换出来执行</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">swapOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">SetThis</span><span class="token punctuation">(</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetMainFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetMainFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"swapcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>   

<span class="token comment">/**
* @brief 将当前线程切换到后台
* @pre 执行的为该协程
* @post 返回到线程的主协程
*/</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SetThis</span><span class="token punctuation">(</span>t_threadFiber<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t_threadFiber<span class="token operator">-></span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"swapcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在非对称协程里，执行swapIn时的当前执行环境一定是位于线程主协程里，所以这里的swapcontext操作的结果把主协程的上下文保存到t_thread_fiber-&gt;m_ctx中，并且激活子协程的上下文；而执行swapOut时，当前执行环境一定是位于子协程里，所以这里的swapcontext操作的结果是把子协程的上下文保存到协程自己的m_ctx中，同时从t_thread_fiber获得主协程的上下文并激活。</p>
<p><strong>协程入口函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 线程的主协程(调度协程)不会进入到MainFunc中,</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">MainFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Fiber<span class="token double-colon punctuation">::</span>ptr cur <span class="token operator">=</span> <span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// GetThis()的shared_from_this()方法让引用计数加1</span>
    <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        cur<span class="token operator">-></span><span class="token function">m_cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这里真正执行协程的入口函数</span>
        cur<span class="token operator">-></span>m_cb <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        cur<span class="token operator">-></span>m_state <span class="token operator">=</span> TERM<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cur<span class="token operator">-></span>m_state <span class="token operator">=</span> EXCEPT<span class="token punctuation">;</span>
        <span class="token function">SYLAR_LOG_ERROR</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Fiber Except: "</span> <span class="token operator">&lt;&lt;</span> ex<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;&lt;</span> <span class="token string">" fiber_id="</span> <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl
            <span class="token operator">&lt;&lt;</span> sylar<span class="token double-colon punctuation">::</span><span class="token function">BacktraceToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cur<span class="token operator">-></span>m_state <span class="token operator">=</span> EXCEPT<span class="token punctuation">;</span>
        <span class="token function">SYLAR_LOG_ERROR</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Fiber Except"</span>
            <span class="token operator">&lt;&lt;</span> <span class="token string">" fiber_id="</span> <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl
            <span class="token operator">&lt;&lt;</span> sylar<span class="token double-colon punctuation">::</span><span class="token function">BacktraceToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">auto</span> raw_ptr <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 手动让t_fiber的引用计数减1</span>
    cur<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    raw_ptr<span class="token operator">-></span><span class="token function">swapOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 协程结束时自动swapOut，以回到主协程(调度协程)</span>

    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"never reach fiber_id="</span> <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>raw_ptr<span class="token operator">-></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">CallerMainFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  Fiber<span class="token double-colon punctuation">::</span>ptr cur <span class="token operator">=</span> <span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// GetThis()的shared_from_this()方法让引用计数加1</span>
  <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    cur<span class="token operator">-></span><span class="token function">m_cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cur<span class="token operator">-></span>m_cb <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    cur<span class="token operator">-></span>m_state <span class="token operator">=</span> TERM<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception <span class="token operator">&amp;</span>ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    cur<span class="token operator">-></span>m_state <span class="token operator">=</span> EXCEPT<span class="token punctuation">;</span>
    <span class="token function">SYLAR_LOG_ERROR</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Fiber Except: "</span> <span class="token operator">&lt;&lt;</span> ex<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" fiber_id="</span> <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                              <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl
                              <span class="token operator">&lt;&lt;</span> sylar<span class="token double-colon punctuation">::</span><span class="token function">BacktraceToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    cur<span class="token operator">-></span>m_state <span class="token operator">=</span> EXCEPT<span class="token punctuation">;</span>
    <span class="token function">SYLAR_LOG_ERROR</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Fiber Except"</span>
                              <span class="token operator">&lt;&lt;</span> <span class="token string">" fiber_id="</span> <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl
                              <span class="token operator">&lt;&lt;</span> sylar<span class="token double-colon punctuation">::</span><span class="token function">BacktraceToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">auto</span> raw_ptr <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 手动让t_fiber的引用计数减1</span>
  cur<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 和MianFunc的区别</span>
  raw_ptr<span class="token operator">-></span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 协程结束时自动swapOut，这里回到主线程(main)的主协程</span>

  <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"never reach fiber_id="</span> <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>raw_ptr<span class="token operator">-></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>协程的重置，重置协程就是重复利用已结束的协程，复用其栈空间，创建新协程，实现如下：</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//重置协程函数，并重置状态</span>
<span class="token comment">// INIT，TERM, EXCEPT,都可以进行重置</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">reset</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>m_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>m_state <span class="token operator">==</span> TERM <span class="token operator">||</span> m_state <span class="token operator">==</span> EXCEPT <span class="token operator">||</span> m_state <span class="token operator">==</span> INIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
  m_cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"getcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  m_ctx<span class="token punctuation">.</span>uc_link <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  m_ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_sp <span class="token operator">=</span> m_stack<span class="token punctuation">;</span>
  m_ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_size <span class="token operator">=</span> m_stacksize<span class="token punctuation">;</span>

  <span class="token function">makecontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Fiber<span class="token double-colon punctuation">::</span>MainFunc<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  m_state <span class="token operator">=</span> INIT<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>其他实现细节</strong></p>
<p>关于协程id。sylar通过全局静态变量s_fiber_id的自增来生成协程id，每创建一个新协程，s_fiber_id自增1，并作为新协程的id（实际是先取值，再自增1）。</p>
<p>关于线程主协程的构建。线程主协程代表线程入口函数或是main函数所在的协程，这两种函数都不是以协程的手段创建的，所以它们只有ucontext_t上下文，但没有入口函数，也没有分配栈空间。</p>
<p>关于协程切换。子协程的resume操作一定是在主协程里执行的，主协程的resume操作一定是在子协程里执行的，这点完美和swapcontext匹配，参考上面协程原语的实现。</p>
<p>关于智能指针的引用计数，由于t_fiber和t_thread_fiber一个是原始指针一个是智能指针，混用时要注意智能指针的引用计数问题，不恰当的混用可能导致协程对象已经运行结束，但未析构问题。关于协程对象的智能指针引用计数跟踪可参考test_fiber.cc。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060957">https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060957</a></p>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/2023/10/17/sylar/scheduler/">协程调度模块</a></li>
                
                
                    <li>下一篇: <a href="/2023/10/14/sylar/backtrace/">backtrace</a></li>
                
            </ul>
        </section>
        
            <section class="post-tags">
            <a class="-none-link" href="/tags/sylar/" rel="tag">sylar</a>
            </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://sdn.geekzu.org/avatar/d22eb460ecab37fcd7205e6a3c55c228?s=200&r=X&d=" alt="木偶人" />
            </figure>
        
            <div class="author-info">
                <h4>木偶人</h4>
                <p>...</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/10/22/error/error-template-with-C-linkage/">error: template with C linkage</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/20/sylar/%E5%85%B3%E4%BA%8E-C-%E4%B8%AD%E7%9A%84-extern-C/">关于 C++ 中的 extern "C"</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/19/sylar/set%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0/">set自定义比较函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/17/sylar/scheduler/">协程调度模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/16/sylar/%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97/">协程模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/14/sylar/backtrace/">backtrace</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-date">时光机：</h3>
                    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-tags">标签云：</h3>
                    <a href="/tags/c-11/" style="font-size: 16.67px;">c++11</a> <a href="/tags/error/" style="font-size: 13.33px;">error</a> <a href="/tags/muduo/" style="font-size: 10px;">muduo</a> <a href="/tags/plan/" style="font-size: 10px;">plan</a> <a href="/tags/sylar/" style="font-size: 20px;">sylar</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2023 <a href="/">木偶人</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":true,"night":true});</script>

  </body>
</html>
