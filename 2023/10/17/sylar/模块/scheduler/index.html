<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>协程调度模块 - 木偶人</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="木偶人">
    <meta property="og:title" content="协程调度模块"/>
    
    <style>body:before{ content: ''; background-image: url(https://api.paugram.com/wallpaper?source=gh) }</style>
    
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <header>
    <div class="head-title">
        <h4>木偶人</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        <div class="has-child">
            <a>分类</a>
            <div class="sub-menu">
                <a class="category-link" href="/categories/FFmpeg/">FFmpeg</a><a class="category-link" href="/categories/c/">c++</a><a class="category-link" href="/categories/cmake/">cmake</a><a class="category-link" href="/categories/sylar/">sylar</a>
            </div>
        </div>
        
            <a href="/about">关于我</a>
        
            <a href="/friends">朋友们</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>协程调度模块</h2>
            <div class="post-meta">
                <time class="date">2023.10.17</time>
            
                <span class="category"><a class="category-link" href="/categories/sylar/">sylar</a></span>
            
            </div>
        </section>
        <article class="post-content">
        
            <p>协程调度最难理解的地方是当caller线程也参与调度时调度协程和主线程切换的情况，注意对照源码进行理解。</p>
<h2 id="协程调度器"><a href="#协程调度器" class="headerlink" title="协程调度器"></a>协程调度器</h2><p>当你有很多协程时，如何把这些协程都消耗掉，这就是协程调度。<br>引入协程调度后，则可以先创建一个协程调度器，然后把这些要调度的协程传递给调度器，由调度器负责把这些协程一个一个消耗掉。</p>
<p><strong>调度任务的定义</strong><br>对于协程调度器来说，协程当然可以作为调度任务，但实际上，函数也应可以，因为函数也是可执行的对象，调度器应当支持直接调度一个函数。这在代码实现上也很简单，只需要将函数包装成协程即可，协程调度器的实现重点还是以协程为基础。</p>
<p><strong>多线程</strong>，通过前面协程模块的知识我们可以知道，<strong>一个线程同一时刻只能运行一个协程</strong>，所以，作为协程调度器，势必要用到多线程来提高调度的效率，因为有多个线程就意味着有多个协程可以同时执行，这显然是要好过单线程的。</p>
<p>既然多线程可以提高协程调度的效率，那么，能不能把调度器所在的线程（称为caller线程）也加入进来作为调度线程呢？<br>比如典型地，在main函数中定义的调度器，能不能把main函数所在的线程也用来执行调度任务呢？答案是肯定的，在实现相同调度能力的情况下（指能够同时调度的协程数量），线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。<br>甚至，调度器完全可以不创建新的线程，而只使用caller线程来进行协程调度，比如只使用main函数所在的线程来进行协程调度。</p>
<p><strong>调度器如何运行</strong><br>这里可以简单地认为，调度器创建后，内部首先会创建一个调度线程池，调度开始后，所有调度线程按顺序从任务队列里取任务执行，调度线程数越多，能够同时调度的任务也就越多，当所有任务都调度完后，调度线程就停下来等新的任务进来。</p>
<p><strong>添加调度任务</strong><br>添加调度任务的本质就是往调度器的任务队列里塞任务，但是，只添加调度任务是不够的，还应该有一种方式用于通知调度线程有新的任务加进来了，因为调度线程并不一定知道有新任务进来了。当然调度线程也可以不停地轮询有没有新任务，但是这样CPU占用率会很高。</p>
<p><strong>调度器的停止</strong><br>调度器应该支持停止调度的功能，以便回收调度线程的资源，只有当所有的调度线程都结束后，调度器才算真正停止。</p>
<p><strong>通过上面的描述，一个协程调度器的大概设计也就出炉了：</strong><br>调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。调度线程可以包含caller线程。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。</p>
<p><strong>scheduler</strong></p>
<ul>
<li>封装的是N-M的协程调度器</li>
<li>内部有一个线程池,支持协程在线程池里面切换</li>
</ul>
<hr>
<h2 id="sylar协程调度模块设计"><a href="#sylar协程调度模块设计" class="headerlink" title="sylar协程调度模块设计"></a>sylar协程调度模块设计</h2><blockquote>
<p>sylar的协程调度模块支持多线程，支持使用caller线程进行调度，支持添加函数或协程作为调度对象，并且支持将函数或协程绑定到一个具体的线程上执行。</p>
</blockquote>
<p><strong>协程调度器的初始化</strong><br>sylar的协程调度器在初始化时支持传入线程数和一个布尔型的<strong>use_caller</strong>参数，表示是否使用caller线程。在<strong>使用caller线程的情况下，线程数自动减一，并且调度器内部会初始化一个属于caller线程的调度协程并保存起来（比如，在main函数中创建的调度器，如果use_caller为true，那调度器会初始化一个属于main函数线程的调度协程）。</strong></p>
<p><strong>添加调度任务</strong><br>调度器创建好后，即可调用调度器的<strong>schedule</strong>方法向调度器添加调度任务，但此时调度器并不会立刻执行这些任务，而是将它们保存到内部的一个任务队列中。</p>
<p><strong>启动调度</strong><br>start方法调用后会创建调度线程池，线程数量由初始化时的线程数和use_caller确定。调度线程一旦创建，就会立刻从任务队列里取任务执行。比较特殊的一点是，如果初始化时指定线程数为1且use_caller为true，那么start方法什么也不做，因为不需要创建新线程用于调度。并且，由于没有创建新的调度线程，那只能由caller线程的调度协程来负责调度协程，而caller线程的调度协程的执行时机与start方法并不在同一个地方。</p>
<p><strong>调度协程</strong><br>对应run方法。调度协程负责从调度器的任务队列中取任务执行。取出的任务即子协程，这里调度协程和子协程的切换模型即为前一章介绍的非对称模型，每个子协程执行完后都必须返回调度协程，由调度协程重新从任务队列中取新的协程并执行。如果任务队列空了，那么调度协程会切换到一个idle协程，这个idle协程什么也不做，等有新任务进来时，idle协程才会退出并回到调度协程，重新开始下一轮调度。</p>
<p>这里有点绕，细细体会。<br><strong>在非caller线程里</strong>，<strong>调度协程就是执行此调度的线程中的主协程</strong>，<strong>但在caller线程里，调度协程并不是caller线程的主协程，而是相当于caller线程的子协程</strong>，这在协程切换时会有大麻烦（这点是sylar协程调度模块最难理解的地方），如何处理这个问题将在下面的章节专门进行讨论。</p>
<p><strong>添加调度任务</strong><br>对应schedule方法，这个方法支持传入协程或函数，并且支持一个线程号参数，表示是否将这个协程或函数绑定到一个具体的线程上执行。如果任务队列为空，那么在添加任务之后，要调用一次tickle方法以通知各调度线程的调度协程有新任务来了。</p>
<p><strong>子协程中创建并运行新的子协程</strong><br>在执行调度任务时，还可以通过调度器的GetThis()方法获取到当前调度器，再通过schedule方法继续添加新的任务，这就变相实现了在子协程中创建并运行新的子协程的功能。</p>
<p><strong>调度器的停止</strong></p>
<ul>
<li>首先是use_caller为false的情况，这种情况下，由于没有使用caller线程进行调度，那么只需要简单地等各个调度线程的调度协程退出就行了。</li>
<li>如果use_caller为true，表示caller线程也要参于调度，这时，调度器初始化时记录的属于caller线程的调度协程就要起作用了，在调度器停止前，应该让这个caller线程的调度协程也运行一次，让caller线程完成调度工作后再退出。如果调度器只使用了caller线程进行调度，那么所有的调度任务要在调度器停止时才会被调度。</li>
</ul>
<h2 id="调度协程切换问题"><a href="#调度协程切换问题" class="headerlink" title="调度协程切换问题"></a>调度协程切换问题</h2><ol>
<li>线程数为1，且use_caller为false，对应额外创建一个线程进行协程调度、main函数线程不参与调度的情况。</li>
<li>线程数为1，且use_caller为true，对应只使用main函数线程进行协程调度的情况。</li>
</ol>
<p>解决单线程环境下caller线程主协程-调度协程-任务协程之间的上下文切换，是sylar协程调度实现的关键。</p>
<p><strong>第一种情况</strong><br>因为有单独的线程用于协程调度，那只需要让新线程的入口函数作为调度协程，从任务队列里取任务执行就行了，main函数与调度协程完全不相关，main函数只需要向调度器添加任务，然后在适当的时机停止调度器即可。当调度器停止时，main函数要等待调度线程结束后再退出，参考下面的图示：</p>
<p><img src="/../../../images/schedule_user_call_false.drawio.png" alt="Alt text"></p>
<p><strong>第二种情况</strong><br>因为没有额外的线程进行协程调度，那只能用main函数所在的线程来进行调度，而梳理一下main函数线程要运行的协程，会发现有以下三类协程：</p>
<ol>
<li><p>main函数对应的主协程</p>
</li>
<li><p>调度协程</p>
</li>
<li><p>待调度的任务协程</p>
</li>
</ol>
<p>在main函数线程里这三类协程运行的顺序是这样的：</p>
<ol>
<li><p>main函数主协程运行，创建调度器</p>
</li>
<li><p>仍然是main函数主协程运行，向调度器添加一些调度任务</p>
</li>
<li><p>开始协程调度，main函数主协程让出执行权，切换到调度协程，调度协程从任务队列里按顺序执行所有的任务</p>
</li>
<li><p>每次执行一个任务，调度协程都要让出执行权，再切到该任务的协程里去执行，任务执行结束后，还要再切回调度协程，继续下一个任务的调度</p>
</li>
<li><p>所有任务都执行完后，调度协程还要让出执行权并切回main函数主协程，以保证程序能顺利结束。</p>
</li>
</ol>
<ul>
<li>这里t_scheduler_fiber(m_rootFiber)是main函数中的调度协程，<strong>注意这个协程不是主协程</strong>。主协程是t_threadFiber，后续还需要t_threadFiber切换回main，这里这里的操作主要是解决程序跑飞问题。<br>上面的过程也可以总结为：main函数先攒下一波协程，然后切到调度协程里去执行，等把这些协程都消耗完后，再从调度协程切回来。<br>参考下面图示：<br><img src="/../../../images/image2.png" alt="Alt text"></li>
</ul>
<h2 id="其他情况讨论"><a href="#其他情况讨论" class="headerlink" title="其他情况讨论"></a>其他情况讨论</h2><p><strong>调度器的退出问题</strong></p>
<p> 调度器内部有一个协程任务队列，调度器调度的实质就是内部的线程池从这个任务队列拿任务并执行，那么，停止调度时，如果任务队列还有任务剩余，要怎么处理？这里可以简化处理，强制规定只有所有的任务都完成调度时，调度器才可以退出，如果有一个任务没有执行完，那调度器就不能退出。</p>
<p><strong>主动调用yield让出了执行权问题</strong></p>
<p>任务协程执行过程中主动调用yield让出了执行权，调度器要怎么处理？半路yield的协程显然并没有执行完，一种处理方法是调度器来帮协程擦屁股，在检测到协程从resume返回时，如果状态仍为READY，那么就把协程重新扔回任务列，使其可以再次被调度，这样保证一个协程可以执行结束。但这种策略是画蛇添足的，从生活经验的角度来看，一个成熟的协程肯定要学会自我管理，既然你自己yield了，那么你就应该自己管理好自己，而不是让别人来帮你，这样才算是一个成熟的协程。</p>
<p>对于主动yield的协程，我们的策略是，调度器直接认为这个任务已经调度完了，不再将其加入任务队列。如果协程想完整地运行，那么在yield之前，协程必须先把自己再扔回当前调度器的任务队列里，然后再执行yield，这样才能确保后面还会再来调度这个协程。</p>
<p>sylar的处理方法比较折衷一些，sylar定义了两种yield操作，一种是yield to ready，这种yield调度器会再次将协程加入任务队列并等待调度，另一种是yield to hold，这种yield调度器不会再将协程加入任务队列，协程在yield之前必须自己先将自己加入到协程的调度队列中，否则协程就处于逃逸状态。再说一点，sylar定义的yield to ready，在整个sylar框架内一次都没用到，看来sylar也同意，一个成熟的协程要学会自我管理。</p>
<p><strong>只使用调度器所在的线程进行调度</strong></p>
<p>典型的就是main函数中定义调度器并且只使用main函数线程执行调度任务。这种场景下，可以认为是main函数先攒下一波协程，然后切到调度协程，把这些协程消耗完后再从调度协程切回main函数协程。每个协程在运行时也可以继续创建新的协程并加入调度。如果所有协程都调度完了，并且没有创建新的调度任务，那么下一步就是讨论idle该如何处理。</p>
<p><strong>idle如何处理</strong></p>
<p>也就是当调度器没有协程可调度时，调度协程该怎么办。直觉上来看这里应该有一些同步手段，比如，没有调度任务时，调度协程阻塞住，比如阻塞在一个idle协程上，等待新任务加入后退出idle协程，恢复调度。然而这种方案是无法实现的，因为每个线程同一时间只能有一个协程在执行，如果调度线程阻塞在idle协程上，那么除非idle协程自行让出执行权，否则其他的协程都得不到执行，这里就造成了一个<strong>先有鸡还是先有蛋</strong>的问题：只有创建新任务idle协程才会退出，只有idle协程退出才能创建新任务。为了解决这个问题，sylar采取了一个简单粗暴的办法，如果任务队列空了，调度协程会不停地检测任务队列，看有没有新任务，俗称忙等待，CPU使用率爆表。这点可以从sylar的源码上发现，一是Scheduler的tickle函数什么也不做，因为根本不需要通知调度线程是否有新任务，二是idle协程在协程调度器未停止的情况下只会yield to hold，而调度协程又会将idle协程重新swapIn，相当于idle啥也不做直接返回。这个问题在sylar框架内无解，只有一种方法可以规避掉，那就是设置autostop标志，这个标志会使得调度器在调度完所有任务后自动退出。在后续的IOManager中，上面的问题会得到一定的改善，并且tickle和idle可以实现得更加巧妙一些，以应对IO事件。</p>
<p><strong>只有main函数线程参与调度时的调度执行时机</strong></p>
<p>前面说过，当只有main函数线程参与调度时，可以认为是主线程先攒下一波协程，然后切到调度协程开始调度这些协程，等所有的协程都调度完了，调度协程进idle状态，这个状态下调度器只能执行忙等待，啥也做不了。这也就是说，主线程main函数一旦开启了协程调度，就无法回头了，位于开始调度点之后的代码都执行不到。对于这个问题，sylar把调度器的开始点放在了stop方法中，也就是，调度开始即结束，干完活就下班。IOManager也是类似，除了可以调用stop方法外，IOManager类的析构函数也有一个stop方法，可以保证所有的任务都会被调度到。</p>
<p><strong>额外创建了调度线程时的调度执行时机</strong></p>
<p>如果不额外创建线程，也就是线程数为1并且use caller，那所有的调度任务都在stop()时才会进行调度。但如果额外创建了线程，那么，在添加完调度任务之后任务马上就可以在另一个线程中调度执行。归纳起来，如果只使用caller线程进行调度，那所有的任务协程都在stop之后排队调度，如果有额外线程，那任务协程在刚添加到任务队列时就可以得到调度。</p>
<p><strong>关于协程调度器的优雅停止</strong></p>
<p>sylar停止调度器的策略如下：</p>
<ol>
<li>设置m_stopping标志，该标志表示正在停止</li>
<li>检测是否使用了caller线程进行调度，如果使用了caller线程进行调度，那要保证stop方法是由caller线程发起的</li>
<li>通知其他调度线程的调度协程退出调度</li>
<li>通知当前线程的调度协程退出调度</li>
<li>如果使用了caller线程进行调度，那执行一次caller线程的调度协程（只使用caller线程时的协程调度全仰仗这个操作）</li>
<li>等caller线程的调度协程返回</li>
<li>等所有调度线程结束</li>
</ol>
<h2 id="Sylar协程调度模块实现"><a href="#Sylar协程调度模块实现" class="headerlink" title="Sylar协程调度模块实现"></a>Sylar协程调度模块实现</h2><h3 id="Fiber的修改"><a href="#Fiber的修改" class="headerlink" title="Fiber的修改"></a>Fiber的修改</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">Fiber</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> cb<span class="token punctuation">,</span> size_t stacksize<span class="token punctuation">,</span> <span class="token keyword">bool</span> use_caller<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">m_id</span><span class="token punctuation">(</span><span class="token operator">++</span>s_fiber_id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_cb</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token operator">++</span>s_fiber_count<span class="token punctuation">;</span>
  m_stacksize <span class="token operator">=</span> stacksize <span class="token operator">?</span> stacksize <span class="token operator">:</span> g_fiber_stack_size<span class="token operator">-></span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  m_stack <span class="token operator">=</span> <span class="token class-name">StackAllocator</span><span class="token double-colon punctuation">::</span><span class="token function">Alloc</span><span class="token punctuation">(</span>m_stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"getcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  m_ctx<span class="token punctuation">.</span>uc_link <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  m_ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_sp <span class="token operator">=</span> m_stack<span class="token punctuation">;</span>
  m_ctx<span class="token punctuation">.</span>uc_stack<span class="token punctuation">.</span>ss_size <span class="token operator">=</span> m_stacksize<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>use_caller<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">makecontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Fiber<span class="token double-colon punctuation">::</span>MainFunc<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token function">makecontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Fiber<span class="token double-colon punctuation">::</span>CallerMainFunc<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token function">SYLAR_LOG_DEBUG</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Fiber::Fiber id="</span> <span class="token operator">&lt;&lt;</span> m_id<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 将执行run的线程换出，换为main函数中的主协程执行</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// bug</span>
  <span class="token function">SetThis</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  m_state <span class="token operator">=</span> EXEC<span class="token punctuation">;</span>
  <span class="token comment">// 和swapIn 的区别---> main函数中的主协程-->t_threadFiber</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t_threadFiber<span class="token operator">-></span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"swapcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">SetThis</span><span class="token punctuation">(</span>t_threadFiber<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t_threadFiber<span class="token operator">-></span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"swapcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 切换到当前协程执行</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">swapIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">SetThis</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>m_state <span class="token operator">!=</span> EXEC<span class="token punctuation">)</span><span class="token punctuation">;</span>
  m_state <span class="token operator">=</span> EXEC<span class="token punctuation">;</span>
  <span class="token comment">// 取当前协程的主协程，自己swap自己，会死锁，所以建立了call</span>
  <span class="token comment">// 这里的GetMainFiber--->是指向run函数的那个fiber</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetMainFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"swapcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 把当前协程切换到后台,调度协程换出来</span>
<span class="token keyword">void</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">swapOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">SetThis</span><span class="token punctuation">(</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetMainFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">swapcontext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_ctx<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetMainFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>m_ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"swapcontext"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="对调度任务的定义"><a href="#对调度任务的定义" class="headerlink" title="对调度任务的定义"></a>对调度任务的定义</h3><p>如下，这里任务类型可以是协程&#x2F;函数二选一，并且可指定调度线程。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/**
 * @brief 调度任务，协程/函数二选一，可指定在哪个线程上调度
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">FiberAndThread</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/// 协程</span>
    Fiber<span class="token double-colon punctuation">::</span>ptr fiber<span class="token punctuation">;</span>
    <span class="token comment">/// 协程执行函数</span>
    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> cb<span class="token punctuation">;</span>
    <span class="token comment">/// 线程id，---需要指定协程在哪一个线程上执行</span>
    <span class="token keyword">int</span> thread<span class="token punctuation">;</span>

    <span class="token comment">/**
     * @brief 构造函数
     * @param[in] f 协程
     * @param[in] thr 线程id
     */</span>
    <span class="token function">FiberAndThread</span><span class="token punctuation">(</span>Fiber<span class="token double-colon punctuation">::</span>ptr f<span class="token punctuation">,</span> <span class="token keyword">int</span> thr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">fiber</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">thread</span><span class="token punctuation">(</span>thr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * @brief 构造函数
     * @param[in] f 协程指针
     * @param[in] thr 线程id
     * @post *f = nullptr---swap  todo
     */</span>
    <span class="token function">FiberAndThread</span><span class="token punctuation">(</span>Fiber<span class="token double-colon punctuation">::</span>ptr <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">int</span> thr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">thread</span><span class="token punctuation">(</span>thr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> fiber<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * @brief 构造函数
     * @param[in] f 协程执行函数
     * @param[in] thr 线程id
     */</span>
    <span class="token function">FiberAndThread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> thr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">cb</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">thread</span><span class="token punctuation">(</span>thr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * @brief 构造函数
     * @param[in] f 协程执行函数指针
     * @param[in] thr 线程id
     * @post *f = nullptr
     */</span>
    <span class="token function">FiberAndThread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">int</span> thr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">thread</span><span class="token punctuation">(</span>thr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cb<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * @brief 无参构造函数
     * stl 中一定需要默认构造函数
     */</span>
    <span class="token function">FiberAndThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">thread</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * @brief 重置数据
     */</span>
    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      fiber <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
      cb <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
      thread <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="调度器的成员变量"><a href="#调度器的成员变量" class="headerlink" title="调度器的成员变量"></a>调度器的成员变量</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">private</span><span class="token operator">:</span>
 <span class="token comment">/// Mutex</span>
 MutexType m_mutex<span class="token punctuation">;</span>
 <span class="token comment">/// 线程池</span>
 std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Thread<span class="token double-colon punctuation">::</span>ptr<span class="token operator">></span> m_threads<span class="token punctuation">;</span>
 <span class="token comment">/// 待执行的协程队列</span>
 std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>FiberAndThread<span class="token operator">></span> m_fibers<span class="token punctuation">;</span>
 <span class="token comment">/// use_caller为true时有效, 调度协程</span>
 Fiber<span class="token double-colon punctuation">::</span>ptr m_rootFiber<span class="token punctuation">;</span>
 <span class="token comment">/// 协程调度器名称</span>
 std<span class="token double-colon punctuation">::</span>string m_name<span class="token punctuation">;</span>

<span class="token keyword">protected</span><span class="token operator">:</span>
 <span class="token comment">/// 协程下的线程id数组</span>
 std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> m_threadIds<span class="token punctuation">;</span>
 <span class="token comment">/// 线程数量</span>
 size_t m_threadCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token comment">/// 工作线程数量</span>
 std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">></span> m_activeThreadCount <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
 <span class="token comment">/// 空闲线程数量</span>
 std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>size_t<span class="token operator">></span> m_idleThreadCount <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
 <span class="token comment">/// 用来表示Scheduler::start()是否启动，默认表示未启动</span>
 <span class="token keyword">bool</span> m_stopping <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 <span class="token comment">/// 是否自动停止</span>
 <span class="token comment">// 这个标志会使得调度器在调度完所有任务后自动退出。</span>
 <span class="token keyword">bool</span> m_autoStop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 <span class="token comment">/// 主线程id(use_caller)</span>
 <span class="token keyword">int</span> m_rootThread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="协程调度模块的全局变量和线程局部变量"><a href="#协程调度模块的全局变量和线程局部变量" class="headerlink" title="协程调度模块的全局变量和线程局部变量"></a>协程调度模块的全局变量和线程局部变量</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// 当前线程的调度器，同一个调度器下的所有线程，指向同一个调度器实例</span>
<span class="token keyword">static</span> <span class="token keyword">thread_local</span> Scheduler <span class="token operator">*</span>t_scheduler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token comment">/// 当前线程的调度协程，每个线程都独有一份，包括caller线程</span>
<span class="token keyword">static</span> <span class="token keyword">thread_local</span> Fiber <span class="token operator">*</span>t_scheduler_fiber <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>t_scheduler_fiber保存当前线程的调度协程，加上Fiber模块的t_fiber和t_thread_fiber，每个线程总共可以记录三个协程的上下文信息。</p>
</blockquote>
<h3 id="调度器的构造方法"><a href="#调度器的构造方法" class="headerlink" title="调度器的构造方法"></a>调度器的构造方法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">
<span class="token comment">/**
 * @brief 创建调度器
 * @param[in] threads 线程数
 * @param[in] use_caller 是否将当前线程也作为调度线程
 * @param[in] name 名称
 */</span>
<span class="token comment">// 调度器</span>
<span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">Scheduler</span><span class="token punctuation">(</span>size_t threads<span class="token punctuation">,</span> <span class="token keyword">bool</span> use_caller<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 首先输入的线程要大于0</span>
  <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>threads <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>use_caller<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果此线程没有协程，会给他初始化一个主协程</span>
    sylar<span class="token double-colon punctuation">::</span><span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 因为use_caller,表示当前线程也是调度线程之一。</span>
    <span class="token operator">--</span>threads<span class="token punctuation">;</span>

    <span class="token comment">// 防止此线程创建多个协程调度器。这里的GetThis() 为</span>
    <span class="token comment">// Scheduler *Scheduler::GetThis() &#123; return t_scheduler; &#125;</span>
    <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t_scheduler <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    <span class="token comment">// ??</span>
    m_rootFiber<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Fiber</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Scheduler<span class="token double-colon punctuation">::</span>run<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sylar<span class="token double-colon punctuation">::</span><span class="token class-name">Thread</span><span class="token double-colon punctuation">::</span><span class="token function">SetName</span><span class="token punctuation">(</span>m_name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 修改线程名称</span>

    <span class="token comment">// 在一个线程内声明一个调度器，在将当前线程放入调度器内，他的主协程就不是线程的主协程</span>
    <span class="token comment">// ，而是执行run方法的主协程 主协程。 ？？？ todo</span>
    t_fiber <span class="token operator">=</span> m_rootFiber<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m_rootThread <span class="token operator">=</span> sylar<span class="token double-colon punctuation">::</span><span class="token function">GetThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m_threadIds<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>m_rootThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    m_rootThread <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  m_threadCount <span class="token operator">=</span> threads<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// m_stopping变为true，则表示调度结束</span>
  <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>m_stopping<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    t_scheduler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Scheduler</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>

  <span class="token comment">/**
   * @brief 构造函数
   * @param[in] threads 线程数量
   * @param[in] use_caller 是否使用当前调用线程
   * @param[in] name 协程调度器名称，线程池名称。
   */</span>
  <span class="token function">Scheduler</span><span class="token punctuation">(</span>size_t threads <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> use_caller <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/**
   * @brief 调度协程
   * @param[in] fc 协程或函数
   * @param[in] thread 协程执行的线程id,-1标识任意线程
   */</span>
  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">FiberOrCb</span><span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span>FiberOrCb fc<span class="token punctuation">,</span> <span class="token keyword">int</span> thread <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">bool</span> need_tickle <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#123;</span>
      MutexType<span class="token double-colon punctuation">::</span>Lock <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      need_tickle <span class="token operator">=</span> <span class="token function">scheduleNoLock</span><span class="token punctuation">(</span>fc<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 待执行队列为空时，然后添加了一个带执行的任务， 则执行下面语句，具体细节查看scheduleNoLock</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>need_tickle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">tickle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">/**
   * @brief 批量调度协程
   * @param[in] begin 协程数组的开始
   * @param[in] end 协程数组的结束
   */</span>
  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span>InputIterator begin<span class="token punctuation">,</span> InputIterator end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">bool</span> need_tickle <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#123;</span>
      MutexType<span class="token double-colon punctuation">::</span>Lock <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 参数为指针，取得是地址，会将里面的东西 swap掉。---这里怎么确认是callback还是fiber？？</span>
        need_tickle <span class="token operator">=</span> <span class="token function">scheduleNoLock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> need_tickle<span class="token punctuation">;</span>
        <span class="token operator">++</span>begin<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>need_tickle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">tickle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token comment">/**
   * @brief 协程调度启动(无锁)
   */</span>
  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">FiberOrCb</span><span class="token operator">></span>
  <span class="token keyword">bool</span> <span class="token function">scheduleNoLock</span><span class="token punctuation">(</span>FiberOrCb fc<span class="token punctuation">,</span> <span class="token keyword">int</span> thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">bool</span> need_tickle <span class="token operator">=</span> m_fibers<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true = 空的待执行队列</span>
    FiberAndThread <span class="token function">ft</span><span class="token punctuation">(</span>fc<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 是协程或者function</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ft<span class="token punctuation">.</span>fiber <span class="token operator">||</span> ft<span class="token punctuation">.</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      m_fibers<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 以前是空的，加上一个后不为空了，我就需要唤醒线程，有任务来了</span>
    <span class="token keyword">return</span> need_tickle<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="两个get方法"><a href="#两个get方法" class="headerlink" title="两个get方法"></a>两个get方法</h3><p>用于获取当前线程的调度器的调度协程，这两个都是静态方法</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// static thread_local Scheduler *t_scheduler = nullptr;</span>
Scheduler <span class="token operator">*</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> t_scheduler<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token comment">// 主协程 static thread_local Fiber *t_fiber = nullptr;</span>
Fiber <span class="token operator">*</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetMainFiber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> t_fiber<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h3><p>这里主要初始化调度线程池，如果只使用caller线程进行调度，那这个方法啥也不做：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 启动线程池</span>
<span class="token keyword">void</span> <span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  MutexType<span class="token double-colon punctuation">::</span>Lock <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// m_stopping 默认为true --->表示未启动， false 则为启动</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_stopping<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  m_stopping <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token comment">// 此时线程池应该是空的，未分配线程。</span>
  <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>m_threads<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 此时配置线程池，线程都跑run方法，</span>
  m_threads<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>m_threadCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m_threadCount<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    m_threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>
        <span class="token keyword">new</span> <span class="token function">Thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Scheduler<span class="token double-colon punctuation">::</span>run<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m_name <span class="token operator">+</span> <span class="token string">"_"</span> <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 线程构造函数放置信号量，确保线程跑起来，才能真正拿到线程id。</span>
    m_threadIds<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>m_threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="判断调度器是否已经停止的方法"><a href="#判断调度器是否已经停止的方法" class="headerlink" title="判断调度器是否已经停止的方法"></a>判断调度器是否已经停止的方法</h3><p>只有当所有的任务都被执行完了，调度器才可以停止：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">stopping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    MutexType<span class="token double-colon punctuation">::</span>Lock <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> m_stopping <span class="token operator">&amp;&amp;</span> m_tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> m_activeThreadCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="调度器的tickle和idle实现"><a href="#调度器的tickle和idle实现" class="headerlink" title="调度器的tickle和idle实现"></a>调度器的tickle和idle实现</h3><p>可以看到这两个方法并没有什么用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">tickle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_LOG_DEBUG</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"ticlke"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 没有任务时，执行idle</span>
<span class="token keyword">void</span> <span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">idle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">SYLAR_LOG_INFO</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"idle"</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">stopping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    sylar<span class="token double-colon punctuation">::</span><span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">YieldToHold</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>由于Fiber类改造过，每个被调度器执行的协程在结束时都会回到调度协程，所以这里不用担心跑飞问题，当任务队列为空时，代码会进idle协程，但idle协程啥也不做直接就yield了，状态还是READY状态，所以这里其实就是个忙等待，CPU占用率爆炸，只有当调度器检测到停止标志时，idle协程才会真正结束，调度协程也会检测到idle协程状态为TERM，并且随之退出整个调度协程。这里还可以看出一点，对于一个任务协程，只要其从resume中返回了，那不管它的状态是TERM还是READY，调度器都不会自动将其再次加入调度，因为前面说过，一个成熟的协程是要学会自我管理的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 核心--->协程和线程的关系</span>
<span class="token comment">// 首先设置当前线程的schedule</span>
<span class="token comment">// 设置当前线程的 run  fiber</span>
<span class="token comment">// 写成调度循环while(true)</span>
<span class="token comment">//   消息队列里是否有任务</span>
<span class="token comment">//   无任务执行，执行idle</span>

<span class="token comment">// 这个run 一个线程只会有一个协程来执行</span>
<span class="token comment">// 一个是use_caller的线程在run执行,线程池里面自己创建的线程也在run中执行</span>
<span class="token keyword">void</span> <span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 设置当前的协程调度器</span>
  <span class="token function">setThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果当前线程id != 主协程id</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>sylar<span class="token double-colon punctuation">::</span><span class="token function">GetThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> m_rootThread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 就将主fiber 设置为当前线程id</span>
    t_fiber <span class="token operator">=</span> <span class="token class-name">Fiber</span><span class="token double-colon punctuation">::</span><span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  Fiber<span class="token double-colon punctuation">::</span>ptr <span class="token function">idle_fiber</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Fiber</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Scheduler<span class="token double-colon punctuation">::</span>idle<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Fiber<span class="token double-colon punctuation">::</span>ptr cb_fiber<span class="token punctuation">;</span>

  <span class="token comment">// 协程和线程</span>
  FiberAndThread ft<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ft<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> tickle_me <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 防止协程调度结束</span>
    <span class="token keyword">bool</span> is_active <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 协程的消息队列中，取出一个协程任务</span>
    <span class="token punctuation">&#123;</span>
      MutexType<span class="token double-colon punctuation">::</span>Lock <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">auto</span> it <span class="token operator">=</span> m_fibers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> m_fibers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 如果一个任务(协程)已经指定好在哪个线程执行，我当前执行run的线程id != 他期望的线程id</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token operator">-></span>thread <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> it<span class="token operator">-></span>thread <span class="token operator">!=</span> sylar<span class="token double-colon punctuation">::</span><span class="token function">GetThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token operator">++</span>it<span class="token punctuation">;</span>
          <span class="token comment">// 通知别人来处理，后面可以优化，通知这里。</span>
          tickle_me <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// fiber cb 至少要有一个，确定任务非空</span>
        <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span>it<span class="token operator">-></span>fiber <span class="token operator">||</span> it<span class="token operator">-></span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// exec--正在执行状态，此时也不处理。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token operator">-></span>fiber <span class="token operator">&amp;&amp;</span> it<span class="token operator">-></span>fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Fiber<span class="token double-colon punctuation">::</span>EXEC<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token operator">++</span>it<span class="token punctuation">;</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 开始处理</span>
        ft <span class="token operator">=</span> <span class="token operator">*</span>it<span class="token punctuation">;</span>
        tickle_me <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        m_fibers<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从待处理队列中删除，这里注意迭代器删除的细节，当心bug</span>
        <span class="token operator">++</span>m_activeThreadCount<span class="token punctuation">;</span>
        is_active <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// while 只循环一次，目的是依次处理每个待处理的任务。</span>
      <span class="token punctuation">&#125;</span>
      <span class="token comment">// tickle_me |= it != m_fibers.end(); todo</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//取出了一个需要执行任务，唤醒其他线程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tickle_me<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">tickle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 执行这个协程，fiber的方式</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ft<span class="token punctuation">.</span>fiber <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>ft<span class="token punctuation">.</span>fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Fiber<span class="token double-colon punctuation">::</span>TERM <span class="token operator">&amp;&amp;</span> ft<span class="token punctuation">.</span>fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Fiber<span class="token double-colon punctuation">::</span>EXCEPT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 执行 ft，唤醒，去执行</span>
      ft<span class="token punctuation">.</span>fiber<span class="token operator">-></span><span class="token function">swapIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 执行完之后，数量--</span>
      <span class="token operator">--</span>m_activeThreadCount<span class="token punctuation">;</span>
      <span class="token comment">// 判断是否需要再次执行</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>ft<span class="token punctuation">.</span>fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Fiber<span class="token double-colon punctuation">::</span>READY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">schedule</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ft<span class="token punctuation">.</span>fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Fiber<span class="token double-colon punctuation">::</span>TERM <span class="token operator">&amp;&amp;</span> ft<span class="token punctuation">.</span>fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Fiber<span class="token double-colon punctuation">::</span>EXCEPT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 设置暂停状态，除了上面的判断的语句外，除了ready， 就是hold状态</span>
        ft<span class="token punctuation">.</span>fiber<span class="token operator">-></span>m_state <span class="token operator">=</span> Fiber<span class="token double-colon punctuation">::</span>HOLD<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token comment">// FiberAndThread::reset</span>
      ft<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 执行这个协程，cb 的方式</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ft<span class="token punctuation">.</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cb_fiber<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 重置协程状态，</span>
        cb_fiber<span class="token operator">-></span><span class="token function">reset</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 智能指针的 reset</span>
        cb_fiber<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Fiber</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span>cb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token comment">// 释放掉</span>
      ft<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 唤醒cb_fiber</span>
      cb_fiber<span class="token operator">-></span><span class="token function">swapIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 运行结束后</span>
      <span class="token operator">--</span>m_activeThreadCount<span class="token punctuation">;</span>
      <span class="token comment">// 判断是否需要再次执行</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cb_fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Fiber<span class="token double-colon punctuation">::</span>READY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">schedule</span><span class="token punctuation">(</span>cb_fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cb_fiber<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 智能指针reset</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cb_fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Fiber<span class="token double-colon punctuation">::</span>EXCEPT <span class="token operator">||</span> cb_fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Fiber<span class="token double-colon punctuation">::</span>TERM<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cb_fiber<span class="token operator">-></span><span class="token function">reset</span><span class="token punctuation">(</span>
            <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 出现异常或者执行完成，智能指针的reset，释放掉，并没有引起他的析构</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>  <span class="token comment">// if (cb_fiber->getState() != Fiber::TERM)</span>
      <span class="token punctuation">&#123;</span>
        <span class="token comment">// 没有结束，设置暂停状态</span>
        cb_fiber<span class="token operator">-></span>m_state <span class="token operator">=</span> Fiber<span class="token double-colon punctuation">::</span>HOLD<span class="token punctuation">;</span>
        cb_fiber<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 调度协程，后面这里表示没有任务执行，事情做完之后</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>is_active<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token operator">--</span>m_activeThreadCount<span class="token punctuation">;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token comment">// fiber已经结束，直接break</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>idle_fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Fiber<span class="token double-colon punctuation">::</span>TERM<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">SYLAR_LOG_INFO</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"idle fiber term"</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>

      <span class="token comment">// 空闲线程数 ++</span>
      <span class="token operator">++</span>m_idleThreadCount<span class="token punctuation">;</span>
      <span class="token comment">// idle_fiber 去执行，---***每个线程，同一时刻只有一个协程在执行。</span>
      <span class="token comment">// ？？在执行idle_fiber时，来了任务要怎么唤醒</span>
      idle_fiber<span class="token operator">-></span><span class="token function">swapIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">--</span>m_idleThreadCount<span class="token punctuation">;</span>
      <span class="token comment">// if (idle_fiber->getState() != Fiber::TERM || idle_fiber->getState() != Fiber::EXCEPT) //</span>
      <span class="token comment">// ---> bug</span>
      <span class="token comment">// idle_fiber执行完之后，判断状态来进行处理，</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>idle_fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Fiber<span class="token double-colon punctuation">::</span>TERM <span class="token operator">&amp;&amp;</span> idle_fiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Fiber<span class="token double-colon punctuation">::</span>EXCEPT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        idle_fiber<span class="token operator">-></span>m_state <span class="token operator">=</span> Fiber<span class="token double-colon punctuation">::</span>HOLD<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 优雅退出，等待所有任务完成退出</span>
<span class="token comment">// 线程没事做时，需要循环等待，stop就是做一个等的动作</span>
<span class="token keyword">void</span> <span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 两种情况</span>
  <span class="token comment">// 一种是用了 use_caller。 -- 必须要去创建schedule的哪个线程去执行stop。</span>
  <span class="token comment">// 一种是未使用， 对应额外创建一个线程进行协程调度、main函数线程不参与调度的情况。</span>
  m_autoStop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">// m_rootFiber是指创建schedule方法的线程中的协程的里面的执行run的那个协程-->调度协程;</span>
  <span class="token comment">// TERM --->结束状态, INIT---> 初始化状态</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m_rootFiber <span class="token operator">&amp;&amp;</span> m_threadCount <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>m_rootFiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Fiber<span class="token double-colon punctuation">::</span>TERM <span class="token operator">||</span> m_rootFiber<span class="token operator">-></span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Fiber<span class="token double-colon punctuation">::</span>INIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_LOG_INFO</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"stopped"</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时已结束，或者未跑起来，那么我们就要设置结束</span>
    m_stopping <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 自己写的bug</span>
    <span class="token comment">// if (m_stopping) &#123;</span>
    <span class="token comment">//   return;</span>
    <span class="token comment">// &#125;</span>

    <span class="token comment">// use_caller 并且只有一个线程的时候，从这里返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stopping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// m_rootThread != -1，说明是 use_caller 线程</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m_rootThread <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 目的是，把创建它的哪个线程也使用上时，stop一定要在创建他的那个线程执行</span>
    <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span><span class="token class-name">Scheduler</span><span class="token double-colon punctuation">::</span><span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SYLAR_ASSERT</span><span class="token punctuation">(</span><span class="token function">GetThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// 设置为true 表示可以结束</span>
  m_stopping <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m_threadCount<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 使线程唤醒</span>
    <span class="token function">tickle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>m_rootFiber<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">tickle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">/// 在use caller情况下，调度器协程结束时，应该返回caller协程</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m_rootFiber<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">stopping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      m_rootFiber<span class="token operator">-></span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">SYLAR_LOG_DEBUG</span><span class="token punctuation">(</span>g_logger<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"m_rootFiber end"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>

  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Thread<span class="token double-colon punctuation">::</span>ptr<span class="token operator">></span> thrs<span class="token punctuation">;</span>
  <span class="token punctuation">&#123;</span>
    MutexType<span class="token double-colon punctuation">::</span>Lock <span class="token function">lock</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    thrs<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>m_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// 所有线程 join</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i <span class="token operator">:</span> thrs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i<span class="token operator">-></span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意事项</strong><br>sylar的协程调度模块因为存任务队列空闲时调度线程忙等待的问题，所以实际上并不实用，真正实用的是后面基于Scheduler实现的IOManager。由于任务队列的任务是按顺序执行的，如果有一个任务占用了比较长时间，那其他任务的执行会受到影响，如果任务执行的是像while(1)这样的循环，那线程数不够时，后面的任务都不会得到执行。另外，当前还没有实现hook功能，像sleep和等待IO就绪这样的操作也会阻塞协程调度。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060963">https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060963</a></p>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/2023/10/19/sylar/c++/set%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0/">set自定义比较函数</a></li>
                
                
                    <li>下一篇: <a href="/2023/10/16/sylar/%E6%A8%A1%E5%9D%97/%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97/">协程模块</a></li>
                
            </ul>
        </section>
        
            <section class="post-tags">
            <a class="-none-link" href="/tags/sylar/" rel="tag">sylar</a>
            </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://sdn.geekzu.org/avatar/d22eb460ecab37fcd7205e6a3c55c228?s=200&r=X&d=" alt="木偶人" />
            </figure>
        
            <div class="author-info">
                <h4>木偶人</h4>
                <p>...</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/01/05/%E9%9F%B3%E8%A7%86%E9%A2%91/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/YUV%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D/">YUV格式介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/04/cmake/cmake/">cmake</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/01/02/cpp/practice/%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">对象生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/22/cpp/c++11/%E5%B0%8F%E5%B0%8F%E7%9A%84operator-%E7%AB%9F%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E7%BB%86%E8%8A%82/">小小的operator=竟有这么多细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/19/my_stl/vector/">自己实现STL之vector</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/18/cpp/c++11/std-allocator/">std::allocator堆内存管理器</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-date">时光机：</h3>
                    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-tags">标签云：</h3>
                    <a href="/tags/FFmpeg/" style="font-size: 15px;">FFmpeg</a> <a href="/tags/FFplay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 15px;">FFplay源码分析</a> <a href="/tags/c/" style="font-size: 12.5px;">c++</a> <a href="/tags/c-11/" style="font-size: 15px;">c++11</a> <a href="/tags/c-17/" style="font-size: 10px;">c++17</a> <a href="/tags/c-20/" style="font-size: 10px;">c++20</a> <a href="/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/tags/error/" style="font-size: 12.5px;">error</a> <a href="/tags/leetcode/" style="font-size: 17.5px;">leetcode</a> <a href="/tags/muduo/" style="font-size: 10px;">muduo</a> <a href="/tags/my-stl/" style="font-size: 10px;">my_stl</a> <a href="/tags/plan/" style="font-size: 10px;">plan</a> <a href="/tags/sylar/" style="font-size: 20px;">sylar</a> <a href="/tags/vscode/" style="font-size: 10px;">vscode</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">音视频基础知识</a>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2024 <a href="/">木偶人</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":true,"night":true});</script>

  </body>
</html>
